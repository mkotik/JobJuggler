/**
 * Client
 **/

import * as runtime from "@prisma/client/runtime/library.js";
import $Types = runtime.Types; // general types
import $Public = runtime.Types.Public;
import $Utils = runtime.Types.Utils;
import $Extensions = runtime.Types.Extensions;
import $Result = runtime.Types.Result;

export type PrismaPromise<T> = $Public.PrismaPromise<T>;

/**
 * Model Taxes
 *
 */
export type Taxes = $Result.DefaultSelection<Prisma.$TaxesPayload>;
/**
 * Model Addresses
 *
 */
export type Addresses = $Result.DefaultSelection<Prisma.$AddressesPayload>;
/**
 * Model Users
 *
 */
export type Users = $Result.DefaultSelection<Prisma.$UsersPayload>;
/**
 * Model Clients
 *
 */
export type Clients = $Result.DefaultSelection<Prisma.$ClientsPayload>;
/**
 * Model Assessments
 *
 */
export type Assessments = $Result.DefaultSelection<Prisma.$AssessmentsPayload>;
/**
 * Model Requests
 *
 */
export type Requests = $Result.DefaultSelection<Prisma.$RequestsPayload>;
/**
 * Model LineItems
 *
 */
export type LineItems = $Result.DefaultSelection<Prisma.$LineItemsPayload>;
/**
 * Model Quotes
 *
 */
export type Quotes = $Result.DefaultSelection<Prisma.$QuotesPayload>;
/**
 * Model LineItemQuote
 *
 */
export type LineItemQuote =
  $Result.DefaultSelection<Prisma.$LineItemQuotePayload>;
/**
 * Model QuoteRequest
 *
 */
export type QuoteRequest =
  $Result.DefaultSelection<Prisma.$QuoteRequestPayload>;
/**
 * Model Jobs
 *
 */
export type Jobs = $Result.DefaultSelection<Prisma.$JobsPayload>;
/**
 * Model LineItemJob
 *
 */
export type LineItemJob = $Result.DefaultSelection<Prisma.$LineItemJobPayload>;
/**
 * Model JobRequest
 *
 */
export type JobRequest = $Result.DefaultSelection<Prisma.$JobRequestPayload>;
/**
 * Model JobQuote
 *
 */
export type JobQuote = $Result.DefaultSelection<Prisma.$JobQuotePayload>;
/**
 * Model Invoices
 *
 */
export type Invoices = $Result.DefaultSelection<Prisma.$InvoicesPayload>;
/**
 * Model LineItemInvoice
 *
 */
export type LineItemInvoice =
  $Result.DefaultSelection<Prisma.$LineItemInvoicePayload>;

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Taxes
 * const taxes = await prisma.taxes.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = "log" extends keyof T
    ? T["log"] extends Array<Prisma.LogLevel | Prisma.LogDefinition>
      ? Prisma.GetEvents<T["log"]>
      : never
    : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>["other"] };

  /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Taxes
   * const taxes = await prisma.taxes.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(
    eventType: V,
    callback: (
      event: V extends "query" ? Prisma.QueryEvent : Prisma.LogEvent
    ) => void
  ): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void;

  /**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(
    query: TemplateStringsArray | Prisma.Sql,
    ...values: any[]
  ): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(
    query: string,
    ...values: any[]
  ): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(
    query: TemplateStringsArray | Prisma.Sql,
    ...values: any[]
  ): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(
    query: string,
    ...values: any[]
  ): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(
    arg: [...P],
    options?: { isolationLevel?: Prisma.TransactionIsolationLevel }
  ): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>;

  $transaction<R>(
    fn: (
      prisma: Omit<PrismaClient, runtime.ITXClientDenyList>
    ) => $Utils.JsPromise<R>,
    options?: {
      maxWait?: number;
      timeout?: number;
      isolationLevel?: Prisma.TransactionIsolationLevel;
    }
  ): $Utils.JsPromise<R>;

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>;

  /**
   * `prisma.taxes`: Exposes CRUD operations for the **Taxes** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Taxes
   * const taxes = await prisma.taxes.findMany()
   * ```
   */
  get taxes(): Prisma.TaxesDelegate<ExtArgs>;

  /**
   * `prisma.addresses`: Exposes CRUD operations for the **Addresses** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Addresses
   * const addresses = await prisma.addresses.findMany()
   * ```
   */
  get addresses(): Prisma.AddressesDelegate<ExtArgs>;

  /**
   * `prisma.users`: Exposes CRUD operations for the **Users** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Users
   * const users = await prisma.users.findMany()
   * ```
   */
  get users(): Prisma.UsersDelegate<ExtArgs>;

  /**
   * `prisma.clients`: Exposes CRUD operations for the **Clients** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Clients
   * const clients = await prisma.clients.findMany()
   * ```
   */
  get clients(): Prisma.ClientsDelegate<ExtArgs>;

  /**
   * `prisma.assessments`: Exposes CRUD operations for the **Assessments** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Assessments
   * const assessments = await prisma.assessments.findMany()
   * ```
   */
  get assessments(): Prisma.AssessmentsDelegate<ExtArgs>;

  /**
   * `prisma.requests`: Exposes CRUD operations for the **Requests** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Requests
   * const requests = await prisma.requests.findMany()
   * ```
   */
  get requests(): Prisma.RequestsDelegate<ExtArgs>;

  /**
   * `prisma.lineItems`: Exposes CRUD operations for the **LineItems** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more LineItems
   * const lineItems = await prisma.lineItems.findMany()
   * ```
   */
  get lineItems(): Prisma.LineItemsDelegate<ExtArgs>;

  /**
   * `prisma.quotes`: Exposes CRUD operations for the **Quotes** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Quotes
   * const quotes = await prisma.quotes.findMany()
   * ```
   */
  get quotes(): Prisma.QuotesDelegate<ExtArgs>;

  /**
   * `prisma.lineItemQuote`: Exposes CRUD operations for the **LineItemQuote** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more LineItemQuotes
   * const lineItemQuotes = await prisma.lineItemQuote.findMany()
   * ```
   */
  get lineItemQuote(): Prisma.LineItemQuoteDelegate<ExtArgs>;

  /**
   * `prisma.quoteRequest`: Exposes CRUD operations for the **QuoteRequest** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more QuoteRequests
   * const quoteRequests = await prisma.quoteRequest.findMany()
   * ```
   */
  get quoteRequest(): Prisma.QuoteRequestDelegate<ExtArgs>;

  /**
   * `prisma.jobs`: Exposes CRUD operations for the **Jobs** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Jobs
   * const jobs = await prisma.jobs.findMany()
   * ```
   */
  get jobs(): Prisma.JobsDelegate<ExtArgs>;

  /**
   * `prisma.lineItemJob`: Exposes CRUD operations for the **LineItemJob** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more LineItemJobs
   * const lineItemJobs = await prisma.lineItemJob.findMany()
   * ```
   */
  get lineItemJob(): Prisma.LineItemJobDelegate<ExtArgs>;

  /**
   * `prisma.jobRequest`: Exposes CRUD operations for the **JobRequest** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more JobRequests
   * const jobRequests = await prisma.jobRequest.findMany()
   * ```
   */
  get jobRequest(): Prisma.JobRequestDelegate<ExtArgs>;

  /**
   * `prisma.jobQuote`: Exposes CRUD operations for the **JobQuote** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more JobQuotes
   * const jobQuotes = await prisma.jobQuote.findMany()
   * ```
   */
  get jobQuote(): Prisma.JobQuoteDelegate<ExtArgs>;

  /**
   * `prisma.invoices`: Exposes CRUD operations for the **Invoices** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Invoices
   * const invoices = await prisma.invoices.findMany()
   * ```
   */
  get invoices(): Prisma.InvoicesDelegate<ExtArgs>;

  /**
   * `prisma.lineItemInvoice`: Exposes CRUD operations for the **LineItemInvoice** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more LineItemInvoices
   * const lineItemInvoices = await prisma.lineItemInvoice.findMany()
   * ```
   */
  get lineItemInvoice(): Prisma.LineItemInvoiceDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF;

  export type PrismaPromise<T> = $Public.PrismaPromise<T>;

  /**
   * Validator
   */
  export import validator = runtime.Public.validator;

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError;
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError;
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError;
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError;
  export import PrismaClientValidationError = runtime.PrismaClientValidationError;
  export import NotFoundError = runtime.NotFoundError;

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag;
  export import empty = runtime.empty;
  export import join = runtime.join;
  export import raw = runtime.raw;
  export import Sql = runtime.Sql;

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal;

  export type DecimalJsLike = runtime.DecimalJsLike;

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics;
  export type Metric<T> = runtime.Metric<T>;
  export type MetricHistogram = runtime.MetricHistogram;
  export type MetricHistogramBucket = runtime.MetricHistogramBucket;

  /**
   * Extensions
   */
  export import Extension = $Extensions.UserArgs;
  export import getExtensionContext = runtime.Extensions.getExtensionContext;
  export import Args = $Public.Args;
  export import Payload = $Public.Payload;
  export import Result = $Public.Result;
  export import Exact = $Public.Exact;

  /**
   * Prisma Client JS version: 5.12.1
   * Query Engine version: 473ed3124229e22d881cb7addf559799debae1ab
   */
  export type PrismaVersion = {
    client: string;
  };

  export const prismaVersion: PrismaVersion;

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from.
   */
  export type JsonObject = { [Key in string]?: JsonValue };

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue =
    | string
    | number
    | boolean
    | JsonObject
    | JsonArray
    | null;

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {
    readonly [Key in string]?: InputJsonValue | null;
  };

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray
    extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue =
    | string
    | number
    | boolean
    | InputJsonObject
    | InputJsonArray
    | { toJSON(): unknown };

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
     * Type of `Prisma.DbNull`.
     *
     * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    class DbNull {
      private DbNull: never;
      private constructor();
    }

    /**
     * Type of `Prisma.JsonNull`.
     *
     * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    class JsonNull {
      private JsonNull: never;
      private constructor();
    }

    /**
     * Type of `Prisma.AnyNull`.
     *
     * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    class AnyNull {
      private AnyNull: never;
      private constructor();
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull;

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull;

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull;

  type SelectAndInclude = {
    select: any;
    include: any;
  };

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<
    infer U
  >
    ? U
    : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<
    T extends (...args: any) => $Utils.JsPromise<any>
  > = PromiseType<ReturnType<T>>;

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
    [P in K]: T[P];
  };

  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K;
  }[keyof T];

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K;
  };

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>;

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  } & (T extends SelectAndInclude
    ? "Please either choose `select` or `include`."
    : {});

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  } & K;

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> = T extends object
    ? U extends object
      ? (Without<T, U> & U) | (Without<U, T> & T)
      : U
    : T;

  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
    ? False
    : T extends Date
    ? False
    : T extends Uint8Array
    ? False
    : T extends BigInt
    ? False
    : T extends object
    ? True
    : False;

  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T;

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O>; // With K possibilities
    }[K];

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>;

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<
    __Either<O, K>
  >;

  type _Either<O extends object, K extends Key, strict extends Boolean> = {
    1: EitherStrict<O, K>;
    0: EitherLoose<O, K>;
  }[strict];

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never;

  export type Union = any;

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K];
  } & {};

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never;

  export type Overwrite<O extends object, O1 extends object> = {
    [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<
    Overwrite<
      U,
      {
        [K in keyof U]-?: At<U, K>;
      }
    >
  >;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O
    ? O[K]
    : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown
    ? AtStrict<O, K>
    : never;
  export type At<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = {
    1: AtStrict<O, K>;
    0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function
    ? A
    : {
        [K in keyof A]: A[K];
      } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
      ?
          | (K extends keyof O ? { [P in K]: O[P] } & O : O)
          | ({ [P in keyof O as P extends K ? K : never]-?: O[P] } & O)
      : never
  >;

  type _Strict<U, _U = U> = U extends unknown
    ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>>
    : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False;

  // /**
  // 1
  // */
  export type True = 1;

  /**
  0
  */
  export type False = 0;

  export type Not<B extends Boolean> = {
    0: 1;
    1: 0;
  }[B];

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0;

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >;

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0;
      1: 1;
    };
    1: {
      0: 1;
      1: 1;
    };
  }[B1][B2];

  export type Keys<U extends Union> = U extends unknown ? keyof U : never;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object
    ? {
        [P in keyof T]: P extends keyof O ? O[P] : never;
      }
    : never;

  type FieldPaths<
    T,
    U = Omit<T, "_avg" | "_sum" | "_count" | "_min" | "_max">
  > = IsObject<T> extends True ? U : T;

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<"OR", K>, Extends<"AND", K>>,
      Extends<"NOT", K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<
            UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never
          >
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K;
  }[keyof T];

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never;
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>;
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T;

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<
    T,
    K extends Enumerable<keyof T> | keyof T
  > = Prisma__Pick<T, MaybeTupleToUnion<K>>;

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}`
    ? never
    : T;

  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>;

  type FieldRefInputType<Model, FieldType> = Model extends never
    ? never
    : FieldRef<Model, FieldType>;

  export const ModelName: {
    Taxes: "Taxes";
    Addresses: "Addresses";
    Users: "Users";
    Clients: "Clients";
    Assessments: "Assessments";
    Requests: "Requests";
    LineItems: "LineItems";
    Quotes: "Quotes";
    LineItemQuote: "LineItemQuote";
    QuoteRequest: "QuoteRequest";
    Jobs: "Jobs";
    LineItemJob: "LineItemJob";
    JobRequest: "JobRequest";
    JobQuote: "JobQuote";
    Invoices: "Invoices";
    LineItemInvoice: "LineItemInvoice";
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName];

  export type Datasources = {
    db?: Datasource;
  };

  interface TypeMapCb
    extends $Utils.Fn<
      { extArgs: $Extensions.InternalArgs },
      $Utils.Record<string, any>
    > {
    returns: Prisma.TypeMap<this["params"]["extArgs"]>;
  }

  export type TypeMap<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    meta: {
      modelProps:
        | "taxes"
        | "addresses"
        | "users"
        | "clients"
        | "assessments"
        | "requests"
        | "lineItems"
        | "quotes"
        | "lineItemQuote"
        | "quoteRequest"
        | "jobs"
        | "lineItemJob"
        | "jobRequest"
        | "jobQuote"
        | "invoices"
        | "lineItemInvoice";
      txIsolationLevel: Prisma.TransactionIsolationLevel;
    };
    model: {
      Taxes: {
        payload: Prisma.$TaxesPayload<ExtArgs>;
        fields: Prisma.TaxesFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.TaxesFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TaxesPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.TaxesFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TaxesPayload>;
          };
          findFirst: {
            args: Prisma.TaxesFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TaxesPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.TaxesFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TaxesPayload>;
          };
          findMany: {
            args: Prisma.TaxesFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TaxesPayload>[];
          };
          create: {
            args: Prisma.TaxesCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TaxesPayload>;
          };
          createMany: {
            args: Prisma.TaxesCreateManyArgs<ExtArgs>;
            result: Prisma.BatchPayload;
          };
          delete: {
            args: Prisma.TaxesDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TaxesPayload>;
          };
          update: {
            args: Prisma.TaxesUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TaxesPayload>;
          };
          deleteMany: {
            args: Prisma.TaxesDeleteManyArgs<ExtArgs>;
            result: Prisma.BatchPayload;
          };
          updateMany: {
            args: Prisma.TaxesUpdateManyArgs<ExtArgs>;
            result: Prisma.BatchPayload;
          };
          upsert: {
            args: Prisma.TaxesUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TaxesPayload>;
          };
          aggregate: {
            args: Prisma.TaxesAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateTaxes>;
          };
          groupBy: {
            args: Prisma.TaxesGroupByArgs<ExtArgs>;
            result: $Utils.Optional<TaxesGroupByOutputType>[];
          };
          count: {
            args: Prisma.TaxesCountArgs<ExtArgs>;
            result: $Utils.Optional<TaxesCountAggregateOutputType> | number;
          };
        };
      };
      Addresses: {
        payload: Prisma.$AddressesPayload<ExtArgs>;
        fields: Prisma.AddressesFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.AddressesFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AddressesPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.AddressesFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AddressesPayload>;
          };
          findFirst: {
            args: Prisma.AddressesFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AddressesPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.AddressesFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AddressesPayload>;
          };
          findMany: {
            args: Prisma.AddressesFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AddressesPayload>[];
          };
          create: {
            args: Prisma.AddressesCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AddressesPayload>;
          };
          createMany: {
            args: Prisma.AddressesCreateManyArgs<ExtArgs>;
            result: Prisma.BatchPayload;
          };
          delete: {
            args: Prisma.AddressesDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AddressesPayload>;
          };
          update: {
            args: Prisma.AddressesUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AddressesPayload>;
          };
          deleteMany: {
            args: Prisma.AddressesDeleteManyArgs<ExtArgs>;
            result: Prisma.BatchPayload;
          };
          updateMany: {
            args: Prisma.AddressesUpdateManyArgs<ExtArgs>;
            result: Prisma.BatchPayload;
          };
          upsert: {
            args: Prisma.AddressesUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AddressesPayload>;
          };
          aggregate: {
            args: Prisma.AddressesAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateAddresses>;
          };
          groupBy: {
            args: Prisma.AddressesGroupByArgs<ExtArgs>;
            result: $Utils.Optional<AddressesGroupByOutputType>[];
          };
          count: {
            args: Prisma.AddressesCountArgs<ExtArgs>;
            result: $Utils.Optional<AddressesCountAggregateOutputType> | number;
          };
        };
      };
      Users: {
        payload: Prisma.$UsersPayload<ExtArgs>;
        fields: Prisma.UsersFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.UsersFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UsersPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.UsersFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>;
          };
          findFirst: {
            args: Prisma.UsersFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UsersPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.UsersFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>;
          };
          findMany: {
            args: Prisma.UsersFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>[];
          };
          create: {
            args: Prisma.UsersCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>;
          };
          createMany: {
            args: Prisma.UsersCreateManyArgs<ExtArgs>;
            result: Prisma.BatchPayload;
          };
          delete: {
            args: Prisma.UsersDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>;
          };
          update: {
            args: Prisma.UsersUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>;
          };
          deleteMany: {
            args: Prisma.UsersDeleteManyArgs<ExtArgs>;
            result: Prisma.BatchPayload;
          };
          updateMany: {
            args: Prisma.UsersUpdateManyArgs<ExtArgs>;
            result: Prisma.BatchPayload;
          };
          upsert: {
            args: Prisma.UsersUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>;
          };
          aggregate: {
            args: Prisma.UsersAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateUsers>;
          };
          groupBy: {
            args: Prisma.UsersGroupByArgs<ExtArgs>;
            result: $Utils.Optional<UsersGroupByOutputType>[];
          };
          count: {
            args: Prisma.UsersCountArgs<ExtArgs>;
            result: $Utils.Optional<UsersCountAggregateOutputType> | number;
          };
        };
      };
      Clients: {
        payload: Prisma.$ClientsPayload<ExtArgs>;
        fields: Prisma.ClientsFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.ClientsFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ClientsPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.ClientsFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ClientsPayload>;
          };
          findFirst: {
            args: Prisma.ClientsFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ClientsPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.ClientsFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ClientsPayload>;
          };
          findMany: {
            args: Prisma.ClientsFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ClientsPayload>[];
          };
          create: {
            args: Prisma.ClientsCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ClientsPayload>;
          };
          createMany: {
            args: Prisma.ClientsCreateManyArgs<ExtArgs>;
            result: Prisma.BatchPayload;
          };
          delete: {
            args: Prisma.ClientsDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ClientsPayload>;
          };
          update: {
            args: Prisma.ClientsUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ClientsPayload>;
          };
          deleteMany: {
            args: Prisma.ClientsDeleteManyArgs<ExtArgs>;
            result: Prisma.BatchPayload;
          };
          updateMany: {
            args: Prisma.ClientsUpdateManyArgs<ExtArgs>;
            result: Prisma.BatchPayload;
          };
          upsert: {
            args: Prisma.ClientsUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ClientsPayload>;
          };
          aggregate: {
            args: Prisma.ClientsAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateClients>;
          };
          groupBy: {
            args: Prisma.ClientsGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ClientsGroupByOutputType>[];
          };
          count: {
            args: Prisma.ClientsCountArgs<ExtArgs>;
            result: $Utils.Optional<ClientsCountAggregateOutputType> | number;
          };
        };
      };
      Assessments: {
        payload: Prisma.$AssessmentsPayload<ExtArgs>;
        fields: Prisma.AssessmentsFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.AssessmentsFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AssessmentsPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.AssessmentsFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AssessmentsPayload>;
          };
          findFirst: {
            args: Prisma.AssessmentsFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AssessmentsPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.AssessmentsFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AssessmentsPayload>;
          };
          findMany: {
            args: Prisma.AssessmentsFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AssessmentsPayload>[];
          };
          create: {
            args: Prisma.AssessmentsCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AssessmentsPayload>;
          };
          createMany: {
            args: Prisma.AssessmentsCreateManyArgs<ExtArgs>;
            result: Prisma.BatchPayload;
          };
          delete: {
            args: Prisma.AssessmentsDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AssessmentsPayload>;
          };
          update: {
            args: Prisma.AssessmentsUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AssessmentsPayload>;
          };
          deleteMany: {
            args: Prisma.AssessmentsDeleteManyArgs<ExtArgs>;
            result: Prisma.BatchPayload;
          };
          updateMany: {
            args: Prisma.AssessmentsUpdateManyArgs<ExtArgs>;
            result: Prisma.BatchPayload;
          };
          upsert: {
            args: Prisma.AssessmentsUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AssessmentsPayload>;
          };
          aggregate: {
            args: Prisma.AssessmentsAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateAssessments>;
          };
          groupBy: {
            args: Prisma.AssessmentsGroupByArgs<ExtArgs>;
            result: $Utils.Optional<AssessmentsGroupByOutputType>[];
          };
          count: {
            args: Prisma.AssessmentsCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<AssessmentsCountAggregateOutputType>
              | number;
          };
        };
      };
      Requests: {
        payload: Prisma.$RequestsPayload<ExtArgs>;
        fields: Prisma.RequestsFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.RequestsFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RequestsPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.RequestsFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RequestsPayload>;
          };
          findFirst: {
            args: Prisma.RequestsFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RequestsPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.RequestsFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RequestsPayload>;
          };
          findMany: {
            args: Prisma.RequestsFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RequestsPayload>[];
          };
          create: {
            args: Prisma.RequestsCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RequestsPayload>;
          };
          createMany: {
            args: Prisma.RequestsCreateManyArgs<ExtArgs>;
            result: Prisma.BatchPayload;
          };
          delete: {
            args: Prisma.RequestsDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RequestsPayload>;
          };
          update: {
            args: Prisma.RequestsUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RequestsPayload>;
          };
          deleteMany: {
            args: Prisma.RequestsDeleteManyArgs<ExtArgs>;
            result: Prisma.BatchPayload;
          };
          updateMany: {
            args: Prisma.RequestsUpdateManyArgs<ExtArgs>;
            result: Prisma.BatchPayload;
          };
          upsert: {
            args: Prisma.RequestsUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RequestsPayload>;
          };
          aggregate: {
            args: Prisma.RequestsAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateRequests>;
          };
          groupBy: {
            args: Prisma.RequestsGroupByArgs<ExtArgs>;
            result: $Utils.Optional<RequestsGroupByOutputType>[];
          };
          count: {
            args: Prisma.RequestsCountArgs<ExtArgs>;
            result: $Utils.Optional<RequestsCountAggregateOutputType> | number;
          };
        };
      };
      LineItems: {
        payload: Prisma.$LineItemsPayload<ExtArgs>;
        fields: Prisma.LineItemsFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.LineItemsFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LineItemsPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.LineItemsFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LineItemsPayload>;
          };
          findFirst: {
            args: Prisma.LineItemsFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LineItemsPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.LineItemsFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LineItemsPayload>;
          };
          findMany: {
            args: Prisma.LineItemsFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LineItemsPayload>[];
          };
          create: {
            args: Prisma.LineItemsCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LineItemsPayload>;
          };
          createMany: {
            args: Prisma.LineItemsCreateManyArgs<ExtArgs>;
            result: Prisma.BatchPayload;
          };
          delete: {
            args: Prisma.LineItemsDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LineItemsPayload>;
          };
          update: {
            args: Prisma.LineItemsUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LineItemsPayload>;
          };
          deleteMany: {
            args: Prisma.LineItemsDeleteManyArgs<ExtArgs>;
            result: Prisma.BatchPayload;
          };
          updateMany: {
            args: Prisma.LineItemsUpdateManyArgs<ExtArgs>;
            result: Prisma.BatchPayload;
          };
          upsert: {
            args: Prisma.LineItemsUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LineItemsPayload>;
          };
          aggregate: {
            args: Prisma.LineItemsAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateLineItems>;
          };
          groupBy: {
            args: Prisma.LineItemsGroupByArgs<ExtArgs>;
            result: $Utils.Optional<LineItemsGroupByOutputType>[];
          };
          count: {
            args: Prisma.LineItemsCountArgs<ExtArgs>;
            result: $Utils.Optional<LineItemsCountAggregateOutputType> | number;
          };
        };
      };
      Quotes: {
        payload: Prisma.$QuotesPayload<ExtArgs>;
        fields: Prisma.QuotesFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.QuotesFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$QuotesPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.QuotesFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$QuotesPayload>;
          };
          findFirst: {
            args: Prisma.QuotesFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$QuotesPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.QuotesFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$QuotesPayload>;
          };
          findMany: {
            args: Prisma.QuotesFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$QuotesPayload>[];
          };
          create: {
            args: Prisma.QuotesCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$QuotesPayload>;
          };
          createMany: {
            args: Prisma.QuotesCreateManyArgs<ExtArgs>;
            result: Prisma.BatchPayload;
          };
          delete: {
            args: Prisma.QuotesDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$QuotesPayload>;
          };
          update: {
            args: Prisma.QuotesUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$QuotesPayload>;
          };
          deleteMany: {
            args: Prisma.QuotesDeleteManyArgs<ExtArgs>;
            result: Prisma.BatchPayload;
          };
          updateMany: {
            args: Prisma.QuotesUpdateManyArgs<ExtArgs>;
            result: Prisma.BatchPayload;
          };
          upsert: {
            args: Prisma.QuotesUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$QuotesPayload>;
          };
          aggregate: {
            args: Prisma.QuotesAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateQuotes>;
          };
          groupBy: {
            args: Prisma.QuotesGroupByArgs<ExtArgs>;
            result: $Utils.Optional<QuotesGroupByOutputType>[];
          };
          count: {
            args: Prisma.QuotesCountArgs<ExtArgs>;
            result: $Utils.Optional<QuotesCountAggregateOutputType> | number;
          };
        };
      };
      LineItemQuote: {
        payload: Prisma.$LineItemQuotePayload<ExtArgs>;
        fields: Prisma.LineItemQuoteFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.LineItemQuoteFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LineItemQuotePayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.LineItemQuoteFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LineItemQuotePayload>;
          };
          findFirst: {
            args: Prisma.LineItemQuoteFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LineItemQuotePayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.LineItemQuoteFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LineItemQuotePayload>;
          };
          findMany: {
            args: Prisma.LineItemQuoteFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LineItemQuotePayload>[];
          };
          create: {
            args: Prisma.LineItemQuoteCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LineItemQuotePayload>;
          };
          createMany: {
            args: Prisma.LineItemQuoteCreateManyArgs<ExtArgs>;
            result: Prisma.BatchPayload;
          };
          delete: {
            args: Prisma.LineItemQuoteDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LineItemQuotePayload>;
          };
          update: {
            args: Prisma.LineItemQuoteUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LineItemQuotePayload>;
          };
          deleteMany: {
            args: Prisma.LineItemQuoteDeleteManyArgs<ExtArgs>;
            result: Prisma.BatchPayload;
          };
          updateMany: {
            args: Prisma.LineItemQuoteUpdateManyArgs<ExtArgs>;
            result: Prisma.BatchPayload;
          };
          upsert: {
            args: Prisma.LineItemQuoteUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LineItemQuotePayload>;
          };
          aggregate: {
            args: Prisma.LineItemQuoteAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateLineItemQuote>;
          };
          groupBy: {
            args: Prisma.LineItemQuoteGroupByArgs<ExtArgs>;
            result: $Utils.Optional<LineItemQuoteGroupByOutputType>[];
          };
          count: {
            args: Prisma.LineItemQuoteCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<LineItemQuoteCountAggregateOutputType>
              | number;
          };
        };
      };
      QuoteRequest: {
        payload: Prisma.$QuoteRequestPayload<ExtArgs>;
        fields: Prisma.QuoteRequestFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.QuoteRequestFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$QuoteRequestPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.QuoteRequestFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$QuoteRequestPayload>;
          };
          findFirst: {
            args: Prisma.QuoteRequestFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$QuoteRequestPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.QuoteRequestFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$QuoteRequestPayload>;
          };
          findMany: {
            args: Prisma.QuoteRequestFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$QuoteRequestPayload>[];
          };
          create: {
            args: Prisma.QuoteRequestCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$QuoteRequestPayload>;
          };
          createMany: {
            args: Prisma.QuoteRequestCreateManyArgs<ExtArgs>;
            result: Prisma.BatchPayload;
          };
          delete: {
            args: Prisma.QuoteRequestDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$QuoteRequestPayload>;
          };
          update: {
            args: Prisma.QuoteRequestUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$QuoteRequestPayload>;
          };
          deleteMany: {
            args: Prisma.QuoteRequestDeleteManyArgs<ExtArgs>;
            result: Prisma.BatchPayload;
          };
          updateMany: {
            args: Prisma.QuoteRequestUpdateManyArgs<ExtArgs>;
            result: Prisma.BatchPayload;
          };
          upsert: {
            args: Prisma.QuoteRequestUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$QuoteRequestPayload>;
          };
          aggregate: {
            args: Prisma.QuoteRequestAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateQuoteRequest>;
          };
          groupBy: {
            args: Prisma.QuoteRequestGroupByArgs<ExtArgs>;
            result: $Utils.Optional<QuoteRequestGroupByOutputType>[];
          };
          count: {
            args: Prisma.QuoteRequestCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<QuoteRequestCountAggregateOutputType>
              | number;
          };
        };
      };
      Jobs: {
        payload: Prisma.$JobsPayload<ExtArgs>;
        fields: Prisma.JobsFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.JobsFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$JobsPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.JobsFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$JobsPayload>;
          };
          findFirst: {
            args: Prisma.JobsFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$JobsPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.JobsFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$JobsPayload>;
          };
          findMany: {
            args: Prisma.JobsFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$JobsPayload>[];
          };
          create: {
            args: Prisma.JobsCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$JobsPayload>;
          };
          createMany: {
            args: Prisma.JobsCreateManyArgs<ExtArgs>;
            result: Prisma.BatchPayload;
          };
          delete: {
            args: Prisma.JobsDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$JobsPayload>;
          };
          update: {
            args: Prisma.JobsUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$JobsPayload>;
          };
          deleteMany: {
            args: Prisma.JobsDeleteManyArgs<ExtArgs>;
            result: Prisma.BatchPayload;
          };
          updateMany: {
            args: Prisma.JobsUpdateManyArgs<ExtArgs>;
            result: Prisma.BatchPayload;
          };
          upsert: {
            args: Prisma.JobsUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$JobsPayload>;
          };
          aggregate: {
            args: Prisma.JobsAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateJobs>;
          };
          groupBy: {
            args: Prisma.JobsGroupByArgs<ExtArgs>;
            result: $Utils.Optional<JobsGroupByOutputType>[];
          };
          count: {
            args: Prisma.JobsCountArgs<ExtArgs>;
            result: $Utils.Optional<JobsCountAggregateOutputType> | number;
          };
        };
      };
      LineItemJob: {
        payload: Prisma.$LineItemJobPayload<ExtArgs>;
        fields: Prisma.LineItemJobFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.LineItemJobFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LineItemJobPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.LineItemJobFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LineItemJobPayload>;
          };
          findFirst: {
            args: Prisma.LineItemJobFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LineItemJobPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.LineItemJobFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LineItemJobPayload>;
          };
          findMany: {
            args: Prisma.LineItemJobFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LineItemJobPayload>[];
          };
          create: {
            args: Prisma.LineItemJobCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LineItemJobPayload>;
          };
          createMany: {
            args: Prisma.LineItemJobCreateManyArgs<ExtArgs>;
            result: Prisma.BatchPayload;
          };
          delete: {
            args: Prisma.LineItemJobDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LineItemJobPayload>;
          };
          update: {
            args: Prisma.LineItemJobUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LineItemJobPayload>;
          };
          deleteMany: {
            args: Prisma.LineItemJobDeleteManyArgs<ExtArgs>;
            result: Prisma.BatchPayload;
          };
          updateMany: {
            args: Prisma.LineItemJobUpdateManyArgs<ExtArgs>;
            result: Prisma.BatchPayload;
          };
          upsert: {
            args: Prisma.LineItemJobUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LineItemJobPayload>;
          };
          aggregate: {
            args: Prisma.LineItemJobAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateLineItemJob>;
          };
          groupBy: {
            args: Prisma.LineItemJobGroupByArgs<ExtArgs>;
            result: $Utils.Optional<LineItemJobGroupByOutputType>[];
          };
          count: {
            args: Prisma.LineItemJobCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<LineItemJobCountAggregateOutputType>
              | number;
          };
        };
      };
      JobRequest: {
        payload: Prisma.$JobRequestPayload<ExtArgs>;
        fields: Prisma.JobRequestFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.JobRequestFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$JobRequestPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.JobRequestFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$JobRequestPayload>;
          };
          findFirst: {
            args: Prisma.JobRequestFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$JobRequestPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.JobRequestFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$JobRequestPayload>;
          };
          findMany: {
            args: Prisma.JobRequestFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$JobRequestPayload>[];
          };
          create: {
            args: Prisma.JobRequestCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$JobRequestPayload>;
          };
          createMany: {
            args: Prisma.JobRequestCreateManyArgs<ExtArgs>;
            result: Prisma.BatchPayload;
          };
          delete: {
            args: Prisma.JobRequestDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$JobRequestPayload>;
          };
          update: {
            args: Prisma.JobRequestUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$JobRequestPayload>;
          };
          deleteMany: {
            args: Prisma.JobRequestDeleteManyArgs<ExtArgs>;
            result: Prisma.BatchPayload;
          };
          updateMany: {
            args: Prisma.JobRequestUpdateManyArgs<ExtArgs>;
            result: Prisma.BatchPayload;
          };
          upsert: {
            args: Prisma.JobRequestUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$JobRequestPayload>;
          };
          aggregate: {
            args: Prisma.JobRequestAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateJobRequest>;
          };
          groupBy: {
            args: Prisma.JobRequestGroupByArgs<ExtArgs>;
            result: $Utils.Optional<JobRequestGroupByOutputType>[];
          };
          count: {
            args: Prisma.JobRequestCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<JobRequestCountAggregateOutputType>
              | number;
          };
        };
      };
      JobQuote: {
        payload: Prisma.$JobQuotePayload<ExtArgs>;
        fields: Prisma.JobQuoteFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.JobQuoteFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$JobQuotePayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.JobQuoteFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$JobQuotePayload>;
          };
          findFirst: {
            args: Prisma.JobQuoteFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$JobQuotePayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.JobQuoteFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$JobQuotePayload>;
          };
          findMany: {
            args: Prisma.JobQuoteFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$JobQuotePayload>[];
          };
          create: {
            args: Prisma.JobQuoteCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$JobQuotePayload>;
          };
          createMany: {
            args: Prisma.JobQuoteCreateManyArgs<ExtArgs>;
            result: Prisma.BatchPayload;
          };
          delete: {
            args: Prisma.JobQuoteDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$JobQuotePayload>;
          };
          update: {
            args: Prisma.JobQuoteUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$JobQuotePayload>;
          };
          deleteMany: {
            args: Prisma.JobQuoteDeleteManyArgs<ExtArgs>;
            result: Prisma.BatchPayload;
          };
          updateMany: {
            args: Prisma.JobQuoteUpdateManyArgs<ExtArgs>;
            result: Prisma.BatchPayload;
          };
          upsert: {
            args: Prisma.JobQuoteUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$JobQuotePayload>;
          };
          aggregate: {
            args: Prisma.JobQuoteAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateJobQuote>;
          };
          groupBy: {
            args: Prisma.JobQuoteGroupByArgs<ExtArgs>;
            result: $Utils.Optional<JobQuoteGroupByOutputType>[];
          };
          count: {
            args: Prisma.JobQuoteCountArgs<ExtArgs>;
            result: $Utils.Optional<JobQuoteCountAggregateOutputType> | number;
          };
        };
      };
      Invoices: {
        payload: Prisma.$InvoicesPayload<ExtArgs>;
        fields: Prisma.InvoicesFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.InvoicesFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$InvoicesPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.InvoicesFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$InvoicesPayload>;
          };
          findFirst: {
            args: Prisma.InvoicesFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$InvoicesPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.InvoicesFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$InvoicesPayload>;
          };
          findMany: {
            args: Prisma.InvoicesFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$InvoicesPayload>[];
          };
          create: {
            args: Prisma.InvoicesCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$InvoicesPayload>;
          };
          createMany: {
            args: Prisma.InvoicesCreateManyArgs<ExtArgs>;
            result: Prisma.BatchPayload;
          };
          delete: {
            args: Prisma.InvoicesDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$InvoicesPayload>;
          };
          update: {
            args: Prisma.InvoicesUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$InvoicesPayload>;
          };
          deleteMany: {
            args: Prisma.InvoicesDeleteManyArgs<ExtArgs>;
            result: Prisma.BatchPayload;
          };
          updateMany: {
            args: Prisma.InvoicesUpdateManyArgs<ExtArgs>;
            result: Prisma.BatchPayload;
          };
          upsert: {
            args: Prisma.InvoicesUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$InvoicesPayload>;
          };
          aggregate: {
            args: Prisma.InvoicesAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateInvoices>;
          };
          groupBy: {
            args: Prisma.InvoicesGroupByArgs<ExtArgs>;
            result: $Utils.Optional<InvoicesGroupByOutputType>[];
          };
          count: {
            args: Prisma.InvoicesCountArgs<ExtArgs>;
            result: $Utils.Optional<InvoicesCountAggregateOutputType> | number;
          };
        };
      };
      LineItemInvoice: {
        payload: Prisma.$LineItemInvoicePayload<ExtArgs>;
        fields: Prisma.LineItemInvoiceFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.LineItemInvoiceFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LineItemInvoicePayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.LineItemInvoiceFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LineItemInvoicePayload>;
          };
          findFirst: {
            args: Prisma.LineItemInvoiceFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LineItemInvoicePayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.LineItemInvoiceFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LineItemInvoicePayload>;
          };
          findMany: {
            args: Prisma.LineItemInvoiceFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LineItemInvoicePayload>[];
          };
          create: {
            args: Prisma.LineItemInvoiceCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LineItemInvoicePayload>;
          };
          createMany: {
            args: Prisma.LineItemInvoiceCreateManyArgs<ExtArgs>;
            result: Prisma.BatchPayload;
          };
          delete: {
            args: Prisma.LineItemInvoiceDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LineItemInvoicePayload>;
          };
          update: {
            args: Prisma.LineItemInvoiceUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LineItemInvoicePayload>;
          };
          deleteMany: {
            args: Prisma.LineItemInvoiceDeleteManyArgs<ExtArgs>;
            result: Prisma.BatchPayload;
          };
          updateMany: {
            args: Prisma.LineItemInvoiceUpdateManyArgs<ExtArgs>;
            result: Prisma.BatchPayload;
          };
          upsert: {
            args: Prisma.LineItemInvoiceUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LineItemInvoicePayload>;
          };
          aggregate: {
            args: Prisma.LineItemInvoiceAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateLineItemInvoice>;
          };
          groupBy: {
            args: Prisma.LineItemInvoiceGroupByArgs<ExtArgs>;
            result: $Utils.Optional<LineItemInvoiceGroupByOutputType>[];
          };
          count: {
            args: Prisma.LineItemInvoiceCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<LineItemInvoiceCountAggregateOutputType>
              | number;
          };
        };
      };
    };
  } & {
    other: {
      payload: any;
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]];
          result: any;
        };
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]];
          result: any;
        };
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]];
          result: any;
        };
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]];
          result: any;
        };
      };
    };
  };
  export const defineExtension: $Extensions.ExtendsHook<
    "define",
    Prisma.TypeMapCb,
    $Extensions.DefaultArgs
  >;
  export type DefaultPrismaClient = PrismaClient;
  export type ErrorFormat = "pretty" | "colorless" | "minimal";
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources;
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string;
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat;
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     *
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[];
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number;
      timeout?: number;
      isolationLevel?: Prisma.TransactionIsolationLevel;
    };
  }

  /* Types for Logging */
  export type LogLevel = "info" | "query" | "warn" | "error";
  export type LogDefinition = {
    level: LogLevel;
    emit: "stdout" | "event";
  };

  export type GetLogType<T extends LogLevel | LogDefinition> =
    T extends LogDefinition
      ? T["emit"] extends "event"
        ? T["level"]
        : never
      : never;
  export type GetEvents<T extends any> = T extends Array<
    LogLevel | LogDefinition
  >
    ? GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never;

  export type QueryEvent = {
    timestamp: Date;
    query: string;
    params: string;
    duration: number;
    target: string;
  };

  export type LogEvent = {
    timestamp: Date;
    message: string;
    target: string;
  };
  /* End Types for Logging */

  export type PrismaAction =
    | "findUnique"
    | "findUniqueOrThrow"
    | "findMany"
    | "findFirst"
    | "findFirstOrThrow"
    | "create"
    | "createMany"
    | "update"
    | "updateMany"
    | "upsert"
    | "delete"
    | "deleteMany"
    | "executeRaw"
    | "queryRaw"
    | "aggregate"
    | "count"
    | "runCommandRaw"
    | "findRaw"
    | "groupBy";

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName;
    action: PrismaAction;
    args: any;
    dataPath: string[];
    runInTransaction: boolean;
  };

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>
  ) => $Utils.JsPromise<T>;

  // tested in getLogLevel.test.ts
  export function getLogLevel(
    log: Array<LogLevel | LogDefinition>
  ): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<
    Prisma.DefaultPrismaClient,
    runtime.ITXClientDenyList
  >;

  export type Datasource = {
    url?: string;
  };

  /**
   * Count Types
   */

  /**
   * Count Type TaxesCountOutputType
   */

  export type TaxesCountOutputType = {
    users: number;
    quotes: number;
    invoices: number;
  };

  export type TaxesCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    users?: boolean | TaxesCountOutputTypeCountUsersArgs;
    quotes?: boolean | TaxesCountOutputTypeCountQuotesArgs;
    invoices?: boolean | TaxesCountOutputTypeCountInvoicesArgs;
  };

  // Custom InputTypes

  /**
   * TaxesCountOutputType without action
   */
  export type TaxesCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the TaxesCountOutputType
     */
    select?: TaxesCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * TaxesCountOutputType without action
   */
  export type TaxesCountOutputTypeCountUsersArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: UsersWhereInput;
  };

  /**
   * TaxesCountOutputType without action
   */
  export type TaxesCountOutputTypeCountQuotesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: QuotesWhereInput;
  };

  /**
   * TaxesCountOutputType without action
   */
  export type TaxesCountOutputTypeCountInvoicesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: InvoicesWhereInput;
  };

  /**
   * Count Type AddressesCountOutputType
   */

  export type AddressesCountOutputType = {
    users: number;
    property_clients: number;
    billing_clients: number;
  };

  export type AddressesCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    users?: boolean | AddressesCountOutputTypeCountUsersArgs;
    property_clients?:
      | boolean
      | AddressesCountOutputTypeCountProperty_clientsArgs;
    billing_clients?:
      | boolean
      | AddressesCountOutputTypeCountBilling_clientsArgs;
  };

  // Custom InputTypes

  /**
   * AddressesCountOutputType without action
   */
  export type AddressesCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the AddressesCountOutputType
     */
    select?: AddressesCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * AddressesCountOutputType without action
   */
  export type AddressesCountOutputTypeCountUsersArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: UsersWhereInput;
  };

  /**
   * AddressesCountOutputType without action
   */
  export type AddressesCountOutputTypeCountProperty_clientsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: ClientsWhereInput;
  };

  /**
   * AddressesCountOutputType without action
   */
  export type AddressesCountOutputTypeCountBilling_clientsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: ClientsWhereInput;
  };

  /**
   * Count Type UsersCountOutputType
   */

  export type UsersCountOutputType = {
    clients: number;
    requests: number;
    jobs: number;
    quotes: number;
    invoices: number;
  };

  export type UsersCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    clients?: boolean | UsersCountOutputTypeCountClientsArgs;
    requests?: boolean | UsersCountOutputTypeCountRequestsArgs;
    jobs?: boolean | UsersCountOutputTypeCountJobsArgs;
    quotes?: boolean | UsersCountOutputTypeCountQuotesArgs;
    invoices?: boolean | UsersCountOutputTypeCountInvoicesArgs;
  };

  // Custom InputTypes

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the UsersCountOutputType
     */
    select?: UsersCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountClientsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: ClientsWhereInput;
  };

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountRequestsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: RequestsWhereInput;
  };

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountJobsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: JobsWhereInput;
  };

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountQuotesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: QuotesWhereInput;
  };

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountInvoicesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: InvoicesWhereInput;
  };

  /**
   * Count Type ClientsCountOutputType
   */

  export type ClientsCountOutputType = {
    requests: number;
    quotes: number;
    jobs: number;
    invoices: number;
  };

  export type ClientsCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    requests?: boolean | ClientsCountOutputTypeCountRequestsArgs;
    quotes?: boolean | ClientsCountOutputTypeCountQuotesArgs;
    jobs?: boolean | ClientsCountOutputTypeCountJobsArgs;
    invoices?: boolean | ClientsCountOutputTypeCountInvoicesArgs;
  };

  // Custom InputTypes

  /**
   * ClientsCountOutputType without action
   */
  export type ClientsCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the ClientsCountOutputType
     */
    select?: ClientsCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * ClientsCountOutputType without action
   */
  export type ClientsCountOutputTypeCountRequestsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: RequestsWhereInput;
  };

  /**
   * ClientsCountOutputType without action
   */
  export type ClientsCountOutputTypeCountQuotesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: QuotesWhereInput;
  };

  /**
   * ClientsCountOutputType without action
   */
  export type ClientsCountOutputTypeCountJobsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: JobsWhereInput;
  };

  /**
   * ClientsCountOutputType without action
   */
  export type ClientsCountOutputTypeCountInvoicesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: InvoicesWhereInput;
  };

  /**
   * Count Type AssessmentsCountOutputType
   */

  export type AssessmentsCountOutputType = {
    requests: number;
  };

  export type AssessmentsCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    requests?: boolean | AssessmentsCountOutputTypeCountRequestsArgs;
  };

  // Custom InputTypes

  /**
   * AssessmentsCountOutputType without action
   */
  export type AssessmentsCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the AssessmentsCountOutputType
     */
    select?: AssessmentsCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * AssessmentsCountOutputType without action
   */
  export type AssessmentsCountOutputTypeCountRequestsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: RequestsWhereInput;
  };

  /**
   * Count Type RequestsCountOutputType
   */

  export type RequestsCountOutputType = {
    quotes: number;
    job_requests: number;
  };

  export type RequestsCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    quotes?: boolean | RequestsCountOutputTypeCountQuotesArgs;
    job_requests?: boolean | RequestsCountOutputTypeCountJob_requestsArgs;
  };

  // Custom InputTypes

  /**
   * RequestsCountOutputType without action
   */
  export type RequestsCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the RequestsCountOutputType
     */
    select?: RequestsCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * RequestsCountOutputType without action
   */
  export type RequestsCountOutputTypeCountQuotesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: QuoteRequestWhereInput;
  };

  /**
   * RequestsCountOutputType without action
   */
  export type RequestsCountOutputTypeCountJob_requestsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: JobRequestWhereInput;
  };

  /**
   * Count Type LineItemsCountOutputType
   */

  export type LineItemsCountOutputType = {
    quotes: number;
    invoices: number;
    jobs: number;
  };

  export type LineItemsCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    quotes?: boolean | LineItemsCountOutputTypeCountQuotesArgs;
    invoices?: boolean | LineItemsCountOutputTypeCountInvoicesArgs;
    jobs?: boolean | LineItemsCountOutputTypeCountJobsArgs;
  };

  // Custom InputTypes

  /**
   * LineItemsCountOutputType without action
   */
  export type LineItemsCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the LineItemsCountOutputType
     */
    select?: LineItemsCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * LineItemsCountOutputType without action
   */
  export type LineItemsCountOutputTypeCountQuotesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: LineItemQuoteWhereInput;
  };

  /**
   * LineItemsCountOutputType without action
   */
  export type LineItemsCountOutputTypeCountInvoicesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: LineItemInvoiceWhereInput;
  };

  /**
   * LineItemsCountOutputType without action
   */
  export type LineItemsCountOutputTypeCountJobsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: LineItemJobWhereInput;
  };

  /**
   * Count Type QuotesCountOutputType
   */

  export type QuotesCountOutputType = {
    line_items: number;
    requests: number;
    job_quotes: number;
  };

  export type QuotesCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    line_items?: boolean | QuotesCountOutputTypeCountLine_itemsArgs;
    requests?: boolean | QuotesCountOutputTypeCountRequestsArgs;
    job_quotes?: boolean | QuotesCountOutputTypeCountJob_quotesArgs;
  };

  // Custom InputTypes

  /**
   * QuotesCountOutputType without action
   */
  export type QuotesCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the QuotesCountOutputType
     */
    select?: QuotesCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * QuotesCountOutputType without action
   */
  export type QuotesCountOutputTypeCountLine_itemsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: LineItemQuoteWhereInput;
  };

  /**
   * QuotesCountOutputType without action
   */
  export type QuotesCountOutputTypeCountRequestsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: QuoteRequestWhereInput;
  };

  /**
   * QuotesCountOutputType without action
   */
  export type QuotesCountOutputTypeCountJob_quotesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: JobQuoteWhereInput;
  };

  /**
   * Count Type JobsCountOutputType
   */

  export type JobsCountOutputType = {
    line_items: number;
    job_requests: number;
    job_quotes: number;
    invoices: number;
  };

  export type JobsCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    line_items?: boolean | JobsCountOutputTypeCountLine_itemsArgs;
    job_requests?: boolean | JobsCountOutputTypeCountJob_requestsArgs;
    job_quotes?: boolean | JobsCountOutputTypeCountJob_quotesArgs;
    invoices?: boolean | JobsCountOutputTypeCountInvoicesArgs;
  };

  // Custom InputTypes

  /**
   * JobsCountOutputType without action
   */
  export type JobsCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the JobsCountOutputType
     */
    select?: JobsCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * JobsCountOutputType without action
   */
  export type JobsCountOutputTypeCountLine_itemsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: LineItemJobWhereInput;
  };

  /**
   * JobsCountOutputType without action
   */
  export type JobsCountOutputTypeCountJob_requestsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: JobRequestWhereInput;
  };

  /**
   * JobsCountOutputType without action
   */
  export type JobsCountOutputTypeCountJob_quotesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: JobQuoteWhereInput;
  };

  /**
   * JobsCountOutputType without action
   */
  export type JobsCountOutputTypeCountInvoicesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: InvoicesWhereInput;
  };

  /**
   * Count Type InvoicesCountOutputType
   */

  export type InvoicesCountOutputType = {
    additional_line_items: number;
  };

  export type InvoicesCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    additional_line_items?:
      | boolean
      | InvoicesCountOutputTypeCountAdditional_line_itemsArgs;
  };

  // Custom InputTypes

  /**
   * InvoicesCountOutputType without action
   */
  export type InvoicesCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the InvoicesCountOutputType
     */
    select?: InvoicesCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * InvoicesCountOutputType without action
   */
  export type InvoicesCountOutputTypeCountAdditional_line_itemsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: LineItemInvoiceWhereInput;
  };

  /**
   * Models
   */

  /**
   * Model Taxes
   */

  export type AggregateTaxes = {
    _count: TaxesCountAggregateOutputType | null;
    _avg: TaxesAvgAggregateOutputType | null;
    _sum: TaxesSumAggregateOutputType | null;
    _min: TaxesMinAggregateOutputType | null;
    _max: TaxesMaxAggregateOutputType | null;
  };

  export type TaxesAvgAggregateOutputType = {
    id: number | null;
    rate: number | null;
  };

  export type TaxesSumAggregateOutputType = {
    id: number | null;
    rate: number | null;
  };

  export type TaxesMinAggregateOutputType = {
    id: number | null;
    name: string | null;
    rate: number | null;
    description: string | null;
  };

  export type TaxesMaxAggregateOutputType = {
    id: number | null;
    name: string | null;
    rate: number | null;
    description: string | null;
  };

  export type TaxesCountAggregateOutputType = {
    id: number;
    name: number;
    rate: number;
    description: number;
    _all: number;
  };

  export type TaxesAvgAggregateInputType = {
    id?: true;
    rate?: true;
  };

  export type TaxesSumAggregateInputType = {
    id?: true;
    rate?: true;
  };

  export type TaxesMinAggregateInputType = {
    id?: true;
    name?: true;
    rate?: true;
    description?: true;
  };

  export type TaxesMaxAggregateInputType = {
    id?: true;
    name?: true;
    rate?: true;
    description?: true;
  };

  export type TaxesCountAggregateInputType = {
    id?: true;
    name?: true;
    rate?: true;
    description?: true;
    _all?: true;
  };

  export type TaxesAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which Taxes to aggregate.
     */
    where?: TaxesWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Taxes to fetch.
     */
    orderBy?: TaxesOrderByWithRelationInput | TaxesOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: TaxesWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Taxes from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Taxes.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Taxes
     **/
    _count?: true | TaxesCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: TaxesAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: TaxesSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: TaxesMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: TaxesMaxAggregateInputType;
  };

  export type GetTaxesAggregateType<T extends TaxesAggregateArgs> = {
    [P in keyof T & keyof AggregateTaxes]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaxes[P]>
      : GetScalarType<T[P], AggregateTaxes[P]>;
  };

  export type TaxesGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: TaxesWhereInput;
    orderBy?:
      | TaxesOrderByWithAggregationInput
      | TaxesOrderByWithAggregationInput[];
    by: TaxesScalarFieldEnum[] | TaxesScalarFieldEnum;
    having?: TaxesScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: TaxesCountAggregateInputType | true;
    _avg?: TaxesAvgAggregateInputType;
    _sum?: TaxesSumAggregateInputType;
    _min?: TaxesMinAggregateInputType;
    _max?: TaxesMaxAggregateInputType;
  };

  export type TaxesGroupByOutputType = {
    id: number;
    name: string;
    rate: number;
    description: string | null;
    _count: TaxesCountAggregateOutputType | null;
    _avg: TaxesAvgAggregateOutputType | null;
    _sum: TaxesSumAggregateOutputType | null;
    _min: TaxesMinAggregateOutputType | null;
    _max: TaxesMaxAggregateOutputType | null;
  };

  type GetTaxesGroupByPayload<T extends TaxesGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<TaxesGroupByOutputType, T["by"]> & {
          [P in keyof T & keyof TaxesGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaxesGroupByOutputType[P]>
            : GetScalarType<T[P], TaxesGroupByOutputType[P]>;
        }
      >
    >;

  export type TaxesSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      rate?: boolean;
      description?: boolean;
      users?: boolean | Taxes$usersArgs<ExtArgs>;
      quotes?: boolean | Taxes$quotesArgs<ExtArgs>;
      invoices?: boolean | Taxes$invoicesArgs<ExtArgs>;
      _count?: boolean | TaxesCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["taxes"]
  >;

  export type TaxesSelectScalar = {
    id?: boolean;
    name?: boolean;
    rate?: boolean;
    description?: boolean;
  };

  export type TaxesInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    users?: boolean | Taxes$usersArgs<ExtArgs>;
    quotes?: boolean | Taxes$quotesArgs<ExtArgs>;
    invoices?: boolean | Taxes$invoicesArgs<ExtArgs>;
    _count?: boolean | TaxesCountOutputTypeDefaultArgs<ExtArgs>;
  };

  export type $TaxesPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: "Taxes";
    objects: {
      users: Prisma.$UsersPayload<ExtArgs>[];
      quotes: Prisma.$QuotesPayload<ExtArgs>[];
      invoices: Prisma.$InvoicesPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: number;
        name: string;
        rate: number;
        description: string | null;
      },
      ExtArgs["result"]["taxes"]
    >;
    composites: {};
  };

  type TaxesGetPayload<
    S extends boolean | null | undefined | TaxesDefaultArgs
  > = $Result.GetResult<Prisma.$TaxesPayload, S>;

  type TaxesCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<TaxesFindManyArgs, "select" | "include" | "distinct"> & {
    select?: TaxesCountAggregateInputType | true;
  };

  export interface TaxesDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["Taxes"];
      meta: { name: "Taxes" };
    };
    /**
     * Find zero or one Taxes that matches the filter.
     * @param {TaxesFindUniqueArgs} args - Arguments to find a Taxes
     * @example
     * // Get one Taxes
     * const taxes = await prisma.taxes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     **/
    findUnique<T extends TaxesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, TaxesFindUniqueArgs<ExtArgs>>
    ): Prisma__TaxesClient<
      $Result.GetResult<Prisma.$TaxesPayload<ExtArgs>, T, "findUnique"> | null,
      null,
      ExtArgs
    >;

    /**
     * Find one Taxes that matches the filter or throw an error  with `error.code='P2025'`
     *     if no matches were found.
     * @param {TaxesFindUniqueOrThrowArgs} args - Arguments to find a Taxes
     * @example
     * // Get one Taxes
     * const taxes = await prisma.taxes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     **/
    findUniqueOrThrow<T extends TaxesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TaxesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__TaxesClient<
      $Result.GetResult<Prisma.$TaxesPayload<ExtArgs>, T, "findUniqueOrThrow">,
      never,
      ExtArgs
    >;

    /**
     * Find the first Taxes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxesFindFirstArgs} args - Arguments to find a Taxes
     * @example
     * // Get one Taxes
     * const taxes = await prisma.taxes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     **/
    findFirst<T extends TaxesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, TaxesFindFirstArgs<ExtArgs>>
    ): Prisma__TaxesClient<
      $Result.GetResult<Prisma.$TaxesPayload<ExtArgs>, T, "findFirst"> | null,
      null,
      ExtArgs
    >;

    /**
     * Find the first Taxes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxesFindFirstOrThrowArgs} args - Arguments to find a Taxes
     * @example
     * // Get one Taxes
     * const taxes = await prisma.taxes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     **/
    findFirstOrThrow<T extends TaxesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TaxesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__TaxesClient<
      $Result.GetResult<Prisma.$TaxesPayload<ExtArgs>, T, "findFirstOrThrow">,
      never,
      ExtArgs
    >;

    /**
     * Find zero or more Taxes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Taxes
     * const taxes = await prisma.taxes.findMany()
     *
     * // Get first 10 Taxes
     * const taxes = await prisma.taxes.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const taxesWithIdOnly = await prisma.taxes.findMany({ select: { id: true } })
     *
     **/
    findMany<T extends TaxesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TaxesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$TaxesPayload<ExtArgs>, T, "findMany">
    >;

    /**
     * Create a Taxes.
     * @param {TaxesCreateArgs} args - Arguments to create a Taxes.
     * @example
     * // Create one Taxes
     * const Taxes = await prisma.taxes.create({
     *   data: {
     *     // ... data to create a Taxes
     *   }
     * })
     *
     **/
    create<T extends TaxesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, TaxesCreateArgs<ExtArgs>>
    ): Prisma__TaxesClient<
      $Result.GetResult<Prisma.$TaxesPayload<ExtArgs>, T, "create">,
      never,
      ExtArgs
    >;

    /**
     * Create many Taxes.
     *     @param {TaxesCreateManyArgs} args - Arguments to create many Taxes.
     *     @example
     *     // Create many Taxes
     *     const taxes = await prisma.taxes.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *
     **/
    createMany<T extends TaxesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TaxesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a Taxes.
     * @param {TaxesDeleteArgs} args - Arguments to delete one Taxes.
     * @example
     * // Delete one Taxes
     * const Taxes = await prisma.taxes.delete({
     *   where: {
     *     // ... filter to delete one Taxes
     *   }
     * })
     *
     **/
    delete<T extends TaxesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, TaxesDeleteArgs<ExtArgs>>
    ): Prisma__TaxesClient<
      $Result.GetResult<Prisma.$TaxesPayload<ExtArgs>, T, "delete">,
      never,
      ExtArgs
    >;

    /**
     * Update one Taxes.
     * @param {TaxesUpdateArgs} args - Arguments to update one Taxes.
     * @example
     * // Update one Taxes
     * const taxes = await prisma.taxes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     **/
    update<T extends TaxesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, TaxesUpdateArgs<ExtArgs>>
    ): Prisma__TaxesClient<
      $Result.GetResult<Prisma.$TaxesPayload<ExtArgs>, T, "update">,
      never,
      ExtArgs
    >;

    /**
     * Delete zero or more Taxes.
     * @param {TaxesDeleteManyArgs} args - Arguments to filter Taxes to delete.
     * @example
     * // Delete a few Taxes
     * const { count } = await prisma.taxes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     **/
    deleteMany<T extends TaxesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TaxesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Taxes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Taxes
     * const taxes = await prisma.taxes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     **/
    updateMany<T extends TaxesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, TaxesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one Taxes.
     * @param {TaxesUpsertArgs} args - Arguments to update or create a Taxes.
     * @example
     * // Update or create a Taxes
     * const taxes = await prisma.taxes.upsert({
     *   create: {
     *     // ... data to create a Taxes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Taxes we want to update
     *   }
     * })
     **/
    upsert<T extends TaxesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, TaxesUpsertArgs<ExtArgs>>
    ): Prisma__TaxesClient<
      $Result.GetResult<Prisma.$TaxesPayload<ExtArgs>, T, "upsert">,
      never,
      ExtArgs
    >;

    /**
     * Count the number of Taxes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxesCountArgs} args - Arguments to filter Taxes to count.
     * @example
     * // Count the number of Taxes
     * const count = await prisma.taxes.count({
     *   where: {
     *     // ... the filter for the Taxes we want to count
     *   }
     * })
     **/
    count<T extends TaxesCountArgs>(
      args?: Subset<T, TaxesCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], TaxesCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Taxes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends TaxesAggregateArgs>(
      args: Subset<T, TaxesAggregateArgs>
    ): Prisma.PrismaPromise<GetTaxesAggregateType<T>>;

    /**
     * Group by Taxes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends TaxesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaxesGroupByArgs["orderBy"] }
        : { orderBy?: TaxesGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
        ? {
            [P in HavingFields]: P extends ByFields
              ? never
              : P extends string
              ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
              : [
                  Error,
                  "Field ",
                  P,
                  ` in "having" needs to be provided in "by"`
                ];
          }[HavingFields]
        : "take" extends Keys<T>
        ? "orderBy" extends Keys<T>
          ? ByValid extends True
            ? {}
            : {
                [P in OrderFields]: P extends ByFields
                  ? never
                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
              }[OrderFields]
          : 'Error: If you provide "take", you also need to provide "orderBy"'
        : "skip" extends Keys<T>
        ? "orderBy" extends Keys<T>
          ? ByValid extends True
            ? {}
            : {
                [P in OrderFields]: P extends ByFields
                  ? never
                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
              }[OrderFields]
          : 'Error: If you provide "skip", you also need to provide "orderBy"'
        : ByValid extends True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
          }[OrderFields]
    >(
      args: SubsetIntersection<T, TaxesGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetTaxesGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Taxes model
     */
    readonly fields: TaxesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Taxes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaxesClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";

    users<T extends Taxes$usersArgs<ExtArgs> = {}>(
      args?: Subset<T, Taxes$usersArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findMany"> | Null
    >;

    quotes<T extends Taxes$quotesArgs<ExtArgs> = {}>(
      args?: Subset<T, Taxes$quotesArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$QuotesPayload<ExtArgs>, T, "findMany"> | Null
    >;

    invoices<T extends Taxes$invoicesArgs<ExtArgs> = {}>(
      args?: Subset<T, Taxes$invoicesArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$InvoicesPayload<ExtArgs>, T, "findMany"> | Null
    >;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Taxes model
   */
  interface TaxesFieldRefs {
    readonly id: FieldRef<"Taxes", "Int">;
    readonly name: FieldRef<"Taxes", "String">;
    readonly rate: FieldRef<"Taxes", "Float">;
    readonly description: FieldRef<"Taxes", "String">;
  }

  // Custom InputTypes

  /**
   * Taxes findUnique
   */
  export type TaxesFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Taxes
     */
    select?: TaxesSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TaxesInclude<ExtArgs> | null;
    /**
     * Filter, which Taxes to fetch.
     */
    where: TaxesWhereUniqueInput;
  };

  /**
   * Taxes findUniqueOrThrow
   */
  export type TaxesFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Taxes
     */
    select?: TaxesSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TaxesInclude<ExtArgs> | null;
    /**
     * Filter, which Taxes to fetch.
     */
    where: TaxesWhereUniqueInput;
  };

  /**
   * Taxes findFirst
   */
  export type TaxesFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Taxes
     */
    select?: TaxesSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TaxesInclude<ExtArgs> | null;
    /**
     * Filter, which Taxes to fetch.
     */
    where?: TaxesWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Taxes to fetch.
     */
    orderBy?: TaxesOrderByWithRelationInput | TaxesOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Taxes.
     */
    cursor?: TaxesWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Taxes from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Taxes.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Taxes.
     */
    distinct?: TaxesScalarFieldEnum | TaxesScalarFieldEnum[];
  };

  /**
   * Taxes findFirstOrThrow
   */
  export type TaxesFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Taxes
     */
    select?: TaxesSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TaxesInclude<ExtArgs> | null;
    /**
     * Filter, which Taxes to fetch.
     */
    where?: TaxesWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Taxes to fetch.
     */
    orderBy?: TaxesOrderByWithRelationInput | TaxesOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Taxes.
     */
    cursor?: TaxesWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Taxes from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Taxes.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Taxes.
     */
    distinct?: TaxesScalarFieldEnum | TaxesScalarFieldEnum[];
  };

  /**
   * Taxes findMany
   */
  export type TaxesFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Taxes
     */
    select?: TaxesSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TaxesInclude<ExtArgs> | null;
    /**
     * Filter, which Taxes to fetch.
     */
    where?: TaxesWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Taxes to fetch.
     */
    orderBy?: TaxesOrderByWithRelationInput | TaxesOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Taxes.
     */
    cursor?: TaxesWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Taxes from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Taxes.
     */
    skip?: number;
    distinct?: TaxesScalarFieldEnum | TaxesScalarFieldEnum[];
  };

  /**
   * Taxes create
   */
  export type TaxesCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Taxes
     */
    select?: TaxesSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TaxesInclude<ExtArgs> | null;
    /**
     * The data needed to create a Taxes.
     */
    data: XOR<TaxesCreateInput, TaxesUncheckedCreateInput>;
  };

  /**
   * Taxes createMany
   */
  export type TaxesCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many Taxes.
     */
    data: TaxesCreateManyInput | TaxesCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Taxes update
   */
  export type TaxesUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Taxes
     */
    select?: TaxesSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TaxesInclude<ExtArgs> | null;
    /**
     * The data needed to update a Taxes.
     */
    data: XOR<TaxesUpdateInput, TaxesUncheckedUpdateInput>;
    /**
     * Choose, which Taxes to update.
     */
    where: TaxesWhereUniqueInput;
  };

  /**
   * Taxes updateMany
   */
  export type TaxesUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update Taxes.
     */
    data: XOR<TaxesUpdateManyMutationInput, TaxesUncheckedUpdateManyInput>;
    /**
     * Filter which Taxes to update
     */
    where?: TaxesWhereInput;
  };

  /**
   * Taxes upsert
   */
  export type TaxesUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Taxes
     */
    select?: TaxesSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TaxesInclude<ExtArgs> | null;
    /**
     * The filter to search for the Taxes to update in case it exists.
     */
    where: TaxesWhereUniqueInput;
    /**
     * In case the Taxes found by the `where` argument doesn't exist, create a new Taxes with this data.
     */
    create: XOR<TaxesCreateInput, TaxesUncheckedCreateInput>;
    /**
     * In case the Taxes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaxesUpdateInput, TaxesUncheckedUpdateInput>;
  };

  /**
   * Taxes delete
   */
  export type TaxesDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Taxes
     */
    select?: TaxesSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TaxesInclude<ExtArgs> | null;
    /**
     * Filter which Taxes to delete.
     */
    where: TaxesWhereUniqueInput;
  };

  /**
   * Taxes deleteMany
   */
  export type TaxesDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which Taxes to delete
     */
    where?: TaxesWhereInput;
  };

  /**
   * Taxes.users
   */
  export type Taxes$usersArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsersInclude<ExtArgs> | null;
    where?: UsersWhereInput;
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[];
    cursor?: UsersWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[];
  };

  /**
   * Taxes.quotes
   */
  export type Taxes$quotesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Quotes
     */
    select?: QuotesSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuotesInclude<ExtArgs> | null;
    where?: QuotesWhereInput;
    orderBy?: QuotesOrderByWithRelationInput | QuotesOrderByWithRelationInput[];
    cursor?: QuotesWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: QuotesScalarFieldEnum | QuotesScalarFieldEnum[];
  };

  /**
   * Taxes.invoices
   */
  export type Taxes$invoicesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Invoices
     */
    select?: InvoicesSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvoicesInclude<ExtArgs> | null;
    where?: InvoicesWhereInput;
    orderBy?:
      | InvoicesOrderByWithRelationInput
      | InvoicesOrderByWithRelationInput[];
    cursor?: InvoicesWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: InvoicesScalarFieldEnum | InvoicesScalarFieldEnum[];
  };

  /**
   * Taxes without action
   */
  export type TaxesDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Taxes
     */
    select?: TaxesSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TaxesInclude<ExtArgs> | null;
  };

  /**
   * Model Addresses
   */

  export type AggregateAddresses = {
    _count: AddressesCountAggregateOutputType | null;
    _avg: AddressesAvgAggregateOutputType | null;
    _sum: AddressesSumAggregateOutputType | null;
    _min: AddressesMinAggregateOutputType | null;
    _max: AddressesMaxAggregateOutputType | null;
  };

  export type AddressesAvgAggregateOutputType = {
    id: number | null;
  };

  export type AddressesSumAggregateOutputType = {
    id: number | null;
  };

  export type AddressesMinAggregateOutputType = {
    id: number | null;
    street1: string | null;
    street2: string | null;
    city: string | null;
    state: string | null;
    zip_code: string | null;
    country: string | null;
  };

  export type AddressesMaxAggregateOutputType = {
    id: number | null;
    street1: string | null;
    street2: string | null;
    city: string | null;
    state: string | null;
    zip_code: string | null;
    country: string | null;
  };

  export type AddressesCountAggregateOutputType = {
    id: number;
    street1: number;
    street2: number;
    city: number;
    state: number;
    zip_code: number;
    country: number;
    _all: number;
  };

  export type AddressesAvgAggregateInputType = {
    id?: true;
  };

  export type AddressesSumAggregateInputType = {
    id?: true;
  };

  export type AddressesMinAggregateInputType = {
    id?: true;
    street1?: true;
    street2?: true;
    city?: true;
    state?: true;
    zip_code?: true;
    country?: true;
  };

  export type AddressesMaxAggregateInputType = {
    id?: true;
    street1?: true;
    street2?: true;
    city?: true;
    state?: true;
    zip_code?: true;
    country?: true;
  };

  export type AddressesCountAggregateInputType = {
    id?: true;
    street1?: true;
    street2?: true;
    city?: true;
    state?: true;
    zip_code?: true;
    country?: true;
    _all?: true;
  };

  export type AddressesAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which Addresses to aggregate.
     */
    where?: AddressesWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Addresses to fetch.
     */
    orderBy?:
      | AddressesOrderByWithRelationInput
      | AddressesOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: AddressesWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Addresses.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Addresses
     **/
    _count?: true | AddressesCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: AddressesAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: AddressesSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: AddressesMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: AddressesMaxAggregateInputType;
  };

  export type GetAddressesAggregateType<T extends AddressesAggregateArgs> = {
    [P in keyof T & keyof AggregateAddresses]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAddresses[P]>
      : GetScalarType<T[P], AggregateAddresses[P]>;
  };

  export type AddressesGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: AddressesWhereInput;
    orderBy?:
      | AddressesOrderByWithAggregationInput
      | AddressesOrderByWithAggregationInput[];
    by: AddressesScalarFieldEnum[] | AddressesScalarFieldEnum;
    having?: AddressesScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: AddressesCountAggregateInputType | true;
    _avg?: AddressesAvgAggregateInputType;
    _sum?: AddressesSumAggregateInputType;
    _min?: AddressesMinAggregateInputType;
    _max?: AddressesMaxAggregateInputType;
  };

  export type AddressesGroupByOutputType = {
    id: number;
    street1: string;
    street2: string | null;
    city: string;
    state: string;
    zip_code: string;
    country: string;
    _count: AddressesCountAggregateOutputType | null;
    _avg: AddressesAvgAggregateOutputType | null;
    _sum: AddressesSumAggregateOutputType | null;
    _min: AddressesMinAggregateOutputType | null;
    _max: AddressesMaxAggregateOutputType | null;
  };

  type GetAddressesGroupByPayload<T extends AddressesGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<AddressesGroupByOutputType, T["by"]> & {
          [P in keyof T & keyof AddressesGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AddressesGroupByOutputType[P]>
            : GetScalarType<T[P], AddressesGroupByOutputType[P]>;
        }
      >
    >;

  export type AddressesSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      street1?: boolean;
      street2?: boolean;
      city?: boolean;
      state?: boolean;
      zip_code?: boolean;
      country?: boolean;
      users?: boolean | Addresses$usersArgs<ExtArgs>;
      property_clients?: boolean | Addresses$property_clientsArgs<ExtArgs>;
      billing_clients?: boolean | Addresses$billing_clientsArgs<ExtArgs>;
      _count?: boolean | AddressesCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["addresses"]
  >;

  export type AddressesSelectScalar = {
    id?: boolean;
    street1?: boolean;
    street2?: boolean;
    city?: boolean;
    state?: boolean;
    zip_code?: boolean;
    country?: boolean;
  };

  export type AddressesInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    users?: boolean | Addresses$usersArgs<ExtArgs>;
    property_clients?: boolean | Addresses$property_clientsArgs<ExtArgs>;
    billing_clients?: boolean | Addresses$billing_clientsArgs<ExtArgs>;
    _count?: boolean | AddressesCountOutputTypeDefaultArgs<ExtArgs>;
  };

  export type $AddressesPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: "Addresses";
    objects: {
      users: Prisma.$UsersPayload<ExtArgs>[];
      property_clients: Prisma.$ClientsPayload<ExtArgs>[];
      billing_clients: Prisma.$ClientsPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: number;
        street1: string;
        street2: string | null;
        city: string;
        state: string;
        zip_code: string;
        country: string;
      },
      ExtArgs["result"]["addresses"]
    >;
    composites: {};
  };

  type AddressesGetPayload<
    S extends boolean | null | undefined | AddressesDefaultArgs
  > = $Result.GetResult<Prisma.$AddressesPayload, S>;

  type AddressesCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<AddressesFindManyArgs, "select" | "include" | "distinct"> & {
    select?: AddressesCountAggregateInputType | true;
  };

  export interface AddressesDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["Addresses"];
      meta: { name: "Addresses" };
    };
    /**
     * Find zero or one Addresses that matches the filter.
     * @param {AddressesFindUniqueArgs} args - Arguments to find a Addresses
     * @example
     * // Get one Addresses
     * const addresses = await prisma.addresses.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     **/
    findUnique<T extends AddressesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AddressesFindUniqueArgs<ExtArgs>>
    ): Prisma__AddressesClient<
      $Result.GetResult<
        Prisma.$AddressesPayload<ExtArgs>,
        T,
        "findUnique"
      > | null,
      null,
      ExtArgs
    >;

    /**
     * Find one Addresses that matches the filter or throw an error  with `error.code='P2025'`
     *     if no matches were found.
     * @param {AddressesFindUniqueOrThrowArgs} args - Arguments to find a Addresses
     * @example
     * // Get one Addresses
     * const addresses = await prisma.addresses.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     **/
    findUniqueOrThrow<T extends AddressesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AddressesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AddressesClient<
      $Result.GetResult<
        Prisma.$AddressesPayload<ExtArgs>,
        T,
        "findUniqueOrThrow"
      >,
      never,
      ExtArgs
    >;

    /**
     * Find the first Addresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressesFindFirstArgs} args - Arguments to find a Addresses
     * @example
     * // Get one Addresses
     * const addresses = await prisma.addresses.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     **/
    findFirst<T extends AddressesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AddressesFindFirstArgs<ExtArgs>>
    ): Prisma__AddressesClient<
      $Result.GetResult<
        Prisma.$AddressesPayload<ExtArgs>,
        T,
        "findFirst"
      > | null,
      null,
      ExtArgs
    >;

    /**
     * Find the first Addresses that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressesFindFirstOrThrowArgs} args - Arguments to find a Addresses
     * @example
     * // Get one Addresses
     * const addresses = await prisma.addresses.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     **/
    findFirstOrThrow<T extends AddressesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AddressesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AddressesClient<
      $Result.GetResult<
        Prisma.$AddressesPayload<ExtArgs>,
        T,
        "findFirstOrThrow"
      >,
      never,
      ExtArgs
    >;

    /**
     * Find zero or more Addresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Addresses
     * const addresses = await prisma.addresses.findMany()
     *
     * // Get first 10 Addresses
     * const addresses = await prisma.addresses.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const addressesWithIdOnly = await prisma.addresses.findMany({ select: { id: true } })
     *
     **/
    findMany<T extends AddressesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AddressesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$AddressesPayload<ExtArgs>, T, "findMany">
    >;

    /**
     * Create a Addresses.
     * @param {AddressesCreateArgs} args - Arguments to create a Addresses.
     * @example
     * // Create one Addresses
     * const Addresses = await prisma.addresses.create({
     *   data: {
     *     // ... data to create a Addresses
     *   }
     * })
     *
     **/
    create<T extends AddressesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AddressesCreateArgs<ExtArgs>>
    ): Prisma__AddressesClient<
      $Result.GetResult<Prisma.$AddressesPayload<ExtArgs>, T, "create">,
      never,
      ExtArgs
    >;

    /**
     * Create many Addresses.
     *     @param {AddressesCreateManyArgs} args - Arguments to create many Addresses.
     *     @example
     *     // Create many Addresses
     *     const addresses = await prisma.addresses.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *
     **/
    createMany<T extends AddressesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AddressesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a Addresses.
     * @param {AddressesDeleteArgs} args - Arguments to delete one Addresses.
     * @example
     * // Delete one Addresses
     * const Addresses = await prisma.addresses.delete({
     *   where: {
     *     // ... filter to delete one Addresses
     *   }
     * })
     *
     **/
    delete<T extends AddressesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AddressesDeleteArgs<ExtArgs>>
    ): Prisma__AddressesClient<
      $Result.GetResult<Prisma.$AddressesPayload<ExtArgs>, T, "delete">,
      never,
      ExtArgs
    >;

    /**
     * Update one Addresses.
     * @param {AddressesUpdateArgs} args - Arguments to update one Addresses.
     * @example
     * // Update one Addresses
     * const addresses = await prisma.addresses.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     **/
    update<T extends AddressesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AddressesUpdateArgs<ExtArgs>>
    ): Prisma__AddressesClient<
      $Result.GetResult<Prisma.$AddressesPayload<ExtArgs>, T, "update">,
      never,
      ExtArgs
    >;

    /**
     * Delete zero or more Addresses.
     * @param {AddressesDeleteManyArgs} args - Arguments to filter Addresses to delete.
     * @example
     * // Delete a few Addresses
     * const { count } = await prisma.addresses.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     **/
    deleteMany<T extends AddressesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AddressesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Addresses
     * const addresses = await prisma.addresses.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     **/
    updateMany<T extends AddressesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AddressesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one Addresses.
     * @param {AddressesUpsertArgs} args - Arguments to update or create a Addresses.
     * @example
     * // Update or create a Addresses
     * const addresses = await prisma.addresses.upsert({
     *   create: {
     *     // ... data to create a Addresses
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Addresses we want to update
     *   }
     * })
     **/
    upsert<T extends AddressesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AddressesUpsertArgs<ExtArgs>>
    ): Prisma__AddressesClient<
      $Result.GetResult<Prisma.$AddressesPayload<ExtArgs>, T, "upsert">,
      never,
      ExtArgs
    >;

    /**
     * Count the number of Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressesCountArgs} args - Arguments to filter Addresses to count.
     * @example
     * // Count the number of Addresses
     * const count = await prisma.addresses.count({
     *   where: {
     *     // ... the filter for the Addresses we want to count
     *   }
     * })
     **/
    count<T extends AddressesCountArgs>(
      args?: Subset<T, AddressesCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], AddressesCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends AddressesAggregateArgs>(
      args: Subset<T, AddressesAggregateArgs>
    ): Prisma.PrismaPromise<GetAddressesAggregateType<T>>;

    /**
     * Group by Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends AddressesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AddressesGroupByArgs["orderBy"] }
        : { orderBy?: AddressesGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
        ? {
            [P in HavingFields]: P extends ByFields
              ? never
              : P extends string
              ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
              : [
                  Error,
                  "Field ",
                  P,
                  ` in "having" needs to be provided in "by"`
                ];
          }[HavingFields]
        : "take" extends Keys<T>
        ? "orderBy" extends Keys<T>
          ? ByValid extends True
            ? {}
            : {
                [P in OrderFields]: P extends ByFields
                  ? never
                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
              }[OrderFields]
          : 'Error: If you provide "take", you also need to provide "orderBy"'
        : "skip" extends Keys<T>
        ? "orderBy" extends Keys<T>
          ? ByValid extends True
            ? {}
            : {
                [P in OrderFields]: P extends ByFields
                  ? never
                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
              }[OrderFields]
          : 'Error: If you provide "skip", you also need to provide "orderBy"'
        : ByValid extends True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
          }[OrderFields]
    >(
      args: SubsetIntersection<T, AddressesGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetAddressesGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Addresses model
     */
    readonly fields: AddressesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Addresses.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AddressesClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";

    users<T extends Addresses$usersArgs<ExtArgs> = {}>(
      args?: Subset<T, Addresses$usersArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findMany"> | Null
    >;

    property_clients<T extends Addresses$property_clientsArgs<ExtArgs> = {}>(
      args?: Subset<T, Addresses$property_clientsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$ClientsPayload<ExtArgs>, T, "findMany"> | Null
    >;

    billing_clients<T extends Addresses$billing_clientsArgs<ExtArgs> = {}>(
      args?: Subset<T, Addresses$billing_clientsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$ClientsPayload<ExtArgs>, T, "findMany"> | Null
    >;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Addresses model
   */
  interface AddressesFieldRefs {
    readonly id: FieldRef<"Addresses", "Int">;
    readonly street1: FieldRef<"Addresses", "String">;
    readonly street2: FieldRef<"Addresses", "String">;
    readonly city: FieldRef<"Addresses", "String">;
    readonly state: FieldRef<"Addresses", "String">;
    readonly zip_code: FieldRef<"Addresses", "String">;
    readonly country: FieldRef<"Addresses", "String">;
  }

  // Custom InputTypes

  /**
   * Addresses findUnique
   */
  export type AddressesFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Addresses
     */
    select?: AddressesSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AddressesInclude<ExtArgs> | null;
    /**
     * Filter, which Addresses to fetch.
     */
    where: AddressesWhereUniqueInput;
  };

  /**
   * Addresses findUniqueOrThrow
   */
  export type AddressesFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Addresses
     */
    select?: AddressesSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AddressesInclude<ExtArgs> | null;
    /**
     * Filter, which Addresses to fetch.
     */
    where: AddressesWhereUniqueInput;
  };

  /**
   * Addresses findFirst
   */
  export type AddressesFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Addresses
     */
    select?: AddressesSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AddressesInclude<ExtArgs> | null;
    /**
     * Filter, which Addresses to fetch.
     */
    where?: AddressesWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Addresses to fetch.
     */
    orderBy?:
      | AddressesOrderByWithRelationInput
      | AddressesOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Addresses.
     */
    cursor?: AddressesWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Addresses.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Addresses.
     */
    distinct?: AddressesScalarFieldEnum | AddressesScalarFieldEnum[];
  };

  /**
   * Addresses findFirstOrThrow
   */
  export type AddressesFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Addresses
     */
    select?: AddressesSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AddressesInclude<ExtArgs> | null;
    /**
     * Filter, which Addresses to fetch.
     */
    where?: AddressesWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Addresses to fetch.
     */
    orderBy?:
      | AddressesOrderByWithRelationInput
      | AddressesOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Addresses.
     */
    cursor?: AddressesWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Addresses.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Addresses.
     */
    distinct?: AddressesScalarFieldEnum | AddressesScalarFieldEnum[];
  };

  /**
   * Addresses findMany
   */
  export type AddressesFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Addresses
     */
    select?: AddressesSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AddressesInclude<ExtArgs> | null;
    /**
     * Filter, which Addresses to fetch.
     */
    where?: AddressesWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Addresses to fetch.
     */
    orderBy?:
      | AddressesOrderByWithRelationInput
      | AddressesOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Addresses.
     */
    cursor?: AddressesWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Addresses.
     */
    skip?: number;
    distinct?: AddressesScalarFieldEnum | AddressesScalarFieldEnum[];
  };

  /**
   * Addresses create
   */
  export type AddressesCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Addresses
     */
    select?: AddressesSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AddressesInclude<ExtArgs> | null;
    /**
     * The data needed to create a Addresses.
     */
    data: XOR<AddressesCreateInput, AddressesUncheckedCreateInput>;
  };

  /**
   * Addresses createMany
   */
  export type AddressesCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many Addresses.
     */
    data: AddressesCreateManyInput | AddressesCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Addresses update
   */
  export type AddressesUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Addresses
     */
    select?: AddressesSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AddressesInclude<ExtArgs> | null;
    /**
     * The data needed to update a Addresses.
     */
    data: XOR<AddressesUpdateInput, AddressesUncheckedUpdateInput>;
    /**
     * Choose, which Addresses to update.
     */
    where: AddressesWhereUniqueInput;
  };

  /**
   * Addresses updateMany
   */
  export type AddressesUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update Addresses.
     */
    data: XOR<
      AddressesUpdateManyMutationInput,
      AddressesUncheckedUpdateManyInput
    >;
    /**
     * Filter which Addresses to update
     */
    where?: AddressesWhereInput;
  };

  /**
   * Addresses upsert
   */
  export type AddressesUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Addresses
     */
    select?: AddressesSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AddressesInclude<ExtArgs> | null;
    /**
     * The filter to search for the Addresses to update in case it exists.
     */
    where: AddressesWhereUniqueInput;
    /**
     * In case the Addresses found by the `where` argument doesn't exist, create a new Addresses with this data.
     */
    create: XOR<AddressesCreateInput, AddressesUncheckedCreateInput>;
    /**
     * In case the Addresses was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AddressesUpdateInput, AddressesUncheckedUpdateInput>;
  };

  /**
   * Addresses delete
   */
  export type AddressesDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Addresses
     */
    select?: AddressesSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AddressesInclude<ExtArgs> | null;
    /**
     * Filter which Addresses to delete.
     */
    where: AddressesWhereUniqueInput;
  };

  /**
   * Addresses deleteMany
   */
  export type AddressesDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which Addresses to delete
     */
    where?: AddressesWhereInput;
  };

  /**
   * Addresses.users
   */
  export type Addresses$usersArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsersInclude<ExtArgs> | null;
    where?: UsersWhereInput;
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[];
    cursor?: UsersWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[];
  };

  /**
   * Addresses.property_clients
   */
  export type Addresses$property_clientsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Clients
     */
    select?: ClientsSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClientsInclude<ExtArgs> | null;
    where?: ClientsWhereInput;
    orderBy?:
      | ClientsOrderByWithRelationInput
      | ClientsOrderByWithRelationInput[];
    cursor?: ClientsWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ClientsScalarFieldEnum | ClientsScalarFieldEnum[];
  };

  /**
   * Addresses.billing_clients
   */
  export type Addresses$billing_clientsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Clients
     */
    select?: ClientsSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClientsInclude<ExtArgs> | null;
    where?: ClientsWhereInput;
    orderBy?:
      | ClientsOrderByWithRelationInput
      | ClientsOrderByWithRelationInput[];
    cursor?: ClientsWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ClientsScalarFieldEnum | ClientsScalarFieldEnum[];
  };

  /**
   * Addresses without action
   */
  export type AddressesDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Addresses
     */
    select?: AddressesSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AddressesInclude<ExtArgs> | null;
  };

  /**
   * Model Users
   */

  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null;
    _avg: UsersAvgAggregateOutputType | null;
    _sum: UsersSumAggregateOutputType | null;
    _min: UsersMinAggregateOutputType | null;
    _max: UsersMaxAggregateOutputType | null;
  };

  export type UsersAvgAggregateOutputType = {
    id: number | null;
    default_tax_id: number | null;
    address_id: number | null;
  };

  export type UsersSumAggregateOutputType = {
    id: number | null;
    default_tax_id: number | null;
    address_id: number | null;
  };

  export type UsersMinAggregateOutputType = {
    id: number | null;
    email: string | null;
    password: string | null;
    first_name: string | null;
    last_name: string | null;
    phone_number: string | null;
    company_name: string | null;
    subscription_id: string | null;
    free_trial_expiration_date: Date | null;
    default_tax_id: number | null;
    address_id: number | null;
  };

  export type UsersMaxAggregateOutputType = {
    id: number | null;
    email: string | null;
    password: string | null;
    first_name: string | null;
    last_name: string | null;
    phone_number: string | null;
    company_name: string | null;
    subscription_id: string | null;
    free_trial_expiration_date: Date | null;
    default_tax_id: number | null;
    address_id: number | null;
  };

  export type UsersCountAggregateOutputType = {
    id: number;
    email: number;
    password: number;
    first_name: number;
    last_name: number;
    phone_number: number;
    company_name: number;
    subscription_id: number;
    free_trial_expiration_date: number;
    default_tax_id: number;
    address_id: number;
    settings: number;
    _all: number;
  };

  export type UsersAvgAggregateInputType = {
    id?: true;
    default_tax_id?: true;
    address_id?: true;
  };

  export type UsersSumAggregateInputType = {
    id?: true;
    default_tax_id?: true;
    address_id?: true;
  };

  export type UsersMinAggregateInputType = {
    id?: true;
    email?: true;
    password?: true;
    first_name?: true;
    last_name?: true;
    phone_number?: true;
    company_name?: true;
    subscription_id?: true;
    free_trial_expiration_date?: true;
    default_tax_id?: true;
    address_id?: true;
  };

  export type UsersMaxAggregateInputType = {
    id?: true;
    email?: true;
    password?: true;
    first_name?: true;
    last_name?: true;
    phone_number?: true;
    company_name?: true;
    subscription_id?: true;
    free_trial_expiration_date?: true;
    default_tax_id?: true;
    address_id?: true;
  };

  export type UsersCountAggregateInputType = {
    id?: true;
    email?: true;
    password?: true;
    first_name?: true;
    last_name?: true;
    phone_number?: true;
    company_name?: true;
    subscription_id?: true;
    free_trial_expiration_date?: true;
    default_tax_id?: true;
    address_id?: true;
    settings?: true;
    _all?: true;
  };

  export type UsersAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which Users to aggregate.
     */
    where?: UsersWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Users to fetch.
     */
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: UsersWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Users from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Users.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Users
     **/
    _count?: true | UsersCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: UsersAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: UsersSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: UsersMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: UsersMaxAggregateInputType;
  };

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
    [P in keyof T & keyof AggregateUsers]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>;
  };

  export type UsersGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: UsersWhereInput;
    orderBy?:
      | UsersOrderByWithAggregationInput
      | UsersOrderByWithAggregationInput[];
    by: UsersScalarFieldEnum[] | UsersScalarFieldEnum;
    having?: UsersScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: UsersCountAggregateInputType | true;
    _avg?: UsersAvgAggregateInputType;
    _sum?: UsersSumAggregateInputType;
    _min?: UsersMinAggregateInputType;
    _max?: UsersMaxAggregateInputType;
  };

  export type UsersGroupByOutputType = {
    id: number;
    email: string | null;
    password: string;
    first_name: string;
    last_name: string;
    phone_number: string | null;
    company_name: string | null;
    subscription_id: string | null;
    free_trial_expiration_date: Date | null;
    default_tax_id: number | null;
    address_id: number | null;
    settings: JsonValue | null;
    _count: UsersCountAggregateOutputType | null;
    _avg: UsersAvgAggregateOutputType | null;
    _sum: UsersSumAggregateOutputType | null;
    _min: UsersMinAggregateOutputType | null;
    _max: UsersMaxAggregateOutputType | null;
  };

  type GetUsersGroupByPayload<T extends UsersGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<UsersGroupByOutputType, T["by"]> & {
          [P in keyof T & keyof UsersGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>;
        }
      >
    >;

  export type UsersSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      email?: boolean;
      password?: boolean;
      first_name?: boolean;
      last_name?: boolean;
      phone_number?: boolean;
      company_name?: boolean;
      subscription_id?: boolean;
      free_trial_expiration_date?: boolean;
      default_tax_id?: boolean;
      address_id?: boolean;
      settings?: boolean;
      default_tax?: boolean | Users$default_taxArgs<ExtArgs>;
      address?: boolean | Users$addressArgs<ExtArgs>;
      clients?: boolean | Users$clientsArgs<ExtArgs>;
      requests?: boolean | Users$requestsArgs<ExtArgs>;
      jobs?: boolean | Users$jobsArgs<ExtArgs>;
      quotes?: boolean | Users$quotesArgs<ExtArgs>;
      invoices?: boolean | Users$invoicesArgs<ExtArgs>;
      _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["users"]
  >;

  export type UsersSelectScalar = {
    id?: boolean;
    email?: boolean;
    password?: boolean;
    first_name?: boolean;
    last_name?: boolean;
    phone_number?: boolean;
    company_name?: boolean;
    subscription_id?: boolean;
    free_trial_expiration_date?: boolean;
    default_tax_id?: boolean;
    address_id?: boolean;
    settings?: boolean;
  };

  export type UsersInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    default_tax?: boolean | Users$default_taxArgs<ExtArgs>;
    address?: boolean | Users$addressArgs<ExtArgs>;
    clients?: boolean | Users$clientsArgs<ExtArgs>;
    requests?: boolean | Users$requestsArgs<ExtArgs>;
    jobs?: boolean | Users$jobsArgs<ExtArgs>;
    quotes?: boolean | Users$quotesArgs<ExtArgs>;
    invoices?: boolean | Users$invoicesArgs<ExtArgs>;
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>;
  };

  export type $UsersPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: "Users";
    objects: {
      default_tax: Prisma.$TaxesPayload<ExtArgs> | null;
      address: Prisma.$AddressesPayload<ExtArgs> | null;
      clients: Prisma.$ClientsPayload<ExtArgs>[];
      requests: Prisma.$RequestsPayload<ExtArgs>[];
      jobs: Prisma.$JobsPayload<ExtArgs>[];
      quotes: Prisma.$QuotesPayload<ExtArgs>[];
      invoices: Prisma.$InvoicesPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: number;
        email: string | null;
        password: string;
        first_name: string;
        last_name: string;
        phone_number: string | null;
        company_name: string | null;
        subscription_id: string | null;
        free_trial_expiration_date: Date | null;
        default_tax_id: number | null;
        address_id: number | null;
        settings: Prisma.JsonValue | null;
      },
      ExtArgs["result"]["users"]
    >;
    composites: {};
  };

  type UsersGetPayload<
    S extends boolean | null | undefined | UsersDefaultArgs
  > = $Result.GetResult<Prisma.$UsersPayload, S>;

  type UsersCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<UsersFindManyArgs, "select" | "include" | "distinct"> & {
    select?: UsersCountAggregateInputType | true;
  };

  export interface UsersDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["Users"];
      meta: { name: "Users" };
    };
    /**
     * Find zero or one Users that matches the filter.
     * @param {UsersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     **/
    findUnique<T extends UsersFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UsersFindUniqueArgs<ExtArgs>>
    ): Prisma__UsersClient<
      $Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUnique"> | null,
      null,
      ExtArgs
    >;

    /**
     * Find one Users that matches the filter or throw an error  with `error.code='P2025'`
     *     if no matches were found.
     * @param {UsersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     **/
    findUniqueOrThrow<T extends UsersFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UsersFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UsersClient<
      $Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow">,
      never,
      ExtArgs
    >;

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     **/
    findFirst<T extends UsersFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UsersFindFirstArgs<ExtArgs>>
    ): Prisma__UsersClient<
      $Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findFirst"> | null,
      null,
      ExtArgs
    >;

    /**
     * Find the first Users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     **/
    findFirstOrThrow<T extends UsersFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UsersFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UsersClient<
      $Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findFirstOrThrow">,
      never,
      ExtArgs
    >;

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     *
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const usersWithIdOnly = await prisma.users.findMany({ select: { id: true } })
     *
     **/
    findMany<T extends UsersFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UsersFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findMany">
    >;

    /**
     * Create a Users.
     * @param {UsersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     *
     **/
    create<T extends UsersCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UsersCreateArgs<ExtArgs>>
    ): Prisma__UsersClient<
      $Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "create">,
      never,
      ExtArgs
    >;

    /**
     * Create many Users.
     *     @param {UsersCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const users = await prisma.users.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *
     **/
    createMany<T extends UsersCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UsersCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a Users.
     * @param {UsersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     *
     **/
    delete<T extends UsersDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UsersDeleteArgs<ExtArgs>>
    ): Prisma__UsersClient<
      $Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "delete">,
      never,
      ExtArgs
    >;

    /**
     * Update one Users.
     * @param {UsersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     **/
    update<T extends UsersUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UsersUpdateArgs<ExtArgs>>
    ): Prisma__UsersClient<
      $Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "update">,
      never,
      ExtArgs
    >;

    /**
     * Delete zero or more Users.
     * @param {UsersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     **/
    deleteMany<T extends UsersDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UsersDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     **/
    updateMany<T extends UsersUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UsersUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one Users.
     * @param {UsersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
     **/
    upsert<T extends UsersUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UsersUpsertArgs<ExtArgs>>
    ): Prisma__UsersClient<
      $Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "upsert">,
      never,
      ExtArgs
    >;

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
     **/
    count<T extends UsersCountArgs>(
      args?: Subset<T, UsersCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], UsersCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends UsersAggregateArgs>(
      args: Subset<T, UsersAggregateArgs>
    ): Prisma.PrismaPromise<GetUsersAggregateType<T>>;

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends UsersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsersGroupByArgs["orderBy"] }
        : { orderBy?: UsersGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
        ? {
            [P in HavingFields]: P extends ByFields
              ? never
              : P extends string
              ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
              : [
                  Error,
                  "Field ",
                  P,
                  ` in "having" needs to be provided in "by"`
                ];
          }[HavingFields]
        : "take" extends Keys<T>
        ? "orderBy" extends Keys<T>
          ? ByValid extends True
            ? {}
            : {
                [P in OrderFields]: P extends ByFields
                  ? never
                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
              }[OrderFields]
          : 'Error: If you provide "take", you also need to provide "orderBy"'
        : "skip" extends Keys<T>
        ? "orderBy" extends Keys<T>
          ? ByValid extends True
            ? {}
            : {
                [P in OrderFields]: P extends ByFields
                  ? never
                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
              }[OrderFields]
          : 'Error: If you provide "skip", you also need to provide "orderBy"'
        : ByValid extends True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
          }[OrderFields]
    >(
      args: SubsetIntersection<T, UsersGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetUsersGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Users model
     */
    readonly fields: UsersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsersClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";

    default_tax<T extends Users$default_taxArgs<ExtArgs> = {}>(
      args?: Subset<T, Users$default_taxArgs<ExtArgs>>
    ): Prisma__TaxesClient<
      $Result.GetResult<
        Prisma.$TaxesPayload<ExtArgs>,
        T,
        "findUniqueOrThrow"
      > | null,
      null,
      ExtArgs
    >;

    address<T extends Users$addressArgs<ExtArgs> = {}>(
      args?: Subset<T, Users$addressArgs<ExtArgs>>
    ): Prisma__AddressesClient<
      $Result.GetResult<
        Prisma.$AddressesPayload<ExtArgs>,
        T,
        "findUniqueOrThrow"
      > | null,
      null,
      ExtArgs
    >;

    clients<T extends Users$clientsArgs<ExtArgs> = {}>(
      args?: Subset<T, Users$clientsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$ClientsPayload<ExtArgs>, T, "findMany"> | Null
    >;

    requests<T extends Users$requestsArgs<ExtArgs> = {}>(
      args?: Subset<T, Users$requestsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$RequestsPayload<ExtArgs>, T, "findMany"> | Null
    >;

    jobs<T extends Users$jobsArgs<ExtArgs> = {}>(
      args?: Subset<T, Users$jobsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$JobsPayload<ExtArgs>, T, "findMany"> | Null
    >;

    quotes<T extends Users$quotesArgs<ExtArgs> = {}>(
      args?: Subset<T, Users$quotesArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$QuotesPayload<ExtArgs>, T, "findMany"> | Null
    >;

    invoices<T extends Users$invoicesArgs<ExtArgs> = {}>(
      args?: Subset<T, Users$invoicesArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$InvoicesPayload<ExtArgs>, T, "findMany"> | Null
    >;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Users model
   */
  interface UsersFieldRefs {
    readonly id: FieldRef<"Users", "Int">;
    readonly email: FieldRef<"Users", "String">;
    readonly password: FieldRef<"Users", "String">;
    readonly first_name: FieldRef<"Users", "String">;
    readonly last_name: FieldRef<"Users", "String">;
    readonly phone_number: FieldRef<"Users", "String">;
    readonly company_name: FieldRef<"Users", "String">;
    readonly subscription_id: FieldRef<"Users", "String">;
    readonly free_trial_expiration_date: FieldRef<"Users", "DateTime">;
    readonly default_tax_id: FieldRef<"Users", "Int">;
    readonly address_id: FieldRef<"Users", "Int">;
    readonly settings: FieldRef<"Users", "Json">;
  }

  // Custom InputTypes

  /**
   * Users findUnique
   */
  export type UsersFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsersInclude<ExtArgs> | null;
    /**
     * Filter, which Users to fetch.
     */
    where: UsersWhereUniqueInput;
  };

  /**
   * Users findUniqueOrThrow
   */
  export type UsersFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsersInclude<ExtArgs> | null;
    /**
     * Filter, which Users to fetch.
     */
    where: UsersWhereUniqueInput;
  };

  /**
   * Users findFirst
   */
  export type UsersFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsersInclude<ExtArgs> | null;
    /**
     * Filter, which Users to fetch.
     */
    where?: UsersWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Users to fetch.
     */
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Users.
     */
    cursor?: UsersWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Users from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Users.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[];
  };

  /**
   * Users findFirstOrThrow
   */
  export type UsersFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsersInclude<ExtArgs> | null;
    /**
     * Filter, which Users to fetch.
     */
    where?: UsersWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Users to fetch.
     */
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Users.
     */
    cursor?: UsersWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Users from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Users.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[];
  };

  /**
   * Users findMany
   */
  export type UsersFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsersInclude<ExtArgs> | null;
    /**
     * Filter, which Users to fetch.
     */
    where?: UsersWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Users to fetch.
     */
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Users.
     */
    cursor?: UsersWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Users from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Users.
     */
    skip?: number;
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[];
  };

  /**
   * Users create
   */
  export type UsersCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsersInclude<ExtArgs> | null;
    /**
     * The data needed to create a Users.
     */
    data: XOR<UsersCreateInput, UsersUncheckedCreateInput>;
  };

  /**
   * Users createMany
   */
  export type UsersCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many Users.
     */
    data: UsersCreateManyInput | UsersCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Users update
   */
  export type UsersUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsersInclude<ExtArgs> | null;
    /**
     * The data needed to update a Users.
     */
    data: XOR<UsersUpdateInput, UsersUncheckedUpdateInput>;
    /**
     * Choose, which Users to update.
     */
    where: UsersWhereUniqueInput;
  };

  /**
   * Users updateMany
   */
  export type UsersUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update Users.
     */
    data: XOR<UsersUpdateManyMutationInput, UsersUncheckedUpdateManyInput>;
    /**
     * Filter which Users to update
     */
    where?: UsersWhereInput;
  };

  /**
   * Users upsert
   */
  export type UsersUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsersInclude<ExtArgs> | null;
    /**
     * The filter to search for the Users to update in case it exists.
     */
    where: UsersWhereUniqueInput;
    /**
     * In case the Users found by the `where` argument doesn't exist, create a new Users with this data.
     */
    create: XOR<UsersCreateInput, UsersUncheckedCreateInput>;
    /**
     * In case the Users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsersUpdateInput, UsersUncheckedUpdateInput>;
  };

  /**
   * Users delete
   */
  export type UsersDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsersInclude<ExtArgs> | null;
    /**
     * Filter which Users to delete.
     */
    where: UsersWhereUniqueInput;
  };

  /**
   * Users deleteMany
   */
  export type UsersDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which Users to delete
     */
    where?: UsersWhereInput;
  };

  /**
   * Users.default_tax
   */
  export type Users$default_taxArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Taxes
     */
    select?: TaxesSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TaxesInclude<ExtArgs> | null;
    where?: TaxesWhereInput;
  };

  /**
   * Users.address
   */
  export type Users$addressArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Addresses
     */
    select?: AddressesSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AddressesInclude<ExtArgs> | null;
    where?: AddressesWhereInput;
  };

  /**
   * Users.clients
   */
  export type Users$clientsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Clients
     */
    select?: ClientsSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClientsInclude<ExtArgs> | null;
    where?: ClientsWhereInput;
    orderBy?:
      | ClientsOrderByWithRelationInput
      | ClientsOrderByWithRelationInput[];
    cursor?: ClientsWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ClientsScalarFieldEnum | ClientsScalarFieldEnum[];
  };

  /**
   * Users.requests
   */
  export type Users$requestsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Requests
     */
    select?: RequestsSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RequestsInclude<ExtArgs> | null;
    where?: RequestsWhereInput;
    orderBy?:
      | RequestsOrderByWithRelationInput
      | RequestsOrderByWithRelationInput[];
    cursor?: RequestsWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: RequestsScalarFieldEnum | RequestsScalarFieldEnum[];
  };

  /**
   * Users.jobs
   */
  export type Users$jobsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Jobs
     */
    select?: JobsSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobsInclude<ExtArgs> | null;
    where?: JobsWhereInput;
    orderBy?: JobsOrderByWithRelationInput | JobsOrderByWithRelationInput[];
    cursor?: JobsWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: JobsScalarFieldEnum | JobsScalarFieldEnum[];
  };

  /**
   * Users.quotes
   */
  export type Users$quotesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Quotes
     */
    select?: QuotesSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuotesInclude<ExtArgs> | null;
    where?: QuotesWhereInput;
    orderBy?: QuotesOrderByWithRelationInput | QuotesOrderByWithRelationInput[];
    cursor?: QuotesWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: QuotesScalarFieldEnum | QuotesScalarFieldEnum[];
  };

  /**
   * Users.invoices
   */
  export type Users$invoicesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Invoices
     */
    select?: InvoicesSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvoicesInclude<ExtArgs> | null;
    where?: InvoicesWhereInput;
    orderBy?:
      | InvoicesOrderByWithRelationInput
      | InvoicesOrderByWithRelationInput[];
    cursor?: InvoicesWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: InvoicesScalarFieldEnum | InvoicesScalarFieldEnum[];
  };

  /**
   * Users without action
   */
  export type UsersDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsersInclude<ExtArgs> | null;
  };

  /**
   * Model Clients
   */

  export type AggregateClients = {
    _count: ClientsCountAggregateOutputType | null;
    _avg: ClientsAvgAggregateOutputType | null;
    _sum: ClientsSumAggregateOutputType | null;
    _min: ClientsMinAggregateOutputType | null;
    _max: ClientsMaxAggregateOutputType | null;
  };

  export type ClientsAvgAggregateOutputType = {
    id: number | null;
    property_address_id: number | null;
    billing_address_id: number | null;
    belongs_to_id: number | null;
  };

  export type ClientsSumAggregateOutputType = {
    id: number | null;
    property_address_id: number | null;
    billing_address_id: number | null;
    belongs_to_id: number | null;
  };

  export type ClientsMinAggregateOutputType = {
    id: number | null;
    title: string | null;
    first_name: string | null;
    last_name: string | null;
    company_name: string | null;
    use_company_name_as_primary: boolean | null;
    mobile_phone_number: string | null;
    work_phone_number: string | null;
    email: string | null;
    quote_follow_up: boolean | null;
    job_follow_up: boolean | null;
    invoice_follow_up: boolean | null;
    upcoming_visit_reminder: boolean | null;
    referred_by: string | null;
    billing_address_same_as_property: boolean | null;
    property_address_id: number | null;
    billing_address_id: number | null;
    created_date: Date | null;
    status: string | null;
    belongs_to_id: number | null;
  };

  export type ClientsMaxAggregateOutputType = {
    id: number | null;
    title: string | null;
    first_name: string | null;
    last_name: string | null;
    company_name: string | null;
    use_company_name_as_primary: boolean | null;
    mobile_phone_number: string | null;
    work_phone_number: string | null;
    email: string | null;
    quote_follow_up: boolean | null;
    job_follow_up: boolean | null;
    invoice_follow_up: boolean | null;
    upcoming_visit_reminder: boolean | null;
    referred_by: string | null;
    billing_address_same_as_property: boolean | null;
    property_address_id: number | null;
    billing_address_id: number | null;
    created_date: Date | null;
    status: string | null;
    belongs_to_id: number | null;
  };

  export type ClientsCountAggregateOutputType = {
    id: number;
    title: number;
    tags: number;
    first_name: number;
    last_name: number;
    company_name: number;
    use_company_name_as_primary: number;
    mobile_phone_number: number;
    work_phone_number: number;
    email: number;
    quote_follow_up: number;
    job_follow_up: number;
    invoice_follow_up: number;
    upcoming_visit_reminder: number;
    referred_by: number;
    billing_address_same_as_property: number;
    property_address_id: number;
    billing_address_id: number;
    created_date: number;
    status: number;
    belongs_to_id: number;
    _all: number;
  };

  export type ClientsAvgAggregateInputType = {
    id?: true;
    property_address_id?: true;
    billing_address_id?: true;
    belongs_to_id?: true;
  };

  export type ClientsSumAggregateInputType = {
    id?: true;
    property_address_id?: true;
    billing_address_id?: true;
    belongs_to_id?: true;
  };

  export type ClientsMinAggregateInputType = {
    id?: true;
    title?: true;
    first_name?: true;
    last_name?: true;
    company_name?: true;
    use_company_name_as_primary?: true;
    mobile_phone_number?: true;
    work_phone_number?: true;
    email?: true;
    quote_follow_up?: true;
    job_follow_up?: true;
    invoice_follow_up?: true;
    upcoming_visit_reminder?: true;
    referred_by?: true;
    billing_address_same_as_property?: true;
    property_address_id?: true;
    billing_address_id?: true;
    created_date?: true;
    status?: true;
    belongs_to_id?: true;
  };

  export type ClientsMaxAggregateInputType = {
    id?: true;
    title?: true;
    first_name?: true;
    last_name?: true;
    company_name?: true;
    use_company_name_as_primary?: true;
    mobile_phone_number?: true;
    work_phone_number?: true;
    email?: true;
    quote_follow_up?: true;
    job_follow_up?: true;
    invoice_follow_up?: true;
    upcoming_visit_reminder?: true;
    referred_by?: true;
    billing_address_same_as_property?: true;
    property_address_id?: true;
    billing_address_id?: true;
    created_date?: true;
    status?: true;
    belongs_to_id?: true;
  };

  export type ClientsCountAggregateInputType = {
    id?: true;
    title?: true;
    tags?: true;
    first_name?: true;
    last_name?: true;
    company_name?: true;
    use_company_name_as_primary?: true;
    mobile_phone_number?: true;
    work_phone_number?: true;
    email?: true;
    quote_follow_up?: true;
    job_follow_up?: true;
    invoice_follow_up?: true;
    upcoming_visit_reminder?: true;
    referred_by?: true;
    billing_address_same_as_property?: true;
    property_address_id?: true;
    billing_address_id?: true;
    created_date?: true;
    status?: true;
    belongs_to_id?: true;
    _all?: true;
  };

  export type ClientsAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which Clients to aggregate.
     */
    where?: ClientsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Clients to fetch.
     */
    orderBy?:
      | ClientsOrderByWithRelationInput
      | ClientsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: ClientsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Clients.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Clients
     **/
    _count?: true | ClientsCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: ClientsAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: ClientsSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ClientsMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ClientsMaxAggregateInputType;
  };

  export type GetClientsAggregateType<T extends ClientsAggregateArgs> = {
    [P in keyof T & keyof AggregateClients]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClients[P]>
      : GetScalarType<T[P], AggregateClients[P]>;
  };

  export type ClientsGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: ClientsWhereInput;
    orderBy?:
      | ClientsOrderByWithAggregationInput
      | ClientsOrderByWithAggregationInput[];
    by: ClientsScalarFieldEnum[] | ClientsScalarFieldEnum;
    having?: ClientsScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ClientsCountAggregateInputType | true;
    _avg?: ClientsAvgAggregateInputType;
    _sum?: ClientsSumAggregateInputType;
    _min?: ClientsMinAggregateInputType;
    _max?: ClientsMaxAggregateInputType;
  };

  export type ClientsGroupByOutputType = {
    id: number;
    title: string;
    tags: JsonValue | null;
    first_name: string;
    last_name: string;
    company_name: string | null;
    use_company_name_as_primary: boolean;
    mobile_phone_number: string | null;
    work_phone_number: string | null;
    email: string | null;
    quote_follow_up: boolean;
    job_follow_up: boolean;
    invoice_follow_up: boolean;
    upcoming_visit_reminder: boolean;
    referred_by: string | null;
    billing_address_same_as_property: boolean;
    property_address_id: number | null;
    billing_address_id: number | null;
    created_date: Date;
    status: string | null;
    belongs_to_id: number;
    _count: ClientsCountAggregateOutputType | null;
    _avg: ClientsAvgAggregateOutputType | null;
    _sum: ClientsSumAggregateOutputType | null;
    _min: ClientsMinAggregateOutputType | null;
    _max: ClientsMaxAggregateOutputType | null;
  };

  type GetClientsGroupByPayload<T extends ClientsGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<ClientsGroupByOutputType, T["by"]> & {
          [P in keyof T & keyof ClientsGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientsGroupByOutputType[P]>
            : GetScalarType<T[P], ClientsGroupByOutputType[P]>;
        }
      >
    >;

  export type ClientsSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      title?: boolean;
      tags?: boolean;
      first_name?: boolean;
      last_name?: boolean;
      company_name?: boolean;
      use_company_name_as_primary?: boolean;
      mobile_phone_number?: boolean;
      work_phone_number?: boolean;
      email?: boolean;
      quote_follow_up?: boolean;
      job_follow_up?: boolean;
      invoice_follow_up?: boolean;
      upcoming_visit_reminder?: boolean;
      referred_by?: boolean;
      billing_address_same_as_property?: boolean;
      property_address_id?: boolean;
      billing_address_id?: boolean;
      created_date?: boolean;
      status?: boolean;
      belongs_to_id?: boolean;
      property_address?: boolean | Clients$property_addressArgs<ExtArgs>;
      billing_address?: boolean | Clients$billing_addressArgs<ExtArgs>;
      requests?: boolean | Clients$requestsArgs<ExtArgs>;
      quotes?: boolean | Clients$quotesArgs<ExtArgs>;
      jobs?: boolean | Clients$jobsArgs<ExtArgs>;
      invoices?: boolean | Clients$invoicesArgs<ExtArgs>;
      belongs_to?: boolean | UsersDefaultArgs<ExtArgs>;
      _count?: boolean | ClientsCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["clients"]
  >;

  export type ClientsSelectScalar = {
    id?: boolean;
    title?: boolean;
    tags?: boolean;
    first_name?: boolean;
    last_name?: boolean;
    company_name?: boolean;
    use_company_name_as_primary?: boolean;
    mobile_phone_number?: boolean;
    work_phone_number?: boolean;
    email?: boolean;
    quote_follow_up?: boolean;
    job_follow_up?: boolean;
    invoice_follow_up?: boolean;
    upcoming_visit_reminder?: boolean;
    referred_by?: boolean;
    billing_address_same_as_property?: boolean;
    property_address_id?: boolean;
    billing_address_id?: boolean;
    created_date?: boolean;
    status?: boolean;
    belongs_to_id?: boolean;
  };

  export type ClientsInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    property_address?: boolean | Clients$property_addressArgs<ExtArgs>;
    billing_address?: boolean | Clients$billing_addressArgs<ExtArgs>;
    requests?: boolean | Clients$requestsArgs<ExtArgs>;
    quotes?: boolean | Clients$quotesArgs<ExtArgs>;
    jobs?: boolean | Clients$jobsArgs<ExtArgs>;
    invoices?: boolean | Clients$invoicesArgs<ExtArgs>;
    belongs_to?: boolean | UsersDefaultArgs<ExtArgs>;
    _count?: boolean | ClientsCountOutputTypeDefaultArgs<ExtArgs>;
  };

  export type $ClientsPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: "Clients";
    objects: {
      property_address: Prisma.$AddressesPayload<ExtArgs> | null;
      billing_address: Prisma.$AddressesPayload<ExtArgs> | null;
      requests: Prisma.$RequestsPayload<ExtArgs>[];
      quotes: Prisma.$QuotesPayload<ExtArgs>[];
      jobs: Prisma.$JobsPayload<ExtArgs>[];
      invoices: Prisma.$InvoicesPayload<ExtArgs>[];
      belongs_to: Prisma.$UsersPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: number;
        title: string;
        tags: Prisma.JsonValue | null;
        first_name: string;
        last_name: string;
        company_name: string | null;
        use_company_name_as_primary: boolean;
        mobile_phone_number: string | null;
        work_phone_number: string | null;
        email: string | null;
        quote_follow_up: boolean;
        job_follow_up: boolean;
        invoice_follow_up: boolean;
        upcoming_visit_reminder: boolean;
        referred_by: string | null;
        billing_address_same_as_property: boolean;
        property_address_id: number | null;
        billing_address_id: number | null;
        created_date: Date;
        status: string | null;
        belongs_to_id: number;
      },
      ExtArgs["result"]["clients"]
    >;
    composites: {};
  };

  type ClientsGetPayload<
    S extends boolean | null | undefined | ClientsDefaultArgs
  > = $Result.GetResult<Prisma.$ClientsPayload, S>;

  type ClientsCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<ClientsFindManyArgs, "select" | "include" | "distinct"> & {
    select?: ClientsCountAggregateInputType | true;
  };

  export interface ClientsDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["Clients"];
      meta: { name: "Clients" };
    };
    /**
     * Find zero or one Clients that matches the filter.
     * @param {ClientsFindUniqueArgs} args - Arguments to find a Clients
     * @example
     * // Get one Clients
     * const clients = await prisma.clients.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     **/
    findUnique<T extends ClientsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ClientsFindUniqueArgs<ExtArgs>>
    ): Prisma__ClientsClient<
      $Result.GetResult<
        Prisma.$ClientsPayload<ExtArgs>,
        T,
        "findUnique"
      > | null,
      null,
      ExtArgs
    >;

    /**
     * Find one Clients that matches the filter or throw an error  with `error.code='P2025'`
     *     if no matches were found.
     * @param {ClientsFindUniqueOrThrowArgs} args - Arguments to find a Clients
     * @example
     * // Get one Clients
     * const clients = await prisma.clients.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     **/
    findUniqueOrThrow<T extends ClientsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ClientsClient<
      $Result.GetResult<
        Prisma.$ClientsPayload<ExtArgs>,
        T,
        "findUniqueOrThrow"
      >,
      never,
      ExtArgs
    >;

    /**
     * Find the first Clients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientsFindFirstArgs} args - Arguments to find a Clients
     * @example
     * // Get one Clients
     * const clients = await prisma.clients.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     **/
    findFirst<T extends ClientsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientsFindFirstArgs<ExtArgs>>
    ): Prisma__ClientsClient<
      $Result.GetResult<Prisma.$ClientsPayload<ExtArgs>, T, "findFirst"> | null,
      null,
      ExtArgs
    >;

    /**
     * Find the first Clients that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientsFindFirstOrThrowArgs} args - Arguments to find a Clients
     * @example
     * // Get one Clients
     * const clients = await prisma.clients.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     **/
    findFirstOrThrow<T extends ClientsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ClientsClient<
      $Result.GetResult<Prisma.$ClientsPayload<ExtArgs>, T, "findFirstOrThrow">,
      never,
      ExtArgs
    >;

    /**
     * Find zero or more Clients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clients
     * const clients = await prisma.clients.findMany()
     *
     * // Get first 10 Clients
     * const clients = await prisma.clients.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const clientsWithIdOnly = await prisma.clients.findMany({ select: { id: true } })
     *
     **/
    findMany<T extends ClientsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$ClientsPayload<ExtArgs>, T, "findMany">
    >;

    /**
     * Create a Clients.
     * @param {ClientsCreateArgs} args - Arguments to create a Clients.
     * @example
     * // Create one Clients
     * const Clients = await prisma.clients.create({
     *   data: {
     *     // ... data to create a Clients
     *   }
     * })
     *
     **/
    create<T extends ClientsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ClientsCreateArgs<ExtArgs>>
    ): Prisma__ClientsClient<
      $Result.GetResult<Prisma.$ClientsPayload<ExtArgs>, T, "create">,
      never,
      ExtArgs
    >;

    /**
     * Create many Clients.
     *     @param {ClientsCreateManyArgs} args - Arguments to create many Clients.
     *     @example
     *     // Create many Clients
     *     const clients = await prisma.clients.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *
     **/
    createMany<T extends ClientsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a Clients.
     * @param {ClientsDeleteArgs} args - Arguments to delete one Clients.
     * @example
     * // Delete one Clients
     * const Clients = await prisma.clients.delete({
     *   where: {
     *     // ... filter to delete one Clients
     *   }
     * })
     *
     **/
    delete<T extends ClientsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ClientsDeleteArgs<ExtArgs>>
    ): Prisma__ClientsClient<
      $Result.GetResult<Prisma.$ClientsPayload<ExtArgs>, T, "delete">,
      never,
      ExtArgs
    >;

    /**
     * Update one Clients.
     * @param {ClientsUpdateArgs} args - Arguments to update one Clients.
     * @example
     * // Update one Clients
     * const clients = await prisma.clients.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     **/
    update<T extends ClientsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ClientsUpdateArgs<ExtArgs>>
    ): Prisma__ClientsClient<
      $Result.GetResult<Prisma.$ClientsPayload<ExtArgs>, T, "update">,
      never,
      ExtArgs
    >;

    /**
     * Delete zero or more Clients.
     * @param {ClientsDeleteManyArgs} args - Arguments to filter Clients to delete.
     * @example
     * // Delete a few Clients
     * const { count } = await prisma.clients.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     **/
    deleteMany<T extends ClientsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clients
     * const clients = await prisma.clients.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     **/
    updateMany<T extends ClientsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ClientsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one Clients.
     * @param {ClientsUpsertArgs} args - Arguments to update or create a Clients.
     * @example
     * // Update or create a Clients
     * const clients = await prisma.clients.upsert({
     *   create: {
     *     // ... data to create a Clients
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Clients we want to update
     *   }
     * })
     **/
    upsert<T extends ClientsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ClientsUpsertArgs<ExtArgs>>
    ): Prisma__ClientsClient<
      $Result.GetResult<Prisma.$ClientsPayload<ExtArgs>, T, "upsert">,
      never,
      ExtArgs
    >;

    /**
     * Count the number of Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientsCountArgs} args - Arguments to filter Clients to count.
     * @example
     * // Count the number of Clients
     * const count = await prisma.clients.count({
     *   where: {
     *     // ... the filter for the Clients we want to count
     *   }
     * })
     **/
    count<T extends ClientsCountArgs>(
      args?: Subset<T, ClientsCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], ClientsCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ClientsAggregateArgs>(
      args: Subset<T, ClientsAggregateArgs>
    ): Prisma.PrismaPromise<GetClientsAggregateType<T>>;

    /**
     * Group by Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends ClientsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientsGroupByArgs["orderBy"] }
        : { orderBy?: ClientsGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
        ? {
            [P in HavingFields]: P extends ByFields
              ? never
              : P extends string
              ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
              : [
                  Error,
                  "Field ",
                  P,
                  ` in "having" needs to be provided in "by"`
                ];
          }[HavingFields]
        : "take" extends Keys<T>
        ? "orderBy" extends Keys<T>
          ? ByValid extends True
            ? {}
            : {
                [P in OrderFields]: P extends ByFields
                  ? never
                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
              }[OrderFields]
          : 'Error: If you provide "take", you also need to provide "orderBy"'
        : "skip" extends Keys<T>
        ? "orderBy" extends Keys<T>
          ? ByValid extends True
            ? {}
            : {
                [P in OrderFields]: P extends ByFields
                  ? never
                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
              }[OrderFields]
          : 'Error: If you provide "skip", you also need to provide "orderBy"'
        : ByValid extends True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
          }[OrderFields]
    >(
      args: SubsetIntersection<T, ClientsGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetClientsGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Clients model
     */
    readonly fields: ClientsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Clients.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClientsClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";

    property_address<T extends Clients$property_addressArgs<ExtArgs> = {}>(
      args?: Subset<T, Clients$property_addressArgs<ExtArgs>>
    ): Prisma__AddressesClient<
      $Result.GetResult<
        Prisma.$AddressesPayload<ExtArgs>,
        T,
        "findUniqueOrThrow"
      > | null,
      null,
      ExtArgs
    >;

    billing_address<T extends Clients$billing_addressArgs<ExtArgs> = {}>(
      args?: Subset<T, Clients$billing_addressArgs<ExtArgs>>
    ): Prisma__AddressesClient<
      $Result.GetResult<
        Prisma.$AddressesPayload<ExtArgs>,
        T,
        "findUniqueOrThrow"
      > | null,
      null,
      ExtArgs
    >;

    requests<T extends Clients$requestsArgs<ExtArgs> = {}>(
      args?: Subset<T, Clients$requestsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$RequestsPayload<ExtArgs>, T, "findMany"> | Null
    >;

    quotes<T extends Clients$quotesArgs<ExtArgs> = {}>(
      args?: Subset<T, Clients$quotesArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$QuotesPayload<ExtArgs>, T, "findMany"> | Null
    >;

    jobs<T extends Clients$jobsArgs<ExtArgs> = {}>(
      args?: Subset<T, Clients$jobsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$JobsPayload<ExtArgs>, T, "findMany"> | Null
    >;

    invoices<T extends Clients$invoicesArgs<ExtArgs> = {}>(
      args?: Subset<T, Clients$invoicesArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$InvoicesPayload<ExtArgs>, T, "findMany"> | Null
    >;

    belongs_to<T extends UsersDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UsersDefaultArgs<ExtArgs>>
    ): Prisma__UsersClient<
      | $Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow">
      | Null,
      Null,
      ExtArgs
    >;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Clients model
   */
  interface ClientsFieldRefs {
    readonly id: FieldRef<"Clients", "Int">;
    readonly title: FieldRef<"Clients", "String">;
    readonly tags: FieldRef<"Clients", "Json">;
    readonly first_name: FieldRef<"Clients", "String">;
    readonly last_name: FieldRef<"Clients", "String">;
    readonly company_name: FieldRef<"Clients", "String">;
    readonly use_company_name_as_primary: FieldRef<"Clients", "Boolean">;
    readonly mobile_phone_number: FieldRef<"Clients", "String">;
    readonly work_phone_number: FieldRef<"Clients", "String">;
    readonly email: FieldRef<"Clients", "String">;
    readonly quote_follow_up: FieldRef<"Clients", "Boolean">;
    readonly job_follow_up: FieldRef<"Clients", "Boolean">;
    readonly invoice_follow_up: FieldRef<"Clients", "Boolean">;
    readonly upcoming_visit_reminder: FieldRef<"Clients", "Boolean">;
    readonly referred_by: FieldRef<"Clients", "String">;
    readonly billing_address_same_as_property: FieldRef<"Clients", "Boolean">;
    readonly property_address_id: FieldRef<"Clients", "Int">;
    readonly billing_address_id: FieldRef<"Clients", "Int">;
    readonly created_date: FieldRef<"Clients", "DateTime">;
    readonly status: FieldRef<"Clients", "String">;
    readonly belongs_to_id: FieldRef<"Clients", "Int">;
  }

  // Custom InputTypes

  /**
   * Clients findUnique
   */
  export type ClientsFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Clients
     */
    select?: ClientsSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClientsInclude<ExtArgs> | null;
    /**
     * Filter, which Clients to fetch.
     */
    where: ClientsWhereUniqueInput;
  };

  /**
   * Clients findUniqueOrThrow
   */
  export type ClientsFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Clients
     */
    select?: ClientsSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClientsInclude<ExtArgs> | null;
    /**
     * Filter, which Clients to fetch.
     */
    where: ClientsWhereUniqueInput;
  };

  /**
   * Clients findFirst
   */
  export type ClientsFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Clients
     */
    select?: ClientsSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClientsInclude<ExtArgs> | null;
    /**
     * Filter, which Clients to fetch.
     */
    where?: ClientsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Clients to fetch.
     */
    orderBy?:
      | ClientsOrderByWithRelationInput
      | ClientsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Clients.
     */
    cursor?: ClientsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Clients.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Clients.
     */
    distinct?: ClientsScalarFieldEnum | ClientsScalarFieldEnum[];
  };

  /**
   * Clients findFirstOrThrow
   */
  export type ClientsFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Clients
     */
    select?: ClientsSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClientsInclude<ExtArgs> | null;
    /**
     * Filter, which Clients to fetch.
     */
    where?: ClientsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Clients to fetch.
     */
    orderBy?:
      | ClientsOrderByWithRelationInput
      | ClientsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Clients.
     */
    cursor?: ClientsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Clients.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Clients.
     */
    distinct?: ClientsScalarFieldEnum | ClientsScalarFieldEnum[];
  };

  /**
   * Clients findMany
   */
  export type ClientsFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Clients
     */
    select?: ClientsSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClientsInclude<ExtArgs> | null;
    /**
     * Filter, which Clients to fetch.
     */
    where?: ClientsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Clients to fetch.
     */
    orderBy?:
      | ClientsOrderByWithRelationInput
      | ClientsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Clients.
     */
    cursor?: ClientsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Clients.
     */
    skip?: number;
    distinct?: ClientsScalarFieldEnum | ClientsScalarFieldEnum[];
  };

  /**
   * Clients create
   */
  export type ClientsCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Clients
     */
    select?: ClientsSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClientsInclude<ExtArgs> | null;
    /**
     * The data needed to create a Clients.
     */
    data: XOR<ClientsCreateInput, ClientsUncheckedCreateInput>;
  };

  /**
   * Clients createMany
   */
  export type ClientsCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many Clients.
     */
    data: ClientsCreateManyInput | ClientsCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Clients update
   */
  export type ClientsUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Clients
     */
    select?: ClientsSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClientsInclude<ExtArgs> | null;
    /**
     * The data needed to update a Clients.
     */
    data: XOR<ClientsUpdateInput, ClientsUncheckedUpdateInput>;
    /**
     * Choose, which Clients to update.
     */
    where: ClientsWhereUniqueInput;
  };

  /**
   * Clients updateMany
   */
  export type ClientsUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update Clients.
     */
    data: XOR<ClientsUpdateManyMutationInput, ClientsUncheckedUpdateManyInput>;
    /**
     * Filter which Clients to update
     */
    where?: ClientsWhereInput;
  };

  /**
   * Clients upsert
   */
  export type ClientsUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Clients
     */
    select?: ClientsSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClientsInclude<ExtArgs> | null;
    /**
     * The filter to search for the Clients to update in case it exists.
     */
    where: ClientsWhereUniqueInput;
    /**
     * In case the Clients found by the `where` argument doesn't exist, create a new Clients with this data.
     */
    create: XOR<ClientsCreateInput, ClientsUncheckedCreateInput>;
    /**
     * In case the Clients was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientsUpdateInput, ClientsUncheckedUpdateInput>;
  };

  /**
   * Clients delete
   */
  export type ClientsDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Clients
     */
    select?: ClientsSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClientsInclude<ExtArgs> | null;
    /**
     * Filter which Clients to delete.
     */
    where: ClientsWhereUniqueInput;
  };

  /**
   * Clients deleteMany
   */
  export type ClientsDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which Clients to delete
     */
    where?: ClientsWhereInput;
  };

  /**
   * Clients.property_address
   */
  export type Clients$property_addressArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Addresses
     */
    select?: AddressesSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AddressesInclude<ExtArgs> | null;
    where?: AddressesWhereInput;
  };

  /**
   * Clients.billing_address
   */
  export type Clients$billing_addressArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Addresses
     */
    select?: AddressesSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AddressesInclude<ExtArgs> | null;
    where?: AddressesWhereInput;
  };

  /**
   * Clients.requests
   */
  export type Clients$requestsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Requests
     */
    select?: RequestsSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RequestsInclude<ExtArgs> | null;
    where?: RequestsWhereInput;
    orderBy?:
      | RequestsOrderByWithRelationInput
      | RequestsOrderByWithRelationInput[];
    cursor?: RequestsWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: RequestsScalarFieldEnum | RequestsScalarFieldEnum[];
  };

  /**
   * Clients.quotes
   */
  export type Clients$quotesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Quotes
     */
    select?: QuotesSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuotesInclude<ExtArgs> | null;
    where?: QuotesWhereInput;
    orderBy?: QuotesOrderByWithRelationInput | QuotesOrderByWithRelationInput[];
    cursor?: QuotesWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: QuotesScalarFieldEnum | QuotesScalarFieldEnum[];
  };

  /**
   * Clients.jobs
   */
  export type Clients$jobsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Jobs
     */
    select?: JobsSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobsInclude<ExtArgs> | null;
    where?: JobsWhereInput;
    orderBy?: JobsOrderByWithRelationInput | JobsOrderByWithRelationInput[];
    cursor?: JobsWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: JobsScalarFieldEnum | JobsScalarFieldEnum[];
  };

  /**
   * Clients.invoices
   */
  export type Clients$invoicesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Invoices
     */
    select?: InvoicesSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvoicesInclude<ExtArgs> | null;
    where?: InvoicesWhereInput;
    orderBy?:
      | InvoicesOrderByWithRelationInput
      | InvoicesOrderByWithRelationInput[];
    cursor?: InvoicesWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: InvoicesScalarFieldEnum | InvoicesScalarFieldEnum[];
  };

  /**
   * Clients without action
   */
  export type ClientsDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Clients
     */
    select?: ClientsSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClientsInclude<ExtArgs> | null;
  };

  /**
   * Model Assessments
   */

  export type AggregateAssessments = {
    _count: AssessmentsCountAggregateOutputType | null;
    _avg: AssessmentsAvgAggregateOutputType | null;
    _sum: AssessmentsSumAggregateOutputType | null;
    _min: AssessmentsMinAggregateOutputType | null;
    _max: AssessmentsMaxAggregateOutputType | null;
  };

  export type AssessmentsAvgAggregateOutputType = {
    id: number | null;
  };

  export type AssessmentsSumAggregateOutputType = {
    id: number | null;
  };

  export type AssessmentsMinAggregateOutputType = {
    id: number | null;
    instructions: string | null;
    start_date: Date | null;
    end_date: Date | null;
    schedule_later: boolean | null;
    start_time: Date | null;
    end_time: Date | null;
    any_time: boolean | null;
    team: string | null;
  };

  export type AssessmentsMaxAggregateOutputType = {
    id: number | null;
    instructions: string | null;
    start_date: Date | null;
    end_date: Date | null;
    schedule_later: boolean | null;
    start_time: Date | null;
    end_time: Date | null;
    any_time: boolean | null;
    team: string | null;
  };

  export type AssessmentsCountAggregateOutputType = {
    id: number;
    instructions: number;
    start_date: number;
    end_date: number;
    schedule_later: number;
    start_time: number;
    end_time: number;
    any_time: number;
    team: number;
    _all: number;
  };

  export type AssessmentsAvgAggregateInputType = {
    id?: true;
  };

  export type AssessmentsSumAggregateInputType = {
    id?: true;
  };

  export type AssessmentsMinAggregateInputType = {
    id?: true;
    instructions?: true;
    start_date?: true;
    end_date?: true;
    schedule_later?: true;
    start_time?: true;
    end_time?: true;
    any_time?: true;
    team?: true;
  };

  export type AssessmentsMaxAggregateInputType = {
    id?: true;
    instructions?: true;
    start_date?: true;
    end_date?: true;
    schedule_later?: true;
    start_time?: true;
    end_time?: true;
    any_time?: true;
    team?: true;
  };

  export type AssessmentsCountAggregateInputType = {
    id?: true;
    instructions?: true;
    start_date?: true;
    end_date?: true;
    schedule_later?: true;
    start_time?: true;
    end_time?: true;
    any_time?: true;
    team?: true;
    _all?: true;
  };

  export type AssessmentsAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which Assessments to aggregate.
     */
    where?: AssessmentsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Assessments to fetch.
     */
    orderBy?:
      | AssessmentsOrderByWithRelationInput
      | AssessmentsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: AssessmentsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Assessments from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Assessments.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Assessments
     **/
    _count?: true | AssessmentsCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: AssessmentsAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: AssessmentsSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: AssessmentsMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: AssessmentsMaxAggregateInputType;
  };

  export type GetAssessmentsAggregateType<T extends AssessmentsAggregateArgs> =
    {
      [P in keyof T & keyof AggregateAssessments]: P extends "_count" | "count"
        ? T[P] extends true
          ? number
          : GetScalarType<T[P], AggregateAssessments[P]>
        : GetScalarType<T[P], AggregateAssessments[P]>;
    };

  export type AssessmentsGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: AssessmentsWhereInput;
    orderBy?:
      | AssessmentsOrderByWithAggregationInput
      | AssessmentsOrderByWithAggregationInput[];
    by: AssessmentsScalarFieldEnum[] | AssessmentsScalarFieldEnum;
    having?: AssessmentsScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: AssessmentsCountAggregateInputType | true;
    _avg?: AssessmentsAvgAggregateInputType;
    _sum?: AssessmentsSumAggregateInputType;
    _min?: AssessmentsMinAggregateInputType;
    _max?: AssessmentsMaxAggregateInputType;
  };

  export type AssessmentsGroupByOutputType = {
    id: number;
    instructions: string | null;
    start_date: Date | null;
    end_date: Date | null;
    schedule_later: boolean;
    start_time: Date | null;
    end_time: Date | null;
    any_time: boolean;
    team: string | null;
    _count: AssessmentsCountAggregateOutputType | null;
    _avg: AssessmentsAvgAggregateOutputType | null;
    _sum: AssessmentsSumAggregateOutputType | null;
    _min: AssessmentsMinAggregateOutputType | null;
    _max: AssessmentsMaxAggregateOutputType | null;
  };

  type GetAssessmentsGroupByPayload<T extends AssessmentsGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<AssessmentsGroupByOutputType, T["by"]> & {
          [P in keyof T &
            keyof AssessmentsGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AssessmentsGroupByOutputType[P]>
            : GetScalarType<T[P], AssessmentsGroupByOutputType[P]>;
        }
      >
    >;

  export type AssessmentsSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      instructions?: boolean;
      start_date?: boolean;
      end_date?: boolean;
      schedule_later?: boolean;
      start_time?: boolean;
      end_time?: boolean;
      any_time?: boolean;
      team?: boolean;
      requests?: boolean | Assessments$requestsArgs<ExtArgs>;
      _count?: boolean | AssessmentsCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["assessments"]
  >;

  export type AssessmentsSelectScalar = {
    id?: boolean;
    instructions?: boolean;
    start_date?: boolean;
    end_date?: boolean;
    schedule_later?: boolean;
    start_time?: boolean;
    end_time?: boolean;
    any_time?: boolean;
    team?: boolean;
  };

  export type AssessmentsInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    requests?: boolean | Assessments$requestsArgs<ExtArgs>;
    _count?: boolean | AssessmentsCountOutputTypeDefaultArgs<ExtArgs>;
  };

  export type $AssessmentsPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: "Assessments";
    objects: {
      requests: Prisma.$RequestsPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: number;
        instructions: string | null;
        start_date: Date | null;
        end_date: Date | null;
        schedule_later: boolean;
        start_time: Date | null;
        end_time: Date | null;
        any_time: boolean;
        team: string | null;
      },
      ExtArgs["result"]["assessments"]
    >;
    composites: {};
  };

  type AssessmentsGetPayload<
    S extends boolean | null | undefined | AssessmentsDefaultArgs
  > = $Result.GetResult<Prisma.$AssessmentsPayload, S>;

  type AssessmentsCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<AssessmentsFindManyArgs, "select" | "include" | "distinct"> & {
    select?: AssessmentsCountAggregateInputType | true;
  };

  export interface AssessmentsDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["Assessments"];
      meta: { name: "Assessments" };
    };
    /**
     * Find zero or one Assessments that matches the filter.
     * @param {AssessmentsFindUniqueArgs} args - Arguments to find a Assessments
     * @example
     * // Get one Assessments
     * const assessments = await prisma.assessments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     **/
    findUnique<T extends AssessmentsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AssessmentsFindUniqueArgs<ExtArgs>>
    ): Prisma__AssessmentsClient<
      $Result.GetResult<
        Prisma.$AssessmentsPayload<ExtArgs>,
        T,
        "findUnique"
      > | null,
      null,
      ExtArgs
    >;

    /**
     * Find one Assessments that matches the filter or throw an error  with `error.code='P2025'`
     *     if no matches were found.
     * @param {AssessmentsFindUniqueOrThrowArgs} args - Arguments to find a Assessments
     * @example
     * // Get one Assessments
     * const assessments = await prisma.assessments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     **/
    findUniqueOrThrow<T extends AssessmentsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AssessmentsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AssessmentsClient<
      $Result.GetResult<
        Prisma.$AssessmentsPayload<ExtArgs>,
        T,
        "findUniqueOrThrow"
      >,
      never,
      ExtArgs
    >;

    /**
     * Find the first Assessments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentsFindFirstArgs} args - Arguments to find a Assessments
     * @example
     * // Get one Assessments
     * const assessments = await prisma.assessments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     **/
    findFirst<T extends AssessmentsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AssessmentsFindFirstArgs<ExtArgs>>
    ): Prisma__AssessmentsClient<
      $Result.GetResult<
        Prisma.$AssessmentsPayload<ExtArgs>,
        T,
        "findFirst"
      > | null,
      null,
      ExtArgs
    >;

    /**
     * Find the first Assessments that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentsFindFirstOrThrowArgs} args - Arguments to find a Assessments
     * @example
     * // Get one Assessments
     * const assessments = await prisma.assessments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     **/
    findFirstOrThrow<T extends AssessmentsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AssessmentsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AssessmentsClient<
      $Result.GetResult<
        Prisma.$AssessmentsPayload<ExtArgs>,
        T,
        "findFirstOrThrow"
      >,
      never,
      ExtArgs
    >;

    /**
     * Find zero or more Assessments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Assessments
     * const assessments = await prisma.assessments.findMany()
     *
     * // Get first 10 Assessments
     * const assessments = await prisma.assessments.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const assessmentsWithIdOnly = await prisma.assessments.findMany({ select: { id: true } })
     *
     **/
    findMany<T extends AssessmentsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AssessmentsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$AssessmentsPayload<ExtArgs>, T, "findMany">
    >;

    /**
     * Create a Assessments.
     * @param {AssessmentsCreateArgs} args - Arguments to create a Assessments.
     * @example
     * // Create one Assessments
     * const Assessments = await prisma.assessments.create({
     *   data: {
     *     // ... data to create a Assessments
     *   }
     * })
     *
     **/
    create<T extends AssessmentsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AssessmentsCreateArgs<ExtArgs>>
    ): Prisma__AssessmentsClient<
      $Result.GetResult<Prisma.$AssessmentsPayload<ExtArgs>, T, "create">,
      never,
      ExtArgs
    >;

    /**
     * Create many Assessments.
     *     @param {AssessmentsCreateManyArgs} args - Arguments to create many Assessments.
     *     @example
     *     // Create many Assessments
     *     const assessments = await prisma.assessments.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *
     **/
    createMany<T extends AssessmentsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AssessmentsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a Assessments.
     * @param {AssessmentsDeleteArgs} args - Arguments to delete one Assessments.
     * @example
     * // Delete one Assessments
     * const Assessments = await prisma.assessments.delete({
     *   where: {
     *     // ... filter to delete one Assessments
     *   }
     * })
     *
     **/
    delete<T extends AssessmentsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AssessmentsDeleteArgs<ExtArgs>>
    ): Prisma__AssessmentsClient<
      $Result.GetResult<Prisma.$AssessmentsPayload<ExtArgs>, T, "delete">,
      never,
      ExtArgs
    >;

    /**
     * Update one Assessments.
     * @param {AssessmentsUpdateArgs} args - Arguments to update one Assessments.
     * @example
     * // Update one Assessments
     * const assessments = await prisma.assessments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     **/
    update<T extends AssessmentsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AssessmentsUpdateArgs<ExtArgs>>
    ): Prisma__AssessmentsClient<
      $Result.GetResult<Prisma.$AssessmentsPayload<ExtArgs>, T, "update">,
      never,
      ExtArgs
    >;

    /**
     * Delete zero or more Assessments.
     * @param {AssessmentsDeleteManyArgs} args - Arguments to filter Assessments to delete.
     * @example
     * // Delete a few Assessments
     * const { count } = await prisma.assessments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     **/
    deleteMany<T extends AssessmentsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AssessmentsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Assessments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Assessments
     * const assessments = await prisma.assessments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     **/
    updateMany<T extends AssessmentsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AssessmentsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one Assessments.
     * @param {AssessmentsUpsertArgs} args - Arguments to update or create a Assessments.
     * @example
     * // Update or create a Assessments
     * const assessments = await prisma.assessments.upsert({
     *   create: {
     *     // ... data to create a Assessments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Assessments we want to update
     *   }
     * })
     **/
    upsert<T extends AssessmentsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AssessmentsUpsertArgs<ExtArgs>>
    ): Prisma__AssessmentsClient<
      $Result.GetResult<Prisma.$AssessmentsPayload<ExtArgs>, T, "upsert">,
      never,
      ExtArgs
    >;

    /**
     * Count the number of Assessments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentsCountArgs} args - Arguments to filter Assessments to count.
     * @example
     * // Count the number of Assessments
     * const count = await prisma.assessments.count({
     *   where: {
     *     // ... the filter for the Assessments we want to count
     *   }
     * })
     **/
    count<T extends AssessmentsCountArgs>(
      args?: Subset<T, AssessmentsCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], AssessmentsCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Assessments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends AssessmentsAggregateArgs>(
      args: Subset<T, AssessmentsAggregateArgs>
    ): Prisma.PrismaPromise<GetAssessmentsAggregateType<T>>;

    /**
     * Group by Assessments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends AssessmentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AssessmentsGroupByArgs["orderBy"] }
        : { orderBy?: AssessmentsGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
        ? {
            [P in HavingFields]: P extends ByFields
              ? never
              : P extends string
              ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
              : [
                  Error,
                  "Field ",
                  P,
                  ` in "having" needs to be provided in "by"`
                ];
          }[HavingFields]
        : "take" extends Keys<T>
        ? "orderBy" extends Keys<T>
          ? ByValid extends True
            ? {}
            : {
                [P in OrderFields]: P extends ByFields
                  ? never
                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
              }[OrderFields]
          : 'Error: If you provide "take", you also need to provide "orderBy"'
        : "skip" extends Keys<T>
        ? "orderBy" extends Keys<T>
          ? ByValid extends True
            ? {}
            : {
                [P in OrderFields]: P extends ByFields
                  ? never
                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
              }[OrderFields]
          : 'Error: If you provide "skip", you also need to provide "orderBy"'
        : ByValid extends True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
          }[OrderFields]
    >(
      args: SubsetIntersection<T, AssessmentsGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetAssessmentsGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Assessments model
     */
    readonly fields: AssessmentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Assessments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AssessmentsClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";

    requests<T extends Assessments$requestsArgs<ExtArgs> = {}>(
      args?: Subset<T, Assessments$requestsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$RequestsPayload<ExtArgs>, T, "findMany"> | Null
    >;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Assessments model
   */
  interface AssessmentsFieldRefs {
    readonly id: FieldRef<"Assessments", "Int">;
    readonly instructions: FieldRef<"Assessments", "String">;
    readonly start_date: FieldRef<"Assessments", "DateTime">;
    readonly end_date: FieldRef<"Assessments", "DateTime">;
    readonly schedule_later: FieldRef<"Assessments", "Boolean">;
    readonly start_time: FieldRef<"Assessments", "DateTime">;
    readonly end_time: FieldRef<"Assessments", "DateTime">;
    readonly any_time: FieldRef<"Assessments", "Boolean">;
    readonly team: FieldRef<"Assessments", "String">;
  }

  // Custom InputTypes

  /**
   * Assessments findUnique
   */
  export type AssessmentsFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Assessments
     */
    select?: AssessmentsSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AssessmentsInclude<ExtArgs> | null;
    /**
     * Filter, which Assessments to fetch.
     */
    where: AssessmentsWhereUniqueInput;
  };

  /**
   * Assessments findUniqueOrThrow
   */
  export type AssessmentsFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Assessments
     */
    select?: AssessmentsSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AssessmentsInclude<ExtArgs> | null;
    /**
     * Filter, which Assessments to fetch.
     */
    where: AssessmentsWhereUniqueInput;
  };

  /**
   * Assessments findFirst
   */
  export type AssessmentsFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Assessments
     */
    select?: AssessmentsSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AssessmentsInclude<ExtArgs> | null;
    /**
     * Filter, which Assessments to fetch.
     */
    where?: AssessmentsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Assessments to fetch.
     */
    orderBy?:
      | AssessmentsOrderByWithRelationInput
      | AssessmentsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Assessments.
     */
    cursor?: AssessmentsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Assessments from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Assessments.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Assessments.
     */
    distinct?: AssessmentsScalarFieldEnum | AssessmentsScalarFieldEnum[];
  };

  /**
   * Assessments findFirstOrThrow
   */
  export type AssessmentsFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Assessments
     */
    select?: AssessmentsSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AssessmentsInclude<ExtArgs> | null;
    /**
     * Filter, which Assessments to fetch.
     */
    where?: AssessmentsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Assessments to fetch.
     */
    orderBy?:
      | AssessmentsOrderByWithRelationInput
      | AssessmentsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Assessments.
     */
    cursor?: AssessmentsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Assessments from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Assessments.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Assessments.
     */
    distinct?: AssessmentsScalarFieldEnum | AssessmentsScalarFieldEnum[];
  };

  /**
   * Assessments findMany
   */
  export type AssessmentsFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Assessments
     */
    select?: AssessmentsSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AssessmentsInclude<ExtArgs> | null;
    /**
     * Filter, which Assessments to fetch.
     */
    where?: AssessmentsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Assessments to fetch.
     */
    orderBy?:
      | AssessmentsOrderByWithRelationInput
      | AssessmentsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Assessments.
     */
    cursor?: AssessmentsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Assessments from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Assessments.
     */
    skip?: number;
    distinct?: AssessmentsScalarFieldEnum | AssessmentsScalarFieldEnum[];
  };

  /**
   * Assessments create
   */
  export type AssessmentsCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Assessments
     */
    select?: AssessmentsSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AssessmentsInclude<ExtArgs> | null;
    /**
     * The data needed to create a Assessments.
     */
    data?: XOR<AssessmentsCreateInput, AssessmentsUncheckedCreateInput>;
  };

  /**
   * Assessments createMany
   */
  export type AssessmentsCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many Assessments.
     */
    data: AssessmentsCreateManyInput | AssessmentsCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Assessments update
   */
  export type AssessmentsUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Assessments
     */
    select?: AssessmentsSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AssessmentsInclude<ExtArgs> | null;
    /**
     * The data needed to update a Assessments.
     */
    data: XOR<AssessmentsUpdateInput, AssessmentsUncheckedUpdateInput>;
    /**
     * Choose, which Assessments to update.
     */
    where: AssessmentsWhereUniqueInput;
  };

  /**
   * Assessments updateMany
   */
  export type AssessmentsUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update Assessments.
     */
    data: XOR<
      AssessmentsUpdateManyMutationInput,
      AssessmentsUncheckedUpdateManyInput
    >;
    /**
     * Filter which Assessments to update
     */
    where?: AssessmentsWhereInput;
  };

  /**
   * Assessments upsert
   */
  export type AssessmentsUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Assessments
     */
    select?: AssessmentsSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AssessmentsInclude<ExtArgs> | null;
    /**
     * The filter to search for the Assessments to update in case it exists.
     */
    where: AssessmentsWhereUniqueInput;
    /**
     * In case the Assessments found by the `where` argument doesn't exist, create a new Assessments with this data.
     */
    create: XOR<AssessmentsCreateInput, AssessmentsUncheckedCreateInput>;
    /**
     * In case the Assessments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AssessmentsUpdateInput, AssessmentsUncheckedUpdateInput>;
  };

  /**
   * Assessments delete
   */
  export type AssessmentsDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Assessments
     */
    select?: AssessmentsSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AssessmentsInclude<ExtArgs> | null;
    /**
     * Filter which Assessments to delete.
     */
    where: AssessmentsWhereUniqueInput;
  };

  /**
   * Assessments deleteMany
   */
  export type AssessmentsDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which Assessments to delete
     */
    where?: AssessmentsWhereInput;
  };

  /**
   * Assessments.requests
   */
  export type Assessments$requestsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Requests
     */
    select?: RequestsSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RequestsInclude<ExtArgs> | null;
    where?: RequestsWhereInput;
    orderBy?:
      | RequestsOrderByWithRelationInput
      | RequestsOrderByWithRelationInput[];
    cursor?: RequestsWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: RequestsScalarFieldEnum | RequestsScalarFieldEnum[];
  };

  /**
   * Assessments without action
   */
  export type AssessmentsDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Assessments
     */
    select?: AssessmentsSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AssessmentsInclude<ExtArgs> | null;
  };

  /**
   * Model Requests
   */

  export type AggregateRequests = {
    _count: RequestsCountAggregateOutputType | null;
    _avg: RequestsAvgAggregateOutputType | null;
    _sum: RequestsSumAggregateOutputType | null;
    _min: RequestsMinAggregateOutputType | null;
    _max: RequestsMaxAggregateOutputType | null;
  };

  export type RequestsAvgAggregateOutputType = {
    id: number | null;
    client_id: number | null;
    assessment_id: number | null;
    belongs_to_id: number | null;
  };

  export type RequestsSumAggregateOutputType = {
    id: number | null;
    client_id: number | null;
    assessment_id: number | null;
    belongs_to_id: number | null;
  };

  export type RequestsMinAggregateOutputType = {
    id: number | null;
    status: string | null;
    emailed_to_client: boolean | null;
    texted_to_client: boolean | null;
    title: string | null;
    service_details: string | null;
    assessment_date: Date | null;
    backup_assessment__date: Date | null;
    preferred_arrival_times: string | null;
    on_site_assesment_required: boolean | null;
    client_id: number | null;
    assessment_id: number | null;
    internal_notes: string | null;
    internalAttachmentUrl: string | null;
    link_to_releated_quotes: boolean | null;
    link_to_releated_jobs: boolean | null;
    link_to_releated_invoices: boolean | null;
    belongs_to_id: number | null;
  };

  export type RequestsMaxAggregateOutputType = {
    id: number | null;
    status: string | null;
    emailed_to_client: boolean | null;
    texted_to_client: boolean | null;
    title: string | null;
    service_details: string | null;
    assessment_date: Date | null;
    backup_assessment__date: Date | null;
    preferred_arrival_times: string | null;
    on_site_assesment_required: boolean | null;
    client_id: number | null;
    assessment_id: number | null;
    internal_notes: string | null;
    internalAttachmentUrl: string | null;
    link_to_releated_quotes: boolean | null;
    link_to_releated_jobs: boolean | null;
    link_to_releated_invoices: boolean | null;
    belongs_to_id: number | null;
  };

  export type RequestsCountAggregateOutputType = {
    id: number;
    status: number;
    tags: number;
    emailed_to_client: number;
    texted_to_client: number;
    title: number;
    service_details: number;
    assessment_date: number;
    backup_assessment__date: number;
    preferred_arrival_times: number;
    on_site_assesment_required: number;
    client_id: number;
    assessment_id: number;
    internal_notes: number;
    internalAttachmentUrl: number;
    link_to_releated_quotes: number;
    link_to_releated_jobs: number;
    link_to_releated_invoices: number;
    belongs_to_id: number;
    _all: number;
  };

  export type RequestsAvgAggregateInputType = {
    id?: true;
    client_id?: true;
    assessment_id?: true;
    belongs_to_id?: true;
  };

  export type RequestsSumAggregateInputType = {
    id?: true;
    client_id?: true;
    assessment_id?: true;
    belongs_to_id?: true;
  };

  export type RequestsMinAggregateInputType = {
    id?: true;
    status?: true;
    emailed_to_client?: true;
    texted_to_client?: true;
    title?: true;
    service_details?: true;
    assessment_date?: true;
    backup_assessment__date?: true;
    preferred_arrival_times?: true;
    on_site_assesment_required?: true;
    client_id?: true;
    assessment_id?: true;
    internal_notes?: true;
    internalAttachmentUrl?: true;
    link_to_releated_quotes?: true;
    link_to_releated_jobs?: true;
    link_to_releated_invoices?: true;
    belongs_to_id?: true;
  };

  export type RequestsMaxAggregateInputType = {
    id?: true;
    status?: true;
    emailed_to_client?: true;
    texted_to_client?: true;
    title?: true;
    service_details?: true;
    assessment_date?: true;
    backup_assessment__date?: true;
    preferred_arrival_times?: true;
    on_site_assesment_required?: true;
    client_id?: true;
    assessment_id?: true;
    internal_notes?: true;
    internalAttachmentUrl?: true;
    link_to_releated_quotes?: true;
    link_to_releated_jobs?: true;
    link_to_releated_invoices?: true;
    belongs_to_id?: true;
  };

  export type RequestsCountAggregateInputType = {
    id?: true;
    status?: true;
    tags?: true;
    emailed_to_client?: true;
    texted_to_client?: true;
    title?: true;
    service_details?: true;
    assessment_date?: true;
    backup_assessment__date?: true;
    preferred_arrival_times?: true;
    on_site_assesment_required?: true;
    client_id?: true;
    assessment_id?: true;
    internal_notes?: true;
    internalAttachmentUrl?: true;
    link_to_releated_quotes?: true;
    link_to_releated_jobs?: true;
    link_to_releated_invoices?: true;
    belongs_to_id?: true;
    _all?: true;
  };

  export type RequestsAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which Requests to aggregate.
     */
    where?: RequestsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Requests to fetch.
     */
    orderBy?:
      | RequestsOrderByWithRelationInput
      | RequestsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: RequestsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Requests from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Requests.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Requests
     **/
    _count?: true | RequestsCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: RequestsAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: RequestsSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: RequestsMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: RequestsMaxAggregateInputType;
  };

  export type GetRequestsAggregateType<T extends RequestsAggregateArgs> = {
    [P in keyof T & keyof AggregateRequests]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRequests[P]>
      : GetScalarType<T[P], AggregateRequests[P]>;
  };

  export type RequestsGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: RequestsWhereInput;
    orderBy?:
      | RequestsOrderByWithAggregationInput
      | RequestsOrderByWithAggregationInput[];
    by: RequestsScalarFieldEnum[] | RequestsScalarFieldEnum;
    having?: RequestsScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: RequestsCountAggregateInputType | true;
    _avg?: RequestsAvgAggregateInputType;
    _sum?: RequestsSumAggregateInputType;
    _min?: RequestsMinAggregateInputType;
    _max?: RequestsMaxAggregateInputType;
  };

  export type RequestsGroupByOutputType = {
    id: number;
    status: string;
    tags: JsonValue | null;
    emailed_to_client: boolean;
    texted_to_client: boolean;
    title: string;
    service_details: string;
    assessment_date: Date;
    backup_assessment__date: Date | null;
    preferred_arrival_times: string | null;
    on_site_assesment_required: boolean;
    client_id: number;
    assessment_id: number;
    internal_notes: string;
    internalAttachmentUrl: string;
    link_to_releated_quotes: boolean;
    link_to_releated_jobs: boolean;
    link_to_releated_invoices: boolean;
    belongs_to_id: number;
    _count: RequestsCountAggregateOutputType | null;
    _avg: RequestsAvgAggregateOutputType | null;
    _sum: RequestsSumAggregateOutputType | null;
    _min: RequestsMinAggregateOutputType | null;
    _max: RequestsMaxAggregateOutputType | null;
  };

  type GetRequestsGroupByPayload<T extends RequestsGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<RequestsGroupByOutputType, T["by"]> & {
          [P in keyof T & keyof RequestsGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RequestsGroupByOutputType[P]>
            : GetScalarType<T[P], RequestsGroupByOutputType[P]>;
        }
      >
    >;

  export type RequestsSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      status?: boolean;
      tags?: boolean;
      emailed_to_client?: boolean;
      texted_to_client?: boolean;
      title?: boolean;
      service_details?: boolean;
      assessment_date?: boolean;
      backup_assessment__date?: boolean;
      preferred_arrival_times?: boolean;
      on_site_assesment_required?: boolean;
      client_id?: boolean;
      assessment_id?: boolean;
      internal_notes?: boolean;
      internalAttachmentUrl?: boolean;
      link_to_releated_quotes?: boolean;
      link_to_releated_jobs?: boolean;
      link_to_releated_invoices?: boolean;
      belongs_to_id?: boolean;
      assessment?: boolean | AssessmentsDefaultArgs<ExtArgs>;
      client?: boolean | ClientsDefaultArgs<ExtArgs>;
      quotes?: boolean | Requests$quotesArgs<ExtArgs>;
      job_requests?: boolean | Requests$job_requestsArgs<ExtArgs>;
      belongs_to?: boolean | UsersDefaultArgs<ExtArgs>;
      _count?: boolean | RequestsCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["requests"]
  >;

  export type RequestsSelectScalar = {
    id?: boolean;
    status?: boolean;
    tags?: boolean;
    emailed_to_client?: boolean;
    texted_to_client?: boolean;
    title?: boolean;
    service_details?: boolean;
    assessment_date?: boolean;
    backup_assessment__date?: boolean;
    preferred_arrival_times?: boolean;
    on_site_assesment_required?: boolean;
    client_id?: boolean;
    assessment_id?: boolean;
    internal_notes?: boolean;
    internalAttachmentUrl?: boolean;
    link_to_releated_quotes?: boolean;
    link_to_releated_jobs?: boolean;
    link_to_releated_invoices?: boolean;
    belongs_to_id?: boolean;
  };

  export type RequestsInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    assessment?: boolean | AssessmentsDefaultArgs<ExtArgs>;
    client?: boolean | ClientsDefaultArgs<ExtArgs>;
    quotes?: boolean | Requests$quotesArgs<ExtArgs>;
    job_requests?: boolean | Requests$job_requestsArgs<ExtArgs>;
    belongs_to?: boolean | UsersDefaultArgs<ExtArgs>;
    _count?: boolean | RequestsCountOutputTypeDefaultArgs<ExtArgs>;
  };

  export type $RequestsPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: "Requests";
    objects: {
      assessment: Prisma.$AssessmentsPayload<ExtArgs>;
      client: Prisma.$ClientsPayload<ExtArgs>;
      quotes: Prisma.$QuoteRequestPayload<ExtArgs>[];
      job_requests: Prisma.$JobRequestPayload<ExtArgs>[];
      belongs_to: Prisma.$UsersPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: number;
        status: string;
        tags: Prisma.JsonValue | null;
        emailed_to_client: boolean;
        texted_to_client: boolean;
        title: string;
        service_details: string;
        assessment_date: Date;
        backup_assessment__date: Date | null;
        preferred_arrival_times: string | null;
        on_site_assesment_required: boolean;
        client_id: number;
        assessment_id: number;
        internal_notes: string;
        internalAttachmentUrl: string;
        link_to_releated_quotes: boolean;
        link_to_releated_jobs: boolean;
        link_to_releated_invoices: boolean;
        belongs_to_id: number;
      },
      ExtArgs["result"]["requests"]
    >;
    composites: {};
  };

  type RequestsGetPayload<
    S extends boolean | null | undefined | RequestsDefaultArgs
  > = $Result.GetResult<Prisma.$RequestsPayload, S>;

  type RequestsCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<RequestsFindManyArgs, "select" | "include" | "distinct"> & {
    select?: RequestsCountAggregateInputType | true;
  };

  export interface RequestsDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["Requests"];
      meta: { name: "Requests" };
    };
    /**
     * Find zero or one Requests that matches the filter.
     * @param {RequestsFindUniqueArgs} args - Arguments to find a Requests
     * @example
     * // Get one Requests
     * const requests = await prisma.requests.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     **/
    findUnique<T extends RequestsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, RequestsFindUniqueArgs<ExtArgs>>
    ): Prisma__RequestsClient<
      $Result.GetResult<
        Prisma.$RequestsPayload<ExtArgs>,
        T,
        "findUnique"
      > | null,
      null,
      ExtArgs
    >;

    /**
     * Find one Requests that matches the filter or throw an error  with `error.code='P2025'`
     *     if no matches were found.
     * @param {RequestsFindUniqueOrThrowArgs} args - Arguments to find a Requests
     * @example
     * // Get one Requests
     * const requests = await prisma.requests.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     **/
    findUniqueOrThrow<T extends RequestsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RequestsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__RequestsClient<
      $Result.GetResult<
        Prisma.$RequestsPayload<ExtArgs>,
        T,
        "findUniqueOrThrow"
      >,
      never,
      ExtArgs
    >;

    /**
     * Find the first Requests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestsFindFirstArgs} args - Arguments to find a Requests
     * @example
     * // Get one Requests
     * const requests = await prisma.requests.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     **/
    findFirst<T extends RequestsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, RequestsFindFirstArgs<ExtArgs>>
    ): Prisma__RequestsClient<
      $Result.GetResult<
        Prisma.$RequestsPayload<ExtArgs>,
        T,
        "findFirst"
      > | null,
      null,
      ExtArgs
    >;

    /**
     * Find the first Requests that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestsFindFirstOrThrowArgs} args - Arguments to find a Requests
     * @example
     * // Get one Requests
     * const requests = await prisma.requests.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     **/
    findFirstOrThrow<T extends RequestsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RequestsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__RequestsClient<
      $Result.GetResult<
        Prisma.$RequestsPayload<ExtArgs>,
        T,
        "findFirstOrThrow"
      >,
      never,
      ExtArgs
    >;

    /**
     * Find zero or more Requests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Requests
     * const requests = await prisma.requests.findMany()
     *
     * // Get first 10 Requests
     * const requests = await prisma.requests.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const requestsWithIdOnly = await prisma.requests.findMany({ select: { id: true } })
     *
     **/
    findMany<T extends RequestsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RequestsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$RequestsPayload<ExtArgs>, T, "findMany">
    >;

    /**
     * Create a Requests.
     * @param {RequestsCreateArgs} args - Arguments to create a Requests.
     * @example
     * // Create one Requests
     * const Requests = await prisma.requests.create({
     *   data: {
     *     // ... data to create a Requests
     *   }
     * })
     *
     **/
    create<T extends RequestsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, RequestsCreateArgs<ExtArgs>>
    ): Prisma__RequestsClient<
      $Result.GetResult<Prisma.$RequestsPayload<ExtArgs>, T, "create">,
      never,
      ExtArgs
    >;

    /**
     * Create many Requests.
     *     @param {RequestsCreateManyArgs} args - Arguments to create many Requests.
     *     @example
     *     // Create many Requests
     *     const requests = await prisma.requests.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *
     **/
    createMany<T extends RequestsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RequestsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a Requests.
     * @param {RequestsDeleteArgs} args - Arguments to delete one Requests.
     * @example
     * // Delete one Requests
     * const Requests = await prisma.requests.delete({
     *   where: {
     *     // ... filter to delete one Requests
     *   }
     * })
     *
     **/
    delete<T extends RequestsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, RequestsDeleteArgs<ExtArgs>>
    ): Prisma__RequestsClient<
      $Result.GetResult<Prisma.$RequestsPayload<ExtArgs>, T, "delete">,
      never,
      ExtArgs
    >;

    /**
     * Update one Requests.
     * @param {RequestsUpdateArgs} args - Arguments to update one Requests.
     * @example
     * // Update one Requests
     * const requests = await prisma.requests.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     **/
    update<T extends RequestsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, RequestsUpdateArgs<ExtArgs>>
    ): Prisma__RequestsClient<
      $Result.GetResult<Prisma.$RequestsPayload<ExtArgs>, T, "update">,
      never,
      ExtArgs
    >;

    /**
     * Delete zero or more Requests.
     * @param {RequestsDeleteManyArgs} args - Arguments to filter Requests to delete.
     * @example
     * // Delete a few Requests
     * const { count } = await prisma.requests.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     **/
    deleteMany<T extends RequestsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RequestsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Requests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Requests
     * const requests = await prisma.requests.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     **/
    updateMany<T extends RequestsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, RequestsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one Requests.
     * @param {RequestsUpsertArgs} args - Arguments to update or create a Requests.
     * @example
     * // Update or create a Requests
     * const requests = await prisma.requests.upsert({
     *   create: {
     *     // ... data to create a Requests
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Requests we want to update
     *   }
     * })
     **/
    upsert<T extends RequestsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, RequestsUpsertArgs<ExtArgs>>
    ): Prisma__RequestsClient<
      $Result.GetResult<Prisma.$RequestsPayload<ExtArgs>, T, "upsert">,
      never,
      ExtArgs
    >;

    /**
     * Count the number of Requests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestsCountArgs} args - Arguments to filter Requests to count.
     * @example
     * // Count the number of Requests
     * const count = await prisma.requests.count({
     *   where: {
     *     // ... the filter for the Requests we want to count
     *   }
     * })
     **/
    count<T extends RequestsCountArgs>(
      args?: Subset<T, RequestsCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], RequestsCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Requests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends RequestsAggregateArgs>(
      args: Subset<T, RequestsAggregateArgs>
    ): Prisma.PrismaPromise<GetRequestsAggregateType<T>>;

    /**
     * Group by Requests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends RequestsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RequestsGroupByArgs["orderBy"] }
        : { orderBy?: RequestsGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
        ? {
            [P in HavingFields]: P extends ByFields
              ? never
              : P extends string
              ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
              : [
                  Error,
                  "Field ",
                  P,
                  ` in "having" needs to be provided in "by"`
                ];
          }[HavingFields]
        : "take" extends Keys<T>
        ? "orderBy" extends Keys<T>
          ? ByValid extends True
            ? {}
            : {
                [P in OrderFields]: P extends ByFields
                  ? never
                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
              }[OrderFields]
          : 'Error: If you provide "take", you also need to provide "orderBy"'
        : "skip" extends Keys<T>
        ? "orderBy" extends Keys<T>
          ? ByValid extends True
            ? {}
            : {
                [P in OrderFields]: P extends ByFields
                  ? never
                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
              }[OrderFields]
          : 'Error: If you provide "skip", you also need to provide "orderBy"'
        : ByValid extends True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
          }[OrderFields]
    >(
      args: SubsetIntersection<T, RequestsGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetRequestsGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Requests model
     */
    readonly fields: RequestsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Requests.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RequestsClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";

    assessment<T extends AssessmentsDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, AssessmentsDefaultArgs<ExtArgs>>
    ): Prisma__AssessmentsClient<
      | $Result.GetResult<
          Prisma.$AssessmentsPayload<ExtArgs>,
          T,
          "findUniqueOrThrow"
        >
      | Null,
      Null,
      ExtArgs
    >;

    client<T extends ClientsDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, ClientsDefaultArgs<ExtArgs>>
    ): Prisma__ClientsClient<
      | $Result.GetResult<
          Prisma.$ClientsPayload<ExtArgs>,
          T,
          "findUniqueOrThrow"
        >
      | Null,
      Null,
      ExtArgs
    >;

    quotes<T extends Requests$quotesArgs<ExtArgs> = {}>(
      args?: Subset<T, Requests$quotesArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<Prisma.$QuoteRequestPayload<ExtArgs>, T, "findMany">
      | Null
    >;

    job_requests<T extends Requests$job_requestsArgs<ExtArgs> = {}>(
      args?: Subset<T, Requests$job_requestsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<Prisma.$JobRequestPayload<ExtArgs>, T, "findMany">
      | Null
    >;

    belongs_to<T extends UsersDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UsersDefaultArgs<ExtArgs>>
    ): Prisma__UsersClient<
      | $Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow">
      | Null,
      Null,
      ExtArgs
    >;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Requests model
   */
  interface RequestsFieldRefs {
    readonly id: FieldRef<"Requests", "Int">;
    readonly status: FieldRef<"Requests", "String">;
    readonly tags: FieldRef<"Requests", "Json">;
    readonly emailed_to_client: FieldRef<"Requests", "Boolean">;
    readonly texted_to_client: FieldRef<"Requests", "Boolean">;
    readonly title: FieldRef<"Requests", "String">;
    readonly service_details: FieldRef<"Requests", "String">;
    readonly assessment_date: FieldRef<"Requests", "DateTime">;
    readonly backup_assessment__date: FieldRef<"Requests", "DateTime">;
    readonly preferred_arrival_times: FieldRef<"Requests", "String">;
    readonly on_site_assesment_required: FieldRef<"Requests", "Boolean">;
    readonly client_id: FieldRef<"Requests", "Int">;
    readonly assessment_id: FieldRef<"Requests", "Int">;
    readonly internal_notes: FieldRef<"Requests", "String">;
    readonly internalAttachmentUrl: FieldRef<"Requests", "String">;
    readonly link_to_releated_quotes: FieldRef<"Requests", "Boolean">;
    readonly link_to_releated_jobs: FieldRef<"Requests", "Boolean">;
    readonly link_to_releated_invoices: FieldRef<"Requests", "Boolean">;
    readonly belongs_to_id: FieldRef<"Requests", "Int">;
  }

  // Custom InputTypes

  /**
   * Requests findUnique
   */
  export type RequestsFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Requests
     */
    select?: RequestsSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RequestsInclude<ExtArgs> | null;
    /**
     * Filter, which Requests to fetch.
     */
    where: RequestsWhereUniqueInput;
  };

  /**
   * Requests findUniqueOrThrow
   */
  export type RequestsFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Requests
     */
    select?: RequestsSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RequestsInclude<ExtArgs> | null;
    /**
     * Filter, which Requests to fetch.
     */
    where: RequestsWhereUniqueInput;
  };

  /**
   * Requests findFirst
   */
  export type RequestsFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Requests
     */
    select?: RequestsSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RequestsInclude<ExtArgs> | null;
    /**
     * Filter, which Requests to fetch.
     */
    where?: RequestsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Requests to fetch.
     */
    orderBy?:
      | RequestsOrderByWithRelationInput
      | RequestsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Requests.
     */
    cursor?: RequestsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Requests from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Requests.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Requests.
     */
    distinct?: RequestsScalarFieldEnum | RequestsScalarFieldEnum[];
  };

  /**
   * Requests findFirstOrThrow
   */
  export type RequestsFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Requests
     */
    select?: RequestsSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RequestsInclude<ExtArgs> | null;
    /**
     * Filter, which Requests to fetch.
     */
    where?: RequestsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Requests to fetch.
     */
    orderBy?:
      | RequestsOrderByWithRelationInput
      | RequestsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Requests.
     */
    cursor?: RequestsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Requests from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Requests.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Requests.
     */
    distinct?: RequestsScalarFieldEnum | RequestsScalarFieldEnum[];
  };

  /**
   * Requests findMany
   */
  export type RequestsFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Requests
     */
    select?: RequestsSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RequestsInclude<ExtArgs> | null;
    /**
     * Filter, which Requests to fetch.
     */
    where?: RequestsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Requests to fetch.
     */
    orderBy?:
      | RequestsOrderByWithRelationInput
      | RequestsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Requests.
     */
    cursor?: RequestsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Requests from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Requests.
     */
    skip?: number;
    distinct?: RequestsScalarFieldEnum | RequestsScalarFieldEnum[];
  };

  /**
   * Requests create
   */
  export type RequestsCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Requests
     */
    select?: RequestsSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RequestsInclude<ExtArgs> | null;
    /**
     * The data needed to create a Requests.
     */
    data: XOR<RequestsCreateInput, RequestsUncheckedCreateInput>;
  };

  /**
   * Requests createMany
   */
  export type RequestsCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many Requests.
     */
    data: RequestsCreateManyInput | RequestsCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Requests update
   */
  export type RequestsUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Requests
     */
    select?: RequestsSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RequestsInclude<ExtArgs> | null;
    /**
     * The data needed to update a Requests.
     */
    data: XOR<RequestsUpdateInput, RequestsUncheckedUpdateInput>;
    /**
     * Choose, which Requests to update.
     */
    where: RequestsWhereUniqueInput;
  };

  /**
   * Requests updateMany
   */
  export type RequestsUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update Requests.
     */
    data: XOR<
      RequestsUpdateManyMutationInput,
      RequestsUncheckedUpdateManyInput
    >;
    /**
     * Filter which Requests to update
     */
    where?: RequestsWhereInput;
  };

  /**
   * Requests upsert
   */
  export type RequestsUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Requests
     */
    select?: RequestsSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RequestsInclude<ExtArgs> | null;
    /**
     * The filter to search for the Requests to update in case it exists.
     */
    where: RequestsWhereUniqueInput;
    /**
     * In case the Requests found by the `where` argument doesn't exist, create a new Requests with this data.
     */
    create: XOR<RequestsCreateInput, RequestsUncheckedCreateInput>;
    /**
     * In case the Requests was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RequestsUpdateInput, RequestsUncheckedUpdateInput>;
  };

  /**
   * Requests delete
   */
  export type RequestsDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Requests
     */
    select?: RequestsSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RequestsInclude<ExtArgs> | null;
    /**
     * Filter which Requests to delete.
     */
    where: RequestsWhereUniqueInput;
  };

  /**
   * Requests deleteMany
   */
  export type RequestsDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which Requests to delete
     */
    where?: RequestsWhereInput;
  };

  /**
   * Requests.quotes
   */
  export type Requests$quotesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the QuoteRequest
     */
    select?: QuoteRequestSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuoteRequestInclude<ExtArgs> | null;
    where?: QuoteRequestWhereInput;
    orderBy?:
      | QuoteRequestOrderByWithRelationInput
      | QuoteRequestOrderByWithRelationInput[];
    cursor?: QuoteRequestWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: QuoteRequestScalarFieldEnum | QuoteRequestScalarFieldEnum[];
  };

  /**
   * Requests.job_requests
   */
  export type Requests$job_requestsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the JobRequest
     */
    select?: JobRequestSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobRequestInclude<ExtArgs> | null;
    where?: JobRequestWhereInput;
    orderBy?:
      | JobRequestOrderByWithRelationInput
      | JobRequestOrderByWithRelationInput[];
    cursor?: JobRequestWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: JobRequestScalarFieldEnum | JobRequestScalarFieldEnum[];
  };

  /**
   * Requests without action
   */
  export type RequestsDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Requests
     */
    select?: RequestsSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RequestsInclude<ExtArgs> | null;
  };

  /**
   * Model LineItems
   */

  export type AggregateLineItems = {
    _count: LineItemsCountAggregateOutputType | null;
    _avg: LineItemsAvgAggregateOutputType | null;
    _sum: LineItemsSumAggregateOutputType | null;
    _min: LineItemsMinAggregateOutputType | null;
    _max: LineItemsMaxAggregateOutputType | null;
  };

  export type LineItemsAvgAggregateOutputType = {
    id: number | null;
    quantity: number | null;
    unit_price: number | null;
    markup: number | null;
  };

  export type LineItemsSumAggregateOutputType = {
    id: number | null;
    quantity: number | null;
    unit_price: number | null;
    markup: number | null;
  };

  export type LineItemsMinAggregateOutputType = {
    id: number | null;
    type: string | null;
    name: string | null;
    description: string | null;
    quantity: number | null;
    unit_price: number | null;
    markup: number | null;
    img_url: string | null;
    recommend_item: boolean | null;
  };

  export type LineItemsMaxAggregateOutputType = {
    id: number | null;
    type: string | null;
    name: string | null;
    description: string | null;
    quantity: number | null;
    unit_price: number | null;
    markup: number | null;
    img_url: string | null;
    recommend_item: boolean | null;
  };

  export type LineItemsCountAggregateOutputType = {
    id: number;
    type: number;
    name: number;
    description: number;
    quantity: number;
    unit_price: number;
    markup: number;
    img_url: number;
    recommend_item: number;
    _all: number;
  };

  export type LineItemsAvgAggregateInputType = {
    id?: true;
    quantity?: true;
    unit_price?: true;
    markup?: true;
  };

  export type LineItemsSumAggregateInputType = {
    id?: true;
    quantity?: true;
    unit_price?: true;
    markup?: true;
  };

  export type LineItemsMinAggregateInputType = {
    id?: true;
    type?: true;
    name?: true;
    description?: true;
    quantity?: true;
    unit_price?: true;
    markup?: true;
    img_url?: true;
    recommend_item?: true;
  };

  export type LineItemsMaxAggregateInputType = {
    id?: true;
    type?: true;
    name?: true;
    description?: true;
    quantity?: true;
    unit_price?: true;
    markup?: true;
    img_url?: true;
    recommend_item?: true;
  };

  export type LineItemsCountAggregateInputType = {
    id?: true;
    type?: true;
    name?: true;
    description?: true;
    quantity?: true;
    unit_price?: true;
    markup?: true;
    img_url?: true;
    recommend_item?: true;
    _all?: true;
  };

  export type LineItemsAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which LineItems to aggregate.
     */
    where?: LineItemsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of LineItems to fetch.
     */
    orderBy?:
      | LineItemsOrderByWithRelationInput
      | LineItemsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: LineItemsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` LineItems from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` LineItems.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned LineItems
     **/
    _count?: true | LineItemsCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: LineItemsAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: LineItemsSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: LineItemsMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: LineItemsMaxAggregateInputType;
  };

  export type GetLineItemsAggregateType<T extends LineItemsAggregateArgs> = {
    [P in keyof T & keyof AggregateLineItems]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLineItems[P]>
      : GetScalarType<T[P], AggregateLineItems[P]>;
  };

  export type LineItemsGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: LineItemsWhereInput;
    orderBy?:
      | LineItemsOrderByWithAggregationInput
      | LineItemsOrderByWithAggregationInput[];
    by: LineItemsScalarFieldEnum[] | LineItemsScalarFieldEnum;
    having?: LineItemsScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: LineItemsCountAggregateInputType | true;
    _avg?: LineItemsAvgAggregateInputType;
    _sum?: LineItemsSumAggregateInputType;
    _min?: LineItemsMinAggregateInputType;
    _max?: LineItemsMaxAggregateInputType;
  };

  export type LineItemsGroupByOutputType = {
    id: number;
    type: string;
    name: string;
    description: string | null;
    quantity: number;
    unit_price: number;
    markup: number | null;
    img_url: string | null;
    recommend_item: boolean;
    _count: LineItemsCountAggregateOutputType | null;
    _avg: LineItemsAvgAggregateOutputType | null;
    _sum: LineItemsSumAggregateOutputType | null;
    _min: LineItemsMinAggregateOutputType | null;
    _max: LineItemsMaxAggregateOutputType | null;
  };

  type GetLineItemsGroupByPayload<T extends LineItemsGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<LineItemsGroupByOutputType, T["by"]> & {
          [P in keyof T & keyof LineItemsGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LineItemsGroupByOutputType[P]>
            : GetScalarType<T[P], LineItemsGroupByOutputType[P]>;
        }
      >
    >;

  export type LineItemsSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      type?: boolean;
      name?: boolean;
      description?: boolean;
      quantity?: boolean;
      unit_price?: boolean;
      markup?: boolean;
      img_url?: boolean;
      recommend_item?: boolean;
      quotes?: boolean | LineItems$quotesArgs<ExtArgs>;
      invoices?: boolean | LineItems$invoicesArgs<ExtArgs>;
      jobs?: boolean | LineItems$jobsArgs<ExtArgs>;
      _count?: boolean | LineItemsCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["lineItems"]
  >;

  export type LineItemsSelectScalar = {
    id?: boolean;
    type?: boolean;
    name?: boolean;
    description?: boolean;
    quantity?: boolean;
    unit_price?: boolean;
    markup?: boolean;
    img_url?: boolean;
    recommend_item?: boolean;
  };

  export type LineItemsInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    quotes?: boolean | LineItems$quotesArgs<ExtArgs>;
    invoices?: boolean | LineItems$invoicesArgs<ExtArgs>;
    jobs?: boolean | LineItems$jobsArgs<ExtArgs>;
    _count?: boolean | LineItemsCountOutputTypeDefaultArgs<ExtArgs>;
  };

  export type $LineItemsPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: "LineItems";
    objects: {
      quotes: Prisma.$LineItemQuotePayload<ExtArgs>[];
      invoices: Prisma.$LineItemInvoicePayload<ExtArgs>[];
      jobs: Prisma.$LineItemJobPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: number;
        type: string;
        name: string;
        description: string | null;
        quantity: number;
        unit_price: number;
        markup: number | null;
        img_url: string | null;
        recommend_item: boolean;
      },
      ExtArgs["result"]["lineItems"]
    >;
    composites: {};
  };

  type LineItemsGetPayload<
    S extends boolean | null | undefined | LineItemsDefaultArgs
  > = $Result.GetResult<Prisma.$LineItemsPayload, S>;

  type LineItemsCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<LineItemsFindManyArgs, "select" | "include" | "distinct"> & {
    select?: LineItemsCountAggregateInputType | true;
  };

  export interface LineItemsDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["LineItems"];
      meta: { name: "LineItems" };
    };
    /**
     * Find zero or one LineItems that matches the filter.
     * @param {LineItemsFindUniqueArgs} args - Arguments to find a LineItems
     * @example
     * // Get one LineItems
     * const lineItems = await prisma.lineItems.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     **/
    findUnique<T extends LineItemsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, LineItemsFindUniqueArgs<ExtArgs>>
    ): Prisma__LineItemsClient<
      $Result.GetResult<
        Prisma.$LineItemsPayload<ExtArgs>,
        T,
        "findUnique"
      > | null,
      null,
      ExtArgs
    >;

    /**
     * Find one LineItems that matches the filter or throw an error  with `error.code='P2025'`
     *     if no matches were found.
     * @param {LineItemsFindUniqueOrThrowArgs} args - Arguments to find a LineItems
     * @example
     * // Get one LineItems
     * const lineItems = await prisma.lineItems.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     **/
    findUniqueOrThrow<T extends LineItemsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LineItemsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__LineItemsClient<
      $Result.GetResult<
        Prisma.$LineItemsPayload<ExtArgs>,
        T,
        "findUniqueOrThrow"
      >,
      never,
      ExtArgs
    >;

    /**
     * Find the first LineItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LineItemsFindFirstArgs} args - Arguments to find a LineItems
     * @example
     * // Get one LineItems
     * const lineItems = await prisma.lineItems.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     **/
    findFirst<T extends LineItemsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, LineItemsFindFirstArgs<ExtArgs>>
    ): Prisma__LineItemsClient<
      $Result.GetResult<
        Prisma.$LineItemsPayload<ExtArgs>,
        T,
        "findFirst"
      > | null,
      null,
      ExtArgs
    >;

    /**
     * Find the first LineItems that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LineItemsFindFirstOrThrowArgs} args - Arguments to find a LineItems
     * @example
     * // Get one LineItems
     * const lineItems = await prisma.lineItems.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     **/
    findFirstOrThrow<T extends LineItemsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LineItemsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__LineItemsClient<
      $Result.GetResult<
        Prisma.$LineItemsPayload<ExtArgs>,
        T,
        "findFirstOrThrow"
      >,
      never,
      ExtArgs
    >;

    /**
     * Find zero or more LineItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LineItemsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LineItems
     * const lineItems = await prisma.lineItems.findMany()
     *
     * // Get first 10 LineItems
     * const lineItems = await prisma.lineItems.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const lineItemsWithIdOnly = await prisma.lineItems.findMany({ select: { id: true } })
     *
     **/
    findMany<T extends LineItemsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LineItemsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$LineItemsPayload<ExtArgs>, T, "findMany">
    >;

    /**
     * Create a LineItems.
     * @param {LineItemsCreateArgs} args - Arguments to create a LineItems.
     * @example
     * // Create one LineItems
     * const LineItems = await prisma.lineItems.create({
     *   data: {
     *     // ... data to create a LineItems
     *   }
     * })
     *
     **/
    create<T extends LineItemsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, LineItemsCreateArgs<ExtArgs>>
    ): Prisma__LineItemsClient<
      $Result.GetResult<Prisma.$LineItemsPayload<ExtArgs>, T, "create">,
      never,
      ExtArgs
    >;

    /**
     * Create many LineItems.
     *     @param {LineItemsCreateManyArgs} args - Arguments to create many LineItems.
     *     @example
     *     // Create many LineItems
     *     const lineItems = await prisma.lineItems.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *
     **/
    createMany<T extends LineItemsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LineItemsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a LineItems.
     * @param {LineItemsDeleteArgs} args - Arguments to delete one LineItems.
     * @example
     * // Delete one LineItems
     * const LineItems = await prisma.lineItems.delete({
     *   where: {
     *     // ... filter to delete one LineItems
     *   }
     * })
     *
     **/
    delete<T extends LineItemsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, LineItemsDeleteArgs<ExtArgs>>
    ): Prisma__LineItemsClient<
      $Result.GetResult<Prisma.$LineItemsPayload<ExtArgs>, T, "delete">,
      never,
      ExtArgs
    >;

    /**
     * Update one LineItems.
     * @param {LineItemsUpdateArgs} args - Arguments to update one LineItems.
     * @example
     * // Update one LineItems
     * const lineItems = await prisma.lineItems.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     **/
    update<T extends LineItemsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, LineItemsUpdateArgs<ExtArgs>>
    ): Prisma__LineItemsClient<
      $Result.GetResult<Prisma.$LineItemsPayload<ExtArgs>, T, "update">,
      never,
      ExtArgs
    >;

    /**
     * Delete zero or more LineItems.
     * @param {LineItemsDeleteManyArgs} args - Arguments to filter LineItems to delete.
     * @example
     * // Delete a few LineItems
     * const { count } = await prisma.lineItems.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     **/
    deleteMany<T extends LineItemsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LineItemsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more LineItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LineItemsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LineItems
     * const lineItems = await prisma.lineItems.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     **/
    updateMany<T extends LineItemsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, LineItemsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one LineItems.
     * @param {LineItemsUpsertArgs} args - Arguments to update or create a LineItems.
     * @example
     * // Update or create a LineItems
     * const lineItems = await prisma.lineItems.upsert({
     *   create: {
     *     // ... data to create a LineItems
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LineItems we want to update
     *   }
     * })
     **/
    upsert<T extends LineItemsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, LineItemsUpsertArgs<ExtArgs>>
    ): Prisma__LineItemsClient<
      $Result.GetResult<Prisma.$LineItemsPayload<ExtArgs>, T, "upsert">,
      never,
      ExtArgs
    >;

    /**
     * Count the number of LineItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LineItemsCountArgs} args - Arguments to filter LineItems to count.
     * @example
     * // Count the number of LineItems
     * const count = await prisma.lineItems.count({
     *   where: {
     *     // ... the filter for the LineItems we want to count
     *   }
     * })
     **/
    count<T extends LineItemsCountArgs>(
      args?: Subset<T, LineItemsCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], LineItemsCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a LineItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LineItemsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends LineItemsAggregateArgs>(
      args: Subset<T, LineItemsAggregateArgs>
    ): Prisma.PrismaPromise<GetLineItemsAggregateType<T>>;

    /**
     * Group by LineItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LineItemsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends LineItemsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LineItemsGroupByArgs["orderBy"] }
        : { orderBy?: LineItemsGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
        ? {
            [P in HavingFields]: P extends ByFields
              ? never
              : P extends string
              ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
              : [
                  Error,
                  "Field ",
                  P,
                  ` in "having" needs to be provided in "by"`
                ];
          }[HavingFields]
        : "take" extends Keys<T>
        ? "orderBy" extends Keys<T>
          ? ByValid extends True
            ? {}
            : {
                [P in OrderFields]: P extends ByFields
                  ? never
                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
              }[OrderFields]
          : 'Error: If you provide "take", you also need to provide "orderBy"'
        : "skip" extends Keys<T>
        ? "orderBy" extends Keys<T>
          ? ByValid extends True
            ? {}
            : {
                [P in OrderFields]: P extends ByFields
                  ? never
                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
              }[OrderFields]
          : 'Error: If you provide "skip", you also need to provide "orderBy"'
        : ByValid extends True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
          }[OrderFields]
    >(
      args: SubsetIntersection<T, LineItemsGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetLineItemsGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the LineItems model
     */
    readonly fields: LineItemsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LineItems.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LineItemsClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";

    quotes<T extends LineItems$quotesArgs<ExtArgs> = {}>(
      args?: Subset<T, LineItems$quotesArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<Prisma.$LineItemQuotePayload<ExtArgs>, T, "findMany">
      | Null
    >;

    invoices<T extends LineItems$invoicesArgs<ExtArgs> = {}>(
      args?: Subset<T, LineItems$invoicesArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$LineItemInvoicePayload<ExtArgs>,
          T,
          "findMany"
        >
      | Null
    >;

    jobs<T extends LineItems$jobsArgs<ExtArgs> = {}>(
      args?: Subset<T, LineItems$jobsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<Prisma.$LineItemJobPayload<ExtArgs>, T, "findMany">
      | Null
    >;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the LineItems model
   */
  interface LineItemsFieldRefs {
    readonly id: FieldRef<"LineItems", "Int">;
    readonly type: FieldRef<"LineItems", "String">;
    readonly name: FieldRef<"LineItems", "String">;
    readonly description: FieldRef<"LineItems", "String">;
    readonly quantity: FieldRef<"LineItems", "Int">;
    readonly unit_price: FieldRef<"LineItems", "Float">;
    readonly markup: FieldRef<"LineItems", "Float">;
    readonly img_url: FieldRef<"LineItems", "String">;
    readonly recommend_item: FieldRef<"LineItems", "Boolean">;
  }

  // Custom InputTypes

  /**
   * LineItems findUnique
   */
  export type LineItemsFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the LineItems
     */
    select?: LineItemsSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LineItemsInclude<ExtArgs> | null;
    /**
     * Filter, which LineItems to fetch.
     */
    where: LineItemsWhereUniqueInput;
  };

  /**
   * LineItems findUniqueOrThrow
   */
  export type LineItemsFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the LineItems
     */
    select?: LineItemsSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LineItemsInclude<ExtArgs> | null;
    /**
     * Filter, which LineItems to fetch.
     */
    where: LineItemsWhereUniqueInput;
  };

  /**
   * LineItems findFirst
   */
  export type LineItemsFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the LineItems
     */
    select?: LineItemsSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LineItemsInclude<ExtArgs> | null;
    /**
     * Filter, which LineItems to fetch.
     */
    where?: LineItemsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of LineItems to fetch.
     */
    orderBy?:
      | LineItemsOrderByWithRelationInput
      | LineItemsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for LineItems.
     */
    cursor?: LineItemsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` LineItems from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` LineItems.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of LineItems.
     */
    distinct?: LineItemsScalarFieldEnum | LineItemsScalarFieldEnum[];
  };

  /**
   * LineItems findFirstOrThrow
   */
  export type LineItemsFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the LineItems
     */
    select?: LineItemsSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LineItemsInclude<ExtArgs> | null;
    /**
     * Filter, which LineItems to fetch.
     */
    where?: LineItemsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of LineItems to fetch.
     */
    orderBy?:
      | LineItemsOrderByWithRelationInput
      | LineItemsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for LineItems.
     */
    cursor?: LineItemsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` LineItems from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` LineItems.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of LineItems.
     */
    distinct?: LineItemsScalarFieldEnum | LineItemsScalarFieldEnum[];
  };

  /**
   * LineItems findMany
   */
  export type LineItemsFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the LineItems
     */
    select?: LineItemsSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LineItemsInclude<ExtArgs> | null;
    /**
     * Filter, which LineItems to fetch.
     */
    where?: LineItemsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of LineItems to fetch.
     */
    orderBy?:
      | LineItemsOrderByWithRelationInput
      | LineItemsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing LineItems.
     */
    cursor?: LineItemsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` LineItems from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` LineItems.
     */
    skip?: number;
    distinct?: LineItemsScalarFieldEnum | LineItemsScalarFieldEnum[];
  };

  /**
   * LineItems create
   */
  export type LineItemsCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the LineItems
     */
    select?: LineItemsSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LineItemsInclude<ExtArgs> | null;
    /**
     * The data needed to create a LineItems.
     */
    data: XOR<LineItemsCreateInput, LineItemsUncheckedCreateInput>;
  };

  /**
   * LineItems createMany
   */
  export type LineItemsCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many LineItems.
     */
    data: LineItemsCreateManyInput | LineItemsCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * LineItems update
   */
  export type LineItemsUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the LineItems
     */
    select?: LineItemsSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LineItemsInclude<ExtArgs> | null;
    /**
     * The data needed to update a LineItems.
     */
    data: XOR<LineItemsUpdateInput, LineItemsUncheckedUpdateInput>;
    /**
     * Choose, which LineItems to update.
     */
    where: LineItemsWhereUniqueInput;
  };

  /**
   * LineItems updateMany
   */
  export type LineItemsUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update LineItems.
     */
    data: XOR<
      LineItemsUpdateManyMutationInput,
      LineItemsUncheckedUpdateManyInput
    >;
    /**
     * Filter which LineItems to update
     */
    where?: LineItemsWhereInput;
  };

  /**
   * LineItems upsert
   */
  export type LineItemsUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the LineItems
     */
    select?: LineItemsSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LineItemsInclude<ExtArgs> | null;
    /**
     * The filter to search for the LineItems to update in case it exists.
     */
    where: LineItemsWhereUniqueInput;
    /**
     * In case the LineItems found by the `where` argument doesn't exist, create a new LineItems with this data.
     */
    create: XOR<LineItemsCreateInput, LineItemsUncheckedCreateInput>;
    /**
     * In case the LineItems was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LineItemsUpdateInput, LineItemsUncheckedUpdateInput>;
  };

  /**
   * LineItems delete
   */
  export type LineItemsDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the LineItems
     */
    select?: LineItemsSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LineItemsInclude<ExtArgs> | null;
    /**
     * Filter which LineItems to delete.
     */
    where: LineItemsWhereUniqueInput;
  };

  /**
   * LineItems deleteMany
   */
  export type LineItemsDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which LineItems to delete
     */
    where?: LineItemsWhereInput;
  };

  /**
   * LineItems.quotes
   */
  export type LineItems$quotesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the LineItemQuote
     */
    select?: LineItemQuoteSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LineItemQuoteInclude<ExtArgs> | null;
    where?: LineItemQuoteWhereInput;
    orderBy?:
      | LineItemQuoteOrderByWithRelationInput
      | LineItemQuoteOrderByWithRelationInput[];
    cursor?: LineItemQuoteWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: LineItemQuoteScalarFieldEnum | LineItemQuoteScalarFieldEnum[];
  };

  /**
   * LineItems.invoices
   */
  export type LineItems$invoicesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the LineItemInvoice
     */
    select?: LineItemInvoiceSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LineItemInvoiceInclude<ExtArgs> | null;
    where?: LineItemInvoiceWhereInput;
    orderBy?:
      | LineItemInvoiceOrderByWithRelationInput
      | LineItemInvoiceOrderByWithRelationInput[];
    cursor?: LineItemInvoiceWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?:
      | LineItemInvoiceScalarFieldEnum
      | LineItemInvoiceScalarFieldEnum[];
  };

  /**
   * LineItems.jobs
   */
  export type LineItems$jobsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the LineItemJob
     */
    select?: LineItemJobSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LineItemJobInclude<ExtArgs> | null;
    where?: LineItemJobWhereInput;
    orderBy?:
      | LineItemJobOrderByWithRelationInput
      | LineItemJobOrderByWithRelationInput[];
    cursor?: LineItemJobWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: LineItemJobScalarFieldEnum | LineItemJobScalarFieldEnum[];
  };

  /**
   * LineItems without action
   */
  export type LineItemsDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the LineItems
     */
    select?: LineItemsSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LineItemsInclude<ExtArgs> | null;
  };

  /**
   * Model Quotes
   */

  export type AggregateQuotes = {
    _count: QuotesCountAggregateOutputType | null;
    _avg: QuotesAvgAggregateOutputType | null;
    _sum: QuotesSumAggregateOutputType | null;
    _min: QuotesMinAggregateOutputType | null;
    _max: QuotesMaxAggregateOutputType | null;
  };

  export type QuotesAvgAggregateOutputType = {
    id: number | null;
    client_id: number | null;
    discount: number | null;
    tax_id: number | null;
    required_deposit: number | null;
    belongs_to_id: number | null;
  };

  export type QuotesSumAggregateOutputType = {
    id: number | null;
    client_id: number | null;
    discount: number | null;
    tax_id: number | null;
    required_deposit: number | null;
    belongs_to_id: number | null;
  };

  export type QuotesMinAggregateOutputType = {
    id: number | null;
    emailed_to_client: boolean | null;
    texted_to_client: boolean | null;
    status: string | null;
    title: string | null;
    quote_number: string | null;
    opportunity_rating: string | null;
    client_id: number | null;
    client_message: string | null;
    discount: number | null;
    discount_unit: string | null;
    tax_id: number | null;
    required_deposit: number | null;
    link_to_releated_jobs: boolean | null;
    link_to_releated_invoices: boolean | null;
    belongs_to_id: number | null;
  };

  export type QuotesMaxAggregateOutputType = {
    id: number | null;
    emailed_to_client: boolean | null;
    texted_to_client: boolean | null;
    status: string | null;
    title: string | null;
    quote_number: string | null;
    opportunity_rating: string | null;
    client_id: number | null;
    client_message: string | null;
    discount: number | null;
    discount_unit: string | null;
    tax_id: number | null;
    required_deposit: number | null;
    link_to_releated_jobs: boolean | null;
    link_to_releated_invoices: boolean | null;
    belongs_to_id: number | null;
  };

  export type QuotesCountAggregateOutputType = {
    id: number;
    tags: number;
    emailed_to_client: number;
    texted_to_client: number;
    status: number;
    title: number;
    quote_number: number;
    opportunity_rating: number;
    client_id: number;
    client_message: number;
    discount: number;
    discount_unit: number;
    tax_id: number;
    required_deposit: number;
    link_to_releated_jobs: number;
    link_to_releated_invoices: number;
    belongs_to_id: number;
    _all: number;
  };

  export type QuotesAvgAggregateInputType = {
    id?: true;
    client_id?: true;
    discount?: true;
    tax_id?: true;
    required_deposit?: true;
    belongs_to_id?: true;
  };

  export type QuotesSumAggregateInputType = {
    id?: true;
    client_id?: true;
    discount?: true;
    tax_id?: true;
    required_deposit?: true;
    belongs_to_id?: true;
  };

  export type QuotesMinAggregateInputType = {
    id?: true;
    emailed_to_client?: true;
    texted_to_client?: true;
    status?: true;
    title?: true;
    quote_number?: true;
    opportunity_rating?: true;
    client_id?: true;
    client_message?: true;
    discount?: true;
    discount_unit?: true;
    tax_id?: true;
    required_deposit?: true;
    link_to_releated_jobs?: true;
    link_to_releated_invoices?: true;
    belongs_to_id?: true;
  };

  export type QuotesMaxAggregateInputType = {
    id?: true;
    emailed_to_client?: true;
    texted_to_client?: true;
    status?: true;
    title?: true;
    quote_number?: true;
    opportunity_rating?: true;
    client_id?: true;
    client_message?: true;
    discount?: true;
    discount_unit?: true;
    tax_id?: true;
    required_deposit?: true;
    link_to_releated_jobs?: true;
    link_to_releated_invoices?: true;
    belongs_to_id?: true;
  };

  export type QuotesCountAggregateInputType = {
    id?: true;
    tags?: true;
    emailed_to_client?: true;
    texted_to_client?: true;
    status?: true;
    title?: true;
    quote_number?: true;
    opportunity_rating?: true;
    client_id?: true;
    client_message?: true;
    discount?: true;
    discount_unit?: true;
    tax_id?: true;
    required_deposit?: true;
    link_to_releated_jobs?: true;
    link_to_releated_invoices?: true;
    belongs_to_id?: true;
    _all?: true;
  };

  export type QuotesAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which Quotes to aggregate.
     */
    where?: QuotesWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Quotes to fetch.
     */
    orderBy?: QuotesOrderByWithRelationInput | QuotesOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: QuotesWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Quotes from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Quotes.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Quotes
     **/
    _count?: true | QuotesCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: QuotesAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: QuotesSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: QuotesMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: QuotesMaxAggregateInputType;
  };

  export type GetQuotesAggregateType<T extends QuotesAggregateArgs> = {
    [P in keyof T & keyof AggregateQuotes]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuotes[P]>
      : GetScalarType<T[P], AggregateQuotes[P]>;
  };

  export type QuotesGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: QuotesWhereInput;
    orderBy?:
      | QuotesOrderByWithAggregationInput
      | QuotesOrderByWithAggregationInput[];
    by: QuotesScalarFieldEnum[] | QuotesScalarFieldEnum;
    having?: QuotesScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: QuotesCountAggregateInputType | true;
    _avg?: QuotesAvgAggregateInputType;
    _sum?: QuotesSumAggregateInputType;
    _min?: QuotesMinAggregateInputType;
    _max?: QuotesMaxAggregateInputType;
  };

  export type QuotesGroupByOutputType = {
    id: number;
    tags: JsonValue | null;
    emailed_to_client: boolean;
    texted_to_client: boolean;
    status: string;
    title: string;
    quote_number: string;
    opportunity_rating: string | null;
    client_id: number;
    client_message: string | null;
    discount: number | null;
    discount_unit: string | null;
    tax_id: number;
    required_deposit: number | null;
    link_to_releated_jobs: boolean;
    link_to_releated_invoices: boolean;
    belongs_to_id: number;
    _count: QuotesCountAggregateOutputType | null;
    _avg: QuotesAvgAggregateOutputType | null;
    _sum: QuotesSumAggregateOutputType | null;
    _min: QuotesMinAggregateOutputType | null;
    _max: QuotesMaxAggregateOutputType | null;
  };

  type GetQuotesGroupByPayload<T extends QuotesGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<QuotesGroupByOutputType, T["by"]> & {
          [P in keyof T & keyof QuotesGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuotesGroupByOutputType[P]>
            : GetScalarType<T[P], QuotesGroupByOutputType[P]>;
        }
      >
    >;

  export type QuotesSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      tags?: boolean;
      emailed_to_client?: boolean;
      texted_to_client?: boolean;
      status?: boolean;
      title?: boolean;
      quote_number?: boolean;
      opportunity_rating?: boolean;
      client_id?: boolean;
      client_message?: boolean;
      discount?: boolean;
      discount_unit?: boolean;
      tax_id?: boolean;
      required_deposit?: boolean;
      link_to_releated_jobs?: boolean;
      link_to_releated_invoices?: boolean;
      belongs_to_id?: boolean;
      client?: boolean | ClientsDefaultArgs<ExtArgs>;
      line_items?: boolean | Quotes$line_itemsArgs<ExtArgs>;
      tax?: boolean | Quotes$taxArgs<ExtArgs>;
      requests?: boolean | Quotes$requestsArgs<ExtArgs>;
      job_quotes?: boolean | Quotes$job_quotesArgs<ExtArgs>;
      belongs_to?: boolean | UsersDefaultArgs<ExtArgs>;
      _count?: boolean | QuotesCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["quotes"]
  >;

  export type QuotesSelectScalar = {
    id?: boolean;
    tags?: boolean;
    emailed_to_client?: boolean;
    texted_to_client?: boolean;
    status?: boolean;
    title?: boolean;
    quote_number?: boolean;
    opportunity_rating?: boolean;
    client_id?: boolean;
    client_message?: boolean;
    discount?: boolean;
    discount_unit?: boolean;
    tax_id?: boolean;
    required_deposit?: boolean;
    link_to_releated_jobs?: boolean;
    link_to_releated_invoices?: boolean;
    belongs_to_id?: boolean;
  };

  export type QuotesInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    client?: boolean | ClientsDefaultArgs<ExtArgs>;
    line_items?: boolean | Quotes$line_itemsArgs<ExtArgs>;
    tax?: boolean | Quotes$taxArgs<ExtArgs>;
    requests?: boolean | Quotes$requestsArgs<ExtArgs>;
    job_quotes?: boolean | Quotes$job_quotesArgs<ExtArgs>;
    belongs_to?: boolean | UsersDefaultArgs<ExtArgs>;
    _count?: boolean | QuotesCountOutputTypeDefaultArgs<ExtArgs>;
  };

  export type $QuotesPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: "Quotes";
    objects: {
      client: Prisma.$ClientsPayload<ExtArgs>;
      line_items: Prisma.$LineItemQuotePayload<ExtArgs>[];
      tax: Prisma.$TaxesPayload<ExtArgs> | null;
      requests: Prisma.$QuoteRequestPayload<ExtArgs>[];
      job_quotes: Prisma.$JobQuotePayload<ExtArgs>[];
      belongs_to: Prisma.$UsersPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: number;
        tags: Prisma.JsonValue | null;
        emailed_to_client: boolean;
        texted_to_client: boolean;
        status: string;
        title: string;
        quote_number: string;
        opportunity_rating: string | null;
        client_id: number;
        client_message: string | null;
        discount: number | null;
        discount_unit: string | null;
        tax_id: number;
        required_deposit: number | null;
        link_to_releated_jobs: boolean;
        link_to_releated_invoices: boolean;
        belongs_to_id: number;
      },
      ExtArgs["result"]["quotes"]
    >;
    composites: {};
  };

  type QuotesGetPayload<
    S extends boolean | null | undefined | QuotesDefaultArgs
  > = $Result.GetResult<Prisma.$QuotesPayload, S>;

  type QuotesCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<QuotesFindManyArgs, "select" | "include" | "distinct"> & {
    select?: QuotesCountAggregateInputType | true;
  };

  export interface QuotesDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["Quotes"];
      meta: { name: "Quotes" };
    };
    /**
     * Find zero or one Quotes that matches the filter.
     * @param {QuotesFindUniqueArgs} args - Arguments to find a Quotes
     * @example
     * // Get one Quotes
     * const quotes = await prisma.quotes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     **/
    findUnique<T extends QuotesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, QuotesFindUniqueArgs<ExtArgs>>
    ): Prisma__QuotesClient<
      $Result.GetResult<Prisma.$QuotesPayload<ExtArgs>, T, "findUnique"> | null,
      null,
      ExtArgs
    >;

    /**
     * Find one Quotes that matches the filter or throw an error  with `error.code='P2025'`
     *     if no matches were found.
     * @param {QuotesFindUniqueOrThrowArgs} args - Arguments to find a Quotes
     * @example
     * // Get one Quotes
     * const quotes = await prisma.quotes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     **/
    findUniqueOrThrow<T extends QuotesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, QuotesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__QuotesClient<
      $Result.GetResult<Prisma.$QuotesPayload<ExtArgs>, T, "findUniqueOrThrow">,
      never,
      ExtArgs
    >;

    /**
     * Find the first Quotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotesFindFirstArgs} args - Arguments to find a Quotes
     * @example
     * // Get one Quotes
     * const quotes = await prisma.quotes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     **/
    findFirst<T extends QuotesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, QuotesFindFirstArgs<ExtArgs>>
    ): Prisma__QuotesClient<
      $Result.GetResult<Prisma.$QuotesPayload<ExtArgs>, T, "findFirst"> | null,
      null,
      ExtArgs
    >;

    /**
     * Find the first Quotes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotesFindFirstOrThrowArgs} args - Arguments to find a Quotes
     * @example
     * // Get one Quotes
     * const quotes = await prisma.quotes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     **/
    findFirstOrThrow<T extends QuotesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, QuotesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__QuotesClient<
      $Result.GetResult<Prisma.$QuotesPayload<ExtArgs>, T, "findFirstOrThrow">,
      never,
      ExtArgs
    >;

    /**
     * Find zero or more Quotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Quotes
     * const quotes = await prisma.quotes.findMany()
     *
     * // Get first 10 Quotes
     * const quotes = await prisma.quotes.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const quotesWithIdOnly = await prisma.quotes.findMany({ select: { id: true } })
     *
     **/
    findMany<T extends QuotesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, QuotesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$QuotesPayload<ExtArgs>, T, "findMany">
    >;

    /**
     * Create a Quotes.
     * @param {QuotesCreateArgs} args - Arguments to create a Quotes.
     * @example
     * // Create one Quotes
     * const Quotes = await prisma.quotes.create({
     *   data: {
     *     // ... data to create a Quotes
     *   }
     * })
     *
     **/
    create<T extends QuotesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, QuotesCreateArgs<ExtArgs>>
    ): Prisma__QuotesClient<
      $Result.GetResult<Prisma.$QuotesPayload<ExtArgs>, T, "create">,
      never,
      ExtArgs
    >;

    /**
     * Create many Quotes.
     *     @param {QuotesCreateManyArgs} args - Arguments to create many Quotes.
     *     @example
     *     // Create many Quotes
     *     const quotes = await prisma.quotes.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *
     **/
    createMany<T extends QuotesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, QuotesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a Quotes.
     * @param {QuotesDeleteArgs} args - Arguments to delete one Quotes.
     * @example
     * // Delete one Quotes
     * const Quotes = await prisma.quotes.delete({
     *   where: {
     *     // ... filter to delete one Quotes
     *   }
     * })
     *
     **/
    delete<T extends QuotesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, QuotesDeleteArgs<ExtArgs>>
    ): Prisma__QuotesClient<
      $Result.GetResult<Prisma.$QuotesPayload<ExtArgs>, T, "delete">,
      never,
      ExtArgs
    >;

    /**
     * Update one Quotes.
     * @param {QuotesUpdateArgs} args - Arguments to update one Quotes.
     * @example
     * // Update one Quotes
     * const quotes = await prisma.quotes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     **/
    update<T extends QuotesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, QuotesUpdateArgs<ExtArgs>>
    ): Prisma__QuotesClient<
      $Result.GetResult<Prisma.$QuotesPayload<ExtArgs>, T, "update">,
      never,
      ExtArgs
    >;

    /**
     * Delete zero or more Quotes.
     * @param {QuotesDeleteManyArgs} args - Arguments to filter Quotes to delete.
     * @example
     * // Delete a few Quotes
     * const { count } = await prisma.quotes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     **/
    deleteMany<T extends QuotesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, QuotesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Quotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Quotes
     * const quotes = await prisma.quotes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     **/
    updateMany<T extends QuotesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, QuotesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one Quotes.
     * @param {QuotesUpsertArgs} args - Arguments to update or create a Quotes.
     * @example
     * // Update or create a Quotes
     * const quotes = await prisma.quotes.upsert({
     *   create: {
     *     // ... data to create a Quotes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Quotes we want to update
     *   }
     * })
     **/
    upsert<T extends QuotesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, QuotesUpsertArgs<ExtArgs>>
    ): Prisma__QuotesClient<
      $Result.GetResult<Prisma.$QuotesPayload<ExtArgs>, T, "upsert">,
      never,
      ExtArgs
    >;

    /**
     * Count the number of Quotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotesCountArgs} args - Arguments to filter Quotes to count.
     * @example
     * // Count the number of Quotes
     * const count = await prisma.quotes.count({
     *   where: {
     *     // ... the filter for the Quotes we want to count
     *   }
     * })
     **/
    count<T extends QuotesCountArgs>(
      args?: Subset<T, QuotesCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], QuotesCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Quotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends QuotesAggregateArgs>(
      args: Subset<T, QuotesAggregateArgs>
    ): Prisma.PrismaPromise<GetQuotesAggregateType<T>>;

    /**
     * Group by Quotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends QuotesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuotesGroupByArgs["orderBy"] }
        : { orderBy?: QuotesGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
        ? {
            [P in HavingFields]: P extends ByFields
              ? never
              : P extends string
              ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
              : [
                  Error,
                  "Field ",
                  P,
                  ` in "having" needs to be provided in "by"`
                ];
          }[HavingFields]
        : "take" extends Keys<T>
        ? "orderBy" extends Keys<T>
          ? ByValid extends True
            ? {}
            : {
                [P in OrderFields]: P extends ByFields
                  ? never
                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
              }[OrderFields]
          : 'Error: If you provide "take", you also need to provide "orderBy"'
        : "skip" extends Keys<T>
        ? "orderBy" extends Keys<T>
          ? ByValid extends True
            ? {}
            : {
                [P in OrderFields]: P extends ByFields
                  ? never
                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
              }[OrderFields]
          : 'Error: If you provide "skip", you also need to provide "orderBy"'
        : ByValid extends True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
          }[OrderFields]
    >(
      args: SubsetIntersection<T, QuotesGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetQuotesGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Quotes model
     */
    readonly fields: QuotesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Quotes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuotesClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";

    client<T extends ClientsDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, ClientsDefaultArgs<ExtArgs>>
    ): Prisma__ClientsClient<
      | $Result.GetResult<
          Prisma.$ClientsPayload<ExtArgs>,
          T,
          "findUniqueOrThrow"
        >
      | Null,
      Null,
      ExtArgs
    >;

    line_items<T extends Quotes$line_itemsArgs<ExtArgs> = {}>(
      args?: Subset<T, Quotes$line_itemsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<Prisma.$LineItemQuotePayload<ExtArgs>, T, "findMany">
      | Null
    >;

    tax<T extends Quotes$taxArgs<ExtArgs> = {}>(
      args?: Subset<T, Quotes$taxArgs<ExtArgs>>
    ): Prisma__TaxesClient<
      $Result.GetResult<
        Prisma.$TaxesPayload<ExtArgs>,
        T,
        "findUniqueOrThrow"
      > | null,
      null,
      ExtArgs
    >;

    requests<T extends Quotes$requestsArgs<ExtArgs> = {}>(
      args?: Subset<T, Quotes$requestsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<Prisma.$QuoteRequestPayload<ExtArgs>, T, "findMany">
      | Null
    >;

    job_quotes<T extends Quotes$job_quotesArgs<ExtArgs> = {}>(
      args?: Subset<T, Quotes$job_quotesArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$JobQuotePayload<ExtArgs>, T, "findMany"> | Null
    >;

    belongs_to<T extends UsersDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UsersDefaultArgs<ExtArgs>>
    ): Prisma__UsersClient<
      | $Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow">
      | Null,
      Null,
      ExtArgs
    >;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Quotes model
   */
  interface QuotesFieldRefs {
    readonly id: FieldRef<"Quotes", "Int">;
    readonly tags: FieldRef<"Quotes", "Json">;
    readonly emailed_to_client: FieldRef<"Quotes", "Boolean">;
    readonly texted_to_client: FieldRef<"Quotes", "Boolean">;
    readonly status: FieldRef<"Quotes", "String">;
    readonly title: FieldRef<"Quotes", "String">;
    readonly quote_number: FieldRef<"Quotes", "String">;
    readonly opportunity_rating: FieldRef<"Quotes", "String">;
    readonly client_id: FieldRef<"Quotes", "Int">;
    readonly client_message: FieldRef<"Quotes", "String">;
    readonly discount: FieldRef<"Quotes", "Float">;
    readonly discount_unit: FieldRef<"Quotes", "String">;
    readonly tax_id: FieldRef<"Quotes", "Int">;
    readonly required_deposit: FieldRef<"Quotes", "Float">;
    readonly link_to_releated_jobs: FieldRef<"Quotes", "Boolean">;
    readonly link_to_releated_invoices: FieldRef<"Quotes", "Boolean">;
    readonly belongs_to_id: FieldRef<"Quotes", "Int">;
  }

  // Custom InputTypes

  /**
   * Quotes findUnique
   */
  export type QuotesFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Quotes
     */
    select?: QuotesSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuotesInclude<ExtArgs> | null;
    /**
     * Filter, which Quotes to fetch.
     */
    where: QuotesWhereUniqueInput;
  };

  /**
   * Quotes findUniqueOrThrow
   */
  export type QuotesFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Quotes
     */
    select?: QuotesSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuotesInclude<ExtArgs> | null;
    /**
     * Filter, which Quotes to fetch.
     */
    where: QuotesWhereUniqueInput;
  };

  /**
   * Quotes findFirst
   */
  export type QuotesFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Quotes
     */
    select?: QuotesSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuotesInclude<ExtArgs> | null;
    /**
     * Filter, which Quotes to fetch.
     */
    where?: QuotesWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Quotes to fetch.
     */
    orderBy?: QuotesOrderByWithRelationInput | QuotesOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Quotes.
     */
    cursor?: QuotesWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Quotes from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Quotes.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Quotes.
     */
    distinct?: QuotesScalarFieldEnum | QuotesScalarFieldEnum[];
  };

  /**
   * Quotes findFirstOrThrow
   */
  export type QuotesFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Quotes
     */
    select?: QuotesSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuotesInclude<ExtArgs> | null;
    /**
     * Filter, which Quotes to fetch.
     */
    where?: QuotesWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Quotes to fetch.
     */
    orderBy?: QuotesOrderByWithRelationInput | QuotesOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Quotes.
     */
    cursor?: QuotesWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Quotes from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Quotes.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Quotes.
     */
    distinct?: QuotesScalarFieldEnum | QuotesScalarFieldEnum[];
  };

  /**
   * Quotes findMany
   */
  export type QuotesFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Quotes
     */
    select?: QuotesSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuotesInclude<ExtArgs> | null;
    /**
     * Filter, which Quotes to fetch.
     */
    where?: QuotesWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Quotes to fetch.
     */
    orderBy?: QuotesOrderByWithRelationInput | QuotesOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Quotes.
     */
    cursor?: QuotesWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Quotes from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Quotes.
     */
    skip?: number;
    distinct?: QuotesScalarFieldEnum | QuotesScalarFieldEnum[];
  };

  /**
   * Quotes create
   */
  export type QuotesCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Quotes
     */
    select?: QuotesSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuotesInclude<ExtArgs> | null;
    /**
     * The data needed to create a Quotes.
     */
    data: XOR<QuotesCreateInput, QuotesUncheckedCreateInput>;
  };

  /**
   * Quotes createMany
   */
  export type QuotesCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many Quotes.
     */
    data: QuotesCreateManyInput | QuotesCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Quotes update
   */
  export type QuotesUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Quotes
     */
    select?: QuotesSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuotesInclude<ExtArgs> | null;
    /**
     * The data needed to update a Quotes.
     */
    data: XOR<QuotesUpdateInput, QuotesUncheckedUpdateInput>;
    /**
     * Choose, which Quotes to update.
     */
    where: QuotesWhereUniqueInput;
  };

  /**
   * Quotes updateMany
   */
  export type QuotesUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update Quotes.
     */
    data: XOR<QuotesUpdateManyMutationInput, QuotesUncheckedUpdateManyInput>;
    /**
     * Filter which Quotes to update
     */
    where?: QuotesWhereInput;
  };

  /**
   * Quotes upsert
   */
  export type QuotesUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Quotes
     */
    select?: QuotesSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuotesInclude<ExtArgs> | null;
    /**
     * The filter to search for the Quotes to update in case it exists.
     */
    where: QuotesWhereUniqueInput;
    /**
     * In case the Quotes found by the `where` argument doesn't exist, create a new Quotes with this data.
     */
    create: XOR<QuotesCreateInput, QuotesUncheckedCreateInput>;
    /**
     * In case the Quotes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuotesUpdateInput, QuotesUncheckedUpdateInput>;
  };

  /**
   * Quotes delete
   */
  export type QuotesDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Quotes
     */
    select?: QuotesSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuotesInclude<ExtArgs> | null;
    /**
     * Filter which Quotes to delete.
     */
    where: QuotesWhereUniqueInput;
  };

  /**
   * Quotes deleteMany
   */
  export type QuotesDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which Quotes to delete
     */
    where?: QuotesWhereInput;
  };

  /**
   * Quotes.line_items
   */
  export type Quotes$line_itemsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the LineItemQuote
     */
    select?: LineItemQuoteSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LineItemQuoteInclude<ExtArgs> | null;
    where?: LineItemQuoteWhereInput;
    orderBy?:
      | LineItemQuoteOrderByWithRelationInput
      | LineItemQuoteOrderByWithRelationInput[];
    cursor?: LineItemQuoteWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: LineItemQuoteScalarFieldEnum | LineItemQuoteScalarFieldEnum[];
  };

  /**
   * Quotes.tax
   */
  export type Quotes$taxArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Taxes
     */
    select?: TaxesSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TaxesInclude<ExtArgs> | null;
    where?: TaxesWhereInput;
  };

  /**
   * Quotes.requests
   */
  export type Quotes$requestsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the QuoteRequest
     */
    select?: QuoteRequestSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuoteRequestInclude<ExtArgs> | null;
    where?: QuoteRequestWhereInput;
    orderBy?:
      | QuoteRequestOrderByWithRelationInput
      | QuoteRequestOrderByWithRelationInput[];
    cursor?: QuoteRequestWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: QuoteRequestScalarFieldEnum | QuoteRequestScalarFieldEnum[];
  };

  /**
   * Quotes.job_quotes
   */
  export type Quotes$job_quotesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the JobQuote
     */
    select?: JobQuoteSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobQuoteInclude<ExtArgs> | null;
    where?: JobQuoteWhereInput;
    orderBy?:
      | JobQuoteOrderByWithRelationInput
      | JobQuoteOrderByWithRelationInput[];
    cursor?: JobQuoteWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: JobQuoteScalarFieldEnum | JobQuoteScalarFieldEnum[];
  };

  /**
   * Quotes without action
   */
  export type QuotesDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Quotes
     */
    select?: QuotesSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuotesInclude<ExtArgs> | null;
  };

  /**
   * Model LineItemQuote
   */

  export type AggregateLineItemQuote = {
    _count: LineItemQuoteCountAggregateOutputType | null;
    _avg: LineItemQuoteAvgAggregateOutputType | null;
    _sum: LineItemQuoteSumAggregateOutputType | null;
    _min: LineItemQuoteMinAggregateOutputType | null;
    _max: LineItemQuoteMaxAggregateOutputType | null;
  };

  export type LineItemQuoteAvgAggregateOutputType = {
    id: number | null;
    quote_id: number | null;
    line_item_id: number | null;
  };

  export type LineItemQuoteSumAggregateOutputType = {
    id: number | null;
    quote_id: number | null;
    line_item_id: number | null;
  };

  export type LineItemQuoteMinAggregateOutputType = {
    id: number | null;
    quote_id: number | null;
    line_item_id: number | null;
  };

  export type LineItemQuoteMaxAggregateOutputType = {
    id: number | null;
    quote_id: number | null;
    line_item_id: number | null;
  };

  export type LineItemQuoteCountAggregateOutputType = {
    id: number;
    quote_id: number;
    line_item_id: number;
    _all: number;
  };

  export type LineItemQuoteAvgAggregateInputType = {
    id?: true;
    quote_id?: true;
    line_item_id?: true;
  };

  export type LineItemQuoteSumAggregateInputType = {
    id?: true;
    quote_id?: true;
    line_item_id?: true;
  };

  export type LineItemQuoteMinAggregateInputType = {
    id?: true;
    quote_id?: true;
    line_item_id?: true;
  };

  export type LineItemQuoteMaxAggregateInputType = {
    id?: true;
    quote_id?: true;
    line_item_id?: true;
  };

  export type LineItemQuoteCountAggregateInputType = {
    id?: true;
    quote_id?: true;
    line_item_id?: true;
    _all?: true;
  };

  export type LineItemQuoteAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which LineItemQuote to aggregate.
     */
    where?: LineItemQuoteWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of LineItemQuotes to fetch.
     */
    orderBy?:
      | LineItemQuoteOrderByWithRelationInput
      | LineItemQuoteOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: LineItemQuoteWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` LineItemQuotes from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` LineItemQuotes.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned LineItemQuotes
     **/
    _count?: true | LineItemQuoteCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: LineItemQuoteAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: LineItemQuoteSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: LineItemQuoteMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: LineItemQuoteMaxAggregateInputType;
  };

  export type GetLineItemQuoteAggregateType<
    T extends LineItemQuoteAggregateArgs
  > = {
    [P in keyof T & keyof AggregateLineItemQuote]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLineItemQuote[P]>
      : GetScalarType<T[P], AggregateLineItemQuote[P]>;
  };

  export type LineItemQuoteGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: LineItemQuoteWhereInput;
    orderBy?:
      | LineItemQuoteOrderByWithAggregationInput
      | LineItemQuoteOrderByWithAggregationInput[];
    by: LineItemQuoteScalarFieldEnum[] | LineItemQuoteScalarFieldEnum;
    having?: LineItemQuoteScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: LineItemQuoteCountAggregateInputType | true;
    _avg?: LineItemQuoteAvgAggregateInputType;
    _sum?: LineItemQuoteSumAggregateInputType;
    _min?: LineItemQuoteMinAggregateInputType;
    _max?: LineItemQuoteMaxAggregateInputType;
  };

  export type LineItemQuoteGroupByOutputType = {
    id: number;
    quote_id: number;
    line_item_id: number;
    _count: LineItemQuoteCountAggregateOutputType | null;
    _avg: LineItemQuoteAvgAggregateOutputType | null;
    _sum: LineItemQuoteSumAggregateOutputType | null;
    _min: LineItemQuoteMinAggregateOutputType | null;
    _max: LineItemQuoteMaxAggregateOutputType | null;
  };

  type GetLineItemQuoteGroupByPayload<T extends LineItemQuoteGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<LineItemQuoteGroupByOutputType, T["by"]> & {
          [P in keyof T &
            keyof LineItemQuoteGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LineItemQuoteGroupByOutputType[P]>
            : GetScalarType<T[P], LineItemQuoteGroupByOutputType[P]>;
        }
      >
    >;

  export type LineItemQuoteSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      quote_id?: boolean;
      line_item_id?: boolean;
      quote?: boolean | QuotesDefaultArgs<ExtArgs>;
      line_item?: boolean | LineItemsDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["lineItemQuote"]
  >;

  export type LineItemQuoteSelectScalar = {
    id?: boolean;
    quote_id?: boolean;
    line_item_id?: boolean;
  };

  export type LineItemQuoteInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    quote?: boolean | QuotesDefaultArgs<ExtArgs>;
    line_item?: boolean | LineItemsDefaultArgs<ExtArgs>;
  };

  export type $LineItemQuotePayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: "LineItemQuote";
    objects: {
      quote: Prisma.$QuotesPayload<ExtArgs>;
      line_item: Prisma.$LineItemsPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: number;
        quote_id: number;
        line_item_id: number;
      },
      ExtArgs["result"]["lineItemQuote"]
    >;
    composites: {};
  };

  type LineItemQuoteGetPayload<
    S extends boolean | null | undefined | LineItemQuoteDefaultArgs
  > = $Result.GetResult<Prisma.$LineItemQuotePayload, S>;

  type LineItemQuoteCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<LineItemQuoteFindManyArgs, "select" | "include" | "distinct"> & {
    select?: LineItemQuoteCountAggregateInputType | true;
  };

  export interface LineItemQuoteDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["LineItemQuote"];
      meta: { name: "LineItemQuote" };
    };
    /**
     * Find zero or one LineItemQuote that matches the filter.
     * @param {LineItemQuoteFindUniqueArgs} args - Arguments to find a LineItemQuote
     * @example
     * // Get one LineItemQuote
     * const lineItemQuote = await prisma.lineItemQuote.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     **/
    findUnique<T extends LineItemQuoteFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, LineItemQuoteFindUniqueArgs<ExtArgs>>
    ): Prisma__LineItemQuoteClient<
      $Result.GetResult<
        Prisma.$LineItemQuotePayload<ExtArgs>,
        T,
        "findUnique"
      > | null,
      null,
      ExtArgs
    >;

    /**
     * Find one LineItemQuote that matches the filter or throw an error  with `error.code='P2025'`
     *     if no matches were found.
     * @param {LineItemQuoteFindUniqueOrThrowArgs} args - Arguments to find a LineItemQuote
     * @example
     * // Get one LineItemQuote
     * const lineItemQuote = await prisma.lineItemQuote.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     **/
    findUniqueOrThrow<T extends LineItemQuoteFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LineItemQuoteFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__LineItemQuoteClient<
      $Result.GetResult<
        Prisma.$LineItemQuotePayload<ExtArgs>,
        T,
        "findUniqueOrThrow"
      >,
      never,
      ExtArgs
    >;

    /**
     * Find the first LineItemQuote that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LineItemQuoteFindFirstArgs} args - Arguments to find a LineItemQuote
     * @example
     * // Get one LineItemQuote
     * const lineItemQuote = await prisma.lineItemQuote.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     **/
    findFirst<T extends LineItemQuoteFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, LineItemQuoteFindFirstArgs<ExtArgs>>
    ): Prisma__LineItemQuoteClient<
      $Result.GetResult<
        Prisma.$LineItemQuotePayload<ExtArgs>,
        T,
        "findFirst"
      > | null,
      null,
      ExtArgs
    >;

    /**
     * Find the first LineItemQuote that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LineItemQuoteFindFirstOrThrowArgs} args - Arguments to find a LineItemQuote
     * @example
     * // Get one LineItemQuote
     * const lineItemQuote = await prisma.lineItemQuote.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     **/
    findFirstOrThrow<T extends LineItemQuoteFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LineItemQuoteFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__LineItemQuoteClient<
      $Result.GetResult<
        Prisma.$LineItemQuotePayload<ExtArgs>,
        T,
        "findFirstOrThrow"
      >,
      never,
      ExtArgs
    >;

    /**
     * Find zero or more LineItemQuotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LineItemQuoteFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LineItemQuotes
     * const lineItemQuotes = await prisma.lineItemQuote.findMany()
     *
     * // Get first 10 LineItemQuotes
     * const lineItemQuotes = await prisma.lineItemQuote.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const lineItemQuoteWithIdOnly = await prisma.lineItemQuote.findMany({ select: { id: true } })
     *
     **/
    findMany<T extends LineItemQuoteFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LineItemQuoteFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$LineItemQuotePayload<ExtArgs>, T, "findMany">
    >;

    /**
     * Create a LineItemQuote.
     * @param {LineItemQuoteCreateArgs} args - Arguments to create a LineItemQuote.
     * @example
     * // Create one LineItemQuote
     * const LineItemQuote = await prisma.lineItemQuote.create({
     *   data: {
     *     // ... data to create a LineItemQuote
     *   }
     * })
     *
     **/
    create<T extends LineItemQuoteCreateArgs<ExtArgs>>(
      args: SelectSubset<T, LineItemQuoteCreateArgs<ExtArgs>>
    ): Prisma__LineItemQuoteClient<
      $Result.GetResult<Prisma.$LineItemQuotePayload<ExtArgs>, T, "create">,
      never,
      ExtArgs
    >;

    /**
     * Create many LineItemQuotes.
     *     @param {LineItemQuoteCreateManyArgs} args - Arguments to create many LineItemQuotes.
     *     @example
     *     // Create many LineItemQuotes
     *     const lineItemQuote = await prisma.lineItemQuote.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *
     **/
    createMany<T extends LineItemQuoteCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LineItemQuoteCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a LineItemQuote.
     * @param {LineItemQuoteDeleteArgs} args - Arguments to delete one LineItemQuote.
     * @example
     * // Delete one LineItemQuote
     * const LineItemQuote = await prisma.lineItemQuote.delete({
     *   where: {
     *     // ... filter to delete one LineItemQuote
     *   }
     * })
     *
     **/
    delete<T extends LineItemQuoteDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, LineItemQuoteDeleteArgs<ExtArgs>>
    ): Prisma__LineItemQuoteClient<
      $Result.GetResult<Prisma.$LineItemQuotePayload<ExtArgs>, T, "delete">,
      never,
      ExtArgs
    >;

    /**
     * Update one LineItemQuote.
     * @param {LineItemQuoteUpdateArgs} args - Arguments to update one LineItemQuote.
     * @example
     * // Update one LineItemQuote
     * const lineItemQuote = await prisma.lineItemQuote.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     **/
    update<T extends LineItemQuoteUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, LineItemQuoteUpdateArgs<ExtArgs>>
    ): Prisma__LineItemQuoteClient<
      $Result.GetResult<Prisma.$LineItemQuotePayload<ExtArgs>, T, "update">,
      never,
      ExtArgs
    >;

    /**
     * Delete zero or more LineItemQuotes.
     * @param {LineItemQuoteDeleteManyArgs} args - Arguments to filter LineItemQuotes to delete.
     * @example
     * // Delete a few LineItemQuotes
     * const { count } = await prisma.lineItemQuote.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     **/
    deleteMany<T extends LineItemQuoteDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LineItemQuoteDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more LineItemQuotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LineItemQuoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LineItemQuotes
     * const lineItemQuote = await prisma.lineItemQuote.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     **/
    updateMany<T extends LineItemQuoteUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, LineItemQuoteUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one LineItemQuote.
     * @param {LineItemQuoteUpsertArgs} args - Arguments to update or create a LineItemQuote.
     * @example
     * // Update or create a LineItemQuote
     * const lineItemQuote = await prisma.lineItemQuote.upsert({
     *   create: {
     *     // ... data to create a LineItemQuote
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LineItemQuote we want to update
     *   }
     * })
     **/
    upsert<T extends LineItemQuoteUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, LineItemQuoteUpsertArgs<ExtArgs>>
    ): Prisma__LineItemQuoteClient<
      $Result.GetResult<Prisma.$LineItemQuotePayload<ExtArgs>, T, "upsert">,
      never,
      ExtArgs
    >;

    /**
     * Count the number of LineItemQuotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LineItemQuoteCountArgs} args - Arguments to filter LineItemQuotes to count.
     * @example
     * // Count the number of LineItemQuotes
     * const count = await prisma.lineItemQuote.count({
     *   where: {
     *     // ... the filter for the LineItemQuotes we want to count
     *   }
     * })
     **/
    count<T extends LineItemQuoteCountArgs>(
      args?: Subset<T, LineItemQuoteCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], LineItemQuoteCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a LineItemQuote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LineItemQuoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends LineItemQuoteAggregateArgs>(
      args: Subset<T, LineItemQuoteAggregateArgs>
    ): Prisma.PrismaPromise<GetLineItemQuoteAggregateType<T>>;

    /**
     * Group by LineItemQuote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LineItemQuoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends LineItemQuoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LineItemQuoteGroupByArgs["orderBy"] }
        : { orderBy?: LineItemQuoteGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
        ? {
            [P in HavingFields]: P extends ByFields
              ? never
              : P extends string
              ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
              : [
                  Error,
                  "Field ",
                  P,
                  ` in "having" needs to be provided in "by"`
                ];
          }[HavingFields]
        : "take" extends Keys<T>
        ? "orderBy" extends Keys<T>
          ? ByValid extends True
            ? {}
            : {
                [P in OrderFields]: P extends ByFields
                  ? never
                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
              }[OrderFields]
          : 'Error: If you provide "take", you also need to provide "orderBy"'
        : "skip" extends Keys<T>
        ? "orderBy" extends Keys<T>
          ? ByValid extends True
            ? {}
            : {
                [P in OrderFields]: P extends ByFields
                  ? never
                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
              }[OrderFields]
          : 'Error: If you provide "skip", you also need to provide "orderBy"'
        : ByValid extends True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
          }[OrderFields]
    >(
      args: SubsetIntersection<T, LineItemQuoteGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetLineItemQuoteGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the LineItemQuote model
     */
    readonly fields: LineItemQuoteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LineItemQuote.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LineItemQuoteClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";

    quote<T extends QuotesDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, QuotesDefaultArgs<ExtArgs>>
    ): Prisma__QuotesClient<
      | $Result.GetResult<
          Prisma.$QuotesPayload<ExtArgs>,
          T,
          "findUniqueOrThrow"
        >
      | Null,
      Null,
      ExtArgs
    >;

    line_item<T extends LineItemsDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, LineItemsDefaultArgs<ExtArgs>>
    ): Prisma__LineItemsClient<
      | $Result.GetResult<
          Prisma.$LineItemsPayload<ExtArgs>,
          T,
          "findUniqueOrThrow"
        >
      | Null,
      Null,
      ExtArgs
    >;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the LineItemQuote model
   */
  interface LineItemQuoteFieldRefs {
    readonly id: FieldRef<"LineItemQuote", "Int">;
    readonly quote_id: FieldRef<"LineItemQuote", "Int">;
    readonly line_item_id: FieldRef<"LineItemQuote", "Int">;
  }

  // Custom InputTypes

  /**
   * LineItemQuote findUnique
   */
  export type LineItemQuoteFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the LineItemQuote
     */
    select?: LineItemQuoteSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LineItemQuoteInclude<ExtArgs> | null;
    /**
     * Filter, which LineItemQuote to fetch.
     */
    where: LineItemQuoteWhereUniqueInput;
  };

  /**
   * LineItemQuote findUniqueOrThrow
   */
  export type LineItemQuoteFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the LineItemQuote
     */
    select?: LineItemQuoteSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LineItemQuoteInclude<ExtArgs> | null;
    /**
     * Filter, which LineItemQuote to fetch.
     */
    where: LineItemQuoteWhereUniqueInput;
  };

  /**
   * LineItemQuote findFirst
   */
  export type LineItemQuoteFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the LineItemQuote
     */
    select?: LineItemQuoteSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LineItemQuoteInclude<ExtArgs> | null;
    /**
     * Filter, which LineItemQuote to fetch.
     */
    where?: LineItemQuoteWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of LineItemQuotes to fetch.
     */
    orderBy?:
      | LineItemQuoteOrderByWithRelationInput
      | LineItemQuoteOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for LineItemQuotes.
     */
    cursor?: LineItemQuoteWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` LineItemQuotes from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` LineItemQuotes.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of LineItemQuotes.
     */
    distinct?: LineItemQuoteScalarFieldEnum | LineItemQuoteScalarFieldEnum[];
  };

  /**
   * LineItemQuote findFirstOrThrow
   */
  export type LineItemQuoteFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the LineItemQuote
     */
    select?: LineItemQuoteSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LineItemQuoteInclude<ExtArgs> | null;
    /**
     * Filter, which LineItemQuote to fetch.
     */
    where?: LineItemQuoteWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of LineItemQuotes to fetch.
     */
    orderBy?:
      | LineItemQuoteOrderByWithRelationInput
      | LineItemQuoteOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for LineItemQuotes.
     */
    cursor?: LineItemQuoteWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` LineItemQuotes from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` LineItemQuotes.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of LineItemQuotes.
     */
    distinct?: LineItemQuoteScalarFieldEnum | LineItemQuoteScalarFieldEnum[];
  };

  /**
   * LineItemQuote findMany
   */
  export type LineItemQuoteFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the LineItemQuote
     */
    select?: LineItemQuoteSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LineItemQuoteInclude<ExtArgs> | null;
    /**
     * Filter, which LineItemQuotes to fetch.
     */
    where?: LineItemQuoteWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of LineItemQuotes to fetch.
     */
    orderBy?:
      | LineItemQuoteOrderByWithRelationInput
      | LineItemQuoteOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing LineItemQuotes.
     */
    cursor?: LineItemQuoteWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` LineItemQuotes from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` LineItemQuotes.
     */
    skip?: number;
    distinct?: LineItemQuoteScalarFieldEnum | LineItemQuoteScalarFieldEnum[];
  };

  /**
   * LineItemQuote create
   */
  export type LineItemQuoteCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the LineItemQuote
     */
    select?: LineItemQuoteSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LineItemQuoteInclude<ExtArgs> | null;
    /**
     * The data needed to create a LineItemQuote.
     */
    data: XOR<LineItemQuoteCreateInput, LineItemQuoteUncheckedCreateInput>;
  };

  /**
   * LineItemQuote createMany
   */
  export type LineItemQuoteCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many LineItemQuotes.
     */
    data: LineItemQuoteCreateManyInput | LineItemQuoteCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * LineItemQuote update
   */
  export type LineItemQuoteUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the LineItemQuote
     */
    select?: LineItemQuoteSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LineItemQuoteInclude<ExtArgs> | null;
    /**
     * The data needed to update a LineItemQuote.
     */
    data: XOR<LineItemQuoteUpdateInput, LineItemQuoteUncheckedUpdateInput>;
    /**
     * Choose, which LineItemQuote to update.
     */
    where: LineItemQuoteWhereUniqueInput;
  };

  /**
   * LineItemQuote updateMany
   */
  export type LineItemQuoteUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update LineItemQuotes.
     */
    data: XOR<
      LineItemQuoteUpdateManyMutationInput,
      LineItemQuoteUncheckedUpdateManyInput
    >;
    /**
     * Filter which LineItemQuotes to update
     */
    where?: LineItemQuoteWhereInput;
  };

  /**
   * LineItemQuote upsert
   */
  export type LineItemQuoteUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the LineItemQuote
     */
    select?: LineItemQuoteSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LineItemQuoteInclude<ExtArgs> | null;
    /**
     * The filter to search for the LineItemQuote to update in case it exists.
     */
    where: LineItemQuoteWhereUniqueInput;
    /**
     * In case the LineItemQuote found by the `where` argument doesn't exist, create a new LineItemQuote with this data.
     */
    create: XOR<LineItemQuoteCreateInput, LineItemQuoteUncheckedCreateInput>;
    /**
     * In case the LineItemQuote was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LineItemQuoteUpdateInput, LineItemQuoteUncheckedUpdateInput>;
  };

  /**
   * LineItemQuote delete
   */
  export type LineItemQuoteDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the LineItemQuote
     */
    select?: LineItemQuoteSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LineItemQuoteInclude<ExtArgs> | null;
    /**
     * Filter which LineItemQuote to delete.
     */
    where: LineItemQuoteWhereUniqueInput;
  };

  /**
   * LineItemQuote deleteMany
   */
  export type LineItemQuoteDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which LineItemQuotes to delete
     */
    where?: LineItemQuoteWhereInput;
  };

  /**
   * LineItemQuote without action
   */
  export type LineItemQuoteDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the LineItemQuote
     */
    select?: LineItemQuoteSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LineItemQuoteInclude<ExtArgs> | null;
  };

  /**
   * Model QuoteRequest
   */

  export type AggregateQuoteRequest = {
    _count: QuoteRequestCountAggregateOutputType | null;
    _avg: QuoteRequestAvgAggregateOutputType | null;
    _sum: QuoteRequestSumAggregateOutputType | null;
    _min: QuoteRequestMinAggregateOutputType | null;
    _max: QuoteRequestMaxAggregateOutputType | null;
  };

  export type QuoteRequestAvgAggregateOutputType = {
    id: number | null;
    quoteId: number | null;
    requestId: number | null;
  };

  export type QuoteRequestSumAggregateOutputType = {
    id: number | null;
    quoteId: number | null;
    requestId: number | null;
  };

  export type QuoteRequestMinAggregateOutputType = {
    id: number | null;
    quoteId: number | null;
    requestId: number | null;
  };

  export type QuoteRequestMaxAggregateOutputType = {
    id: number | null;
    quoteId: number | null;
    requestId: number | null;
  };

  export type QuoteRequestCountAggregateOutputType = {
    id: number;
    quoteId: number;
    requestId: number;
    _all: number;
  };

  export type QuoteRequestAvgAggregateInputType = {
    id?: true;
    quoteId?: true;
    requestId?: true;
  };

  export type QuoteRequestSumAggregateInputType = {
    id?: true;
    quoteId?: true;
    requestId?: true;
  };

  export type QuoteRequestMinAggregateInputType = {
    id?: true;
    quoteId?: true;
    requestId?: true;
  };

  export type QuoteRequestMaxAggregateInputType = {
    id?: true;
    quoteId?: true;
    requestId?: true;
  };

  export type QuoteRequestCountAggregateInputType = {
    id?: true;
    quoteId?: true;
    requestId?: true;
    _all?: true;
  };

  export type QuoteRequestAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which QuoteRequest to aggregate.
     */
    where?: QuoteRequestWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of QuoteRequests to fetch.
     */
    orderBy?:
      | QuoteRequestOrderByWithRelationInput
      | QuoteRequestOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: QuoteRequestWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` QuoteRequests from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` QuoteRequests.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned QuoteRequests
     **/
    _count?: true | QuoteRequestCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: QuoteRequestAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: QuoteRequestSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: QuoteRequestMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: QuoteRequestMaxAggregateInputType;
  };

  export type GetQuoteRequestAggregateType<
    T extends QuoteRequestAggregateArgs
  > = {
    [P in keyof T & keyof AggregateQuoteRequest]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuoteRequest[P]>
      : GetScalarType<T[P], AggregateQuoteRequest[P]>;
  };

  export type QuoteRequestGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: QuoteRequestWhereInput;
    orderBy?:
      | QuoteRequestOrderByWithAggregationInput
      | QuoteRequestOrderByWithAggregationInput[];
    by: QuoteRequestScalarFieldEnum[] | QuoteRequestScalarFieldEnum;
    having?: QuoteRequestScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: QuoteRequestCountAggregateInputType | true;
    _avg?: QuoteRequestAvgAggregateInputType;
    _sum?: QuoteRequestSumAggregateInputType;
    _min?: QuoteRequestMinAggregateInputType;
    _max?: QuoteRequestMaxAggregateInputType;
  };

  export type QuoteRequestGroupByOutputType = {
    id: number;
    quoteId: number;
    requestId: number;
    _count: QuoteRequestCountAggregateOutputType | null;
    _avg: QuoteRequestAvgAggregateOutputType | null;
    _sum: QuoteRequestSumAggregateOutputType | null;
    _min: QuoteRequestMinAggregateOutputType | null;
    _max: QuoteRequestMaxAggregateOutputType | null;
  };

  type GetQuoteRequestGroupByPayload<T extends QuoteRequestGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<QuoteRequestGroupByOutputType, T["by"]> & {
          [P in keyof T &
            keyof QuoteRequestGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuoteRequestGroupByOutputType[P]>
            : GetScalarType<T[P], QuoteRequestGroupByOutputType[P]>;
        }
      >
    >;

  export type QuoteRequestSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      quoteId?: boolean;
      requestId?: boolean;
      quote?: boolean | QuotesDefaultArgs<ExtArgs>;
      request?: boolean | RequestsDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["quoteRequest"]
  >;

  export type QuoteRequestSelectScalar = {
    id?: boolean;
    quoteId?: boolean;
    requestId?: boolean;
  };

  export type QuoteRequestInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    quote?: boolean | QuotesDefaultArgs<ExtArgs>;
    request?: boolean | RequestsDefaultArgs<ExtArgs>;
  };

  export type $QuoteRequestPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: "QuoteRequest";
    objects: {
      quote: Prisma.$QuotesPayload<ExtArgs>;
      request: Prisma.$RequestsPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: number;
        quoteId: number;
        requestId: number;
      },
      ExtArgs["result"]["quoteRequest"]
    >;
    composites: {};
  };

  type QuoteRequestGetPayload<
    S extends boolean | null | undefined | QuoteRequestDefaultArgs
  > = $Result.GetResult<Prisma.$QuoteRequestPayload, S>;

  type QuoteRequestCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<QuoteRequestFindManyArgs, "select" | "include" | "distinct"> & {
    select?: QuoteRequestCountAggregateInputType | true;
  };

  export interface QuoteRequestDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["QuoteRequest"];
      meta: { name: "QuoteRequest" };
    };
    /**
     * Find zero or one QuoteRequest that matches the filter.
     * @param {QuoteRequestFindUniqueArgs} args - Arguments to find a QuoteRequest
     * @example
     * // Get one QuoteRequest
     * const quoteRequest = await prisma.quoteRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     **/
    findUnique<T extends QuoteRequestFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, QuoteRequestFindUniqueArgs<ExtArgs>>
    ): Prisma__QuoteRequestClient<
      $Result.GetResult<
        Prisma.$QuoteRequestPayload<ExtArgs>,
        T,
        "findUnique"
      > | null,
      null,
      ExtArgs
    >;

    /**
     * Find one QuoteRequest that matches the filter or throw an error  with `error.code='P2025'`
     *     if no matches were found.
     * @param {QuoteRequestFindUniqueOrThrowArgs} args - Arguments to find a QuoteRequest
     * @example
     * // Get one QuoteRequest
     * const quoteRequest = await prisma.quoteRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     **/
    findUniqueOrThrow<T extends QuoteRequestFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, QuoteRequestFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__QuoteRequestClient<
      $Result.GetResult<
        Prisma.$QuoteRequestPayload<ExtArgs>,
        T,
        "findUniqueOrThrow"
      >,
      never,
      ExtArgs
    >;

    /**
     * Find the first QuoteRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteRequestFindFirstArgs} args - Arguments to find a QuoteRequest
     * @example
     * // Get one QuoteRequest
     * const quoteRequest = await prisma.quoteRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     **/
    findFirst<T extends QuoteRequestFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, QuoteRequestFindFirstArgs<ExtArgs>>
    ): Prisma__QuoteRequestClient<
      $Result.GetResult<
        Prisma.$QuoteRequestPayload<ExtArgs>,
        T,
        "findFirst"
      > | null,
      null,
      ExtArgs
    >;

    /**
     * Find the first QuoteRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteRequestFindFirstOrThrowArgs} args - Arguments to find a QuoteRequest
     * @example
     * // Get one QuoteRequest
     * const quoteRequest = await prisma.quoteRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     **/
    findFirstOrThrow<T extends QuoteRequestFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, QuoteRequestFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__QuoteRequestClient<
      $Result.GetResult<
        Prisma.$QuoteRequestPayload<ExtArgs>,
        T,
        "findFirstOrThrow"
      >,
      never,
      ExtArgs
    >;

    /**
     * Find zero or more QuoteRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteRequestFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuoteRequests
     * const quoteRequests = await prisma.quoteRequest.findMany()
     *
     * // Get first 10 QuoteRequests
     * const quoteRequests = await prisma.quoteRequest.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const quoteRequestWithIdOnly = await prisma.quoteRequest.findMany({ select: { id: true } })
     *
     **/
    findMany<T extends QuoteRequestFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, QuoteRequestFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$QuoteRequestPayload<ExtArgs>, T, "findMany">
    >;

    /**
     * Create a QuoteRequest.
     * @param {QuoteRequestCreateArgs} args - Arguments to create a QuoteRequest.
     * @example
     * // Create one QuoteRequest
     * const QuoteRequest = await prisma.quoteRequest.create({
     *   data: {
     *     // ... data to create a QuoteRequest
     *   }
     * })
     *
     **/
    create<T extends QuoteRequestCreateArgs<ExtArgs>>(
      args: SelectSubset<T, QuoteRequestCreateArgs<ExtArgs>>
    ): Prisma__QuoteRequestClient<
      $Result.GetResult<Prisma.$QuoteRequestPayload<ExtArgs>, T, "create">,
      never,
      ExtArgs
    >;

    /**
     * Create many QuoteRequests.
     *     @param {QuoteRequestCreateManyArgs} args - Arguments to create many QuoteRequests.
     *     @example
     *     // Create many QuoteRequests
     *     const quoteRequest = await prisma.quoteRequest.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *
     **/
    createMany<T extends QuoteRequestCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, QuoteRequestCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a QuoteRequest.
     * @param {QuoteRequestDeleteArgs} args - Arguments to delete one QuoteRequest.
     * @example
     * // Delete one QuoteRequest
     * const QuoteRequest = await prisma.quoteRequest.delete({
     *   where: {
     *     // ... filter to delete one QuoteRequest
     *   }
     * })
     *
     **/
    delete<T extends QuoteRequestDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, QuoteRequestDeleteArgs<ExtArgs>>
    ): Prisma__QuoteRequestClient<
      $Result.GetResult<Prisma.$QuoteRequestPayload<ExtArgs>, T, "delete">,
      never,
      ExtArgs
    >;

    /**
     * Update one QuoteRequest.
     * @param {QuoteRequestUpdateArgs} args - Arguments to update one QuoteRequest.
     * @example
     * // Update one QuoteRequest
     * const quoteRequest = await prisma.quoteRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     **/
    update<T extends QuoteRequestUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, QuoteRequestUpdateArgs<ExtArgs>>
    ): Prisma__QuoteRequestClient<
      $Result.GetResult<Prisma.$QuoteRequestPayload<ExtArgs>, T, "update">,
      never,
      ExtArgs
    >;

    /**
     * Delete zero or more QuoteRequests.
     * @param {QuoteRequestDeleteManyArgs} args - Arguments to filter QuoteRequests to delete.
     * @example
     * // Delete a few QuoteRequests
     * const { count } = await prisma.quoteRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     **/
    deleteMany<T extends QuoteRequestDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, QuoteRequestDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more QuoteRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuoteRequests
     * const quoteRequest = await prisma.quoteRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     **/
    updateMany<T extends QuoteRequestUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, QuoteRequestUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one QuoteRequest.
     * @param {QuoteRequestUpsertArgs} args - Arguments to update or create a QuoteRequest.
     * @example
     * // Update or create a QuoteRequest
     * const quoteRequest = await prisma.quoteRequest.upsert({
     *   create: {
     *     // ... data to create a QuoteRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuoteRequest we want to update
     *   }
     * })
     **/
    upsert<T extends QuoteRequestUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, QuoteRequestUpsertArgs<ExtArgs>>
    ): Prisma__QuoteRequestClient<
      $Result.GetResult<Prisma.$QuoteRequestPayload<ExtArgs>, T, "upsert">,
      never,
      ExtArgs
    >;

    /**
     * Count the number of QuoteRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteRequestCountArgs} args - Arguments to filter QuoteRequests to count.
     * @example
     * // Count the number of QuoteRequests
     * const count = await prisma.quoteRequest.count({
     *   where: {
     *     // ... the filter for the QuoteRequests we want to count
     *   }
     * })
     **/
    count<T extends QuoteRequestCountArgs>(
      args?: Subset<T, QuoteRequestCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], QuoteRequestCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a QuoteRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends QuoteRequestAggregateArgs>(
      args: Subset<T, QuoteRequestAggregateArgs>
    ): Prisma.PrismaPromise<GetQuoteRequestAggregateType<T>>;

    /**
     * Group by QuoteRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends QuoteRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuoteRequestGroupByArgs["orderBy"] }
        : { orderBy?: QuoteRequestGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
        ? {
            [P in HavingFields]: P extends ByFields
              ? never
              : P extends string
              ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
              : [
                  Error,
                  "Field ",
                  P,
                  ` in "having" needs to be provided in "by"`
                ];
          }[HavingFields]
        : "take" extends Keys<T>
        ? "orderBy" extends Keys<T>
          ? ByValid extends True
            ? {}
            : {
                [P in OrderFields]: P extends ByFields
                  ? never
                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
              }[OrderFields]
          : 'Error: If you provide "take", you also need to provide "orderBy"'
        : "skip" extends Keys<T>
        ? "orderBy" extends Keys<T>
          ? ByValid extends True
            ? {}
            : {
                [P in OrderFields]: P extends ByFields
                  ? never
                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
              }[OrderFields]
          : 'Error: If you provide "skip", you also need to provide "orderBy"'
        : ByValid extends True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
          }[OrderFields]
    >(
      args: SubsetIntersection<T, QuoteRequestGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetQuoteRequestGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the QuoteRequest model
     */
    readonly fields: QuoteRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuoteRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuoteRequestClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";

    quote<T extends QuotesDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, QuotesDefaultArgs<ExtArgs>>
    ): Prisma__QuotesClient<
      | $Result.GetResult<
          Prisma.$QuotesPayload<ExtArgs>,
          T,
          "findUniqueOrThrow"
        >
      | Null,
      Null,
      ExtArgs
    >;

    request<T extends RequestsDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, RequestsDefaultArgs<ExtArgs>>
    ): Prisma__RequestsClient<
      | $Result.GetResult<
          Prisma.$RequestsPayload<ExtArgs>,
          T,
          "findUniqueOrThrow"
        >
      | Null,
      Null,
      ExtArgs
    >;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the QuoteRequest model
   */
  interface QuoteRequestFieldRefs {
    readonly id: FieldRef<"QuoteRequest", "Int">;
    readonly quoteId: FieldRef<"QuoteRequest", "Int">;
    readonly requestId: FieldRef<"QuoteRequest", "Int">;
  }

  // Custom InputTypes

  /**
   * QuoteRequest findUnique
   */
  export type QuoteRequestFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the QuoteRequest
     */
    select?: QuoteRequestSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuoteRequestInclude<ExtArgs> | null;
    /**
     * Filter, which QuoteRequest to fetch.
     */
    where: QuoteRequestWhereUniqueInput;
  };

  /**
   * QuoteRequest findUniqueOrThrow
   */
  export type QuoteRequestFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the QuoteRequest
     */
    select?: QuoteRequestSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuoteRequestInclude<ExtArgs> | null;
    /**
     * Filter, which QuoteRequest to fetch.
     */
    where: QuoteRequestWhereUniqueInput;
  };

  /**
   * QuoteRequest findFirst
   */
  export type QuoteRequestFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the QuoteRequest
     */
    select?: QuoteRequestSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuoteRequestInclude<ExtArgs> | null;
    /**
     * Filter, which QuoteRequest to fetch.
     */
    where?: QuoteRequestWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of QuoteRequests to fetch.
     */
    orderBy?:
      | QuoteRequestOrderByWithRelationInput
      | QuoteRequestOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for QuoteRequests.
     */
    cursor?: QuoteRequestWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` QuoteRequests from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` QuoteRequests.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of QuoteRequests.
     */
    distinct?: QuoteRequestScalarFieldEnum | QuoteRequestScalarFieldEnum[];
  };

  /**
   * QuoteRequest findFirstOrThrow
   */
  export type QuoteRequestFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the QuoteRequest
     */
    select?: QuoteRequestSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuoteRequestInclude<ExtArgs> | null;
    /**
     * Filter, which QuoteRequest to fetch.
     */
    where?: QuoteRequestWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of QuoteRequests to fetch.
     */
    orderBy?:
      | QuoteRequestOrderByWithRelationInput
      | QuoteRequestOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for QuoteRequests.
     */
    cursor?: QuoteRequestWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` QuoteRequests from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` QuoteRequests.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of QuoteRequests.
     */
    distinct?: QuoteRequestScalarFieldEnum | QuoteRequestScalarFieldEnum[];
  };

  /**
   * QuoteRequest findMany
   */
  export type QuoteRequestFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the QuoteRequest
     */
    select?: QuoteRequestSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuoteRequestInclude<ExtArgs> | null;
    /**
     * Filter, which QuoteRequests to fetch.
     */
    where?: QuoteRequestWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of QuoteRequests to fetch.
     */
    orderBy?:
      | QuoteRequestOrderByWithRelationInput
      | QuoteRequestOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing QuoteRequests.
     */
    cursor?: QuoteRequestWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` QuoteRequests from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` QuoteRequests.
     */
    skip?: number;
    distinct?: QuoteRequestScalarFieldEnum | QuoteRequestScalarFieldEnum[];
  };

  /**
   * QuoteRequest create
   */
  export type QuoteRequestCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the QuoteRequest
     */
    select?: QuoteRequestSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuoteRequestInclude<ExtArgs> | null;
    /**
     * The data needed to create a QuoteRequest.
     */
    data: XOR<QuoteRequestCreateInput, QuoteRequestUncheckedCreateInput>;
  };

  /**
   * QuoteRequest createMany
   */
  export type QuoteRequestCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many QuoteRequests.
     */
    data: QuoteRequestCreateManyInput | QuoteRequestCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * QuoteRequest update
   */
  export type QuoteRequestUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the QuoteRequest
     */
    select?: QuoteRequestSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuoteRequestInclude<ExtArgs> | null;
    /**
     * The data needed to update a QuoteRequest.
     */
    data: XOR<QuoteRequestUpdateInput, QuoteRequestUncheckedUpdateInput>;
    /**
     * Choose, which QuoteRequest to update.
     */
    where: QuoteRequestWhereUniqueInput;
  };

  /**
   * QuoteRequest updateMany
   */
  export type QuoteRequestUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update QuoteRequests.
     */
    data: XOR<
      QuoteRequestUpdateManyMutationInput,
      QuoteRequestUncheckedUpdateManyInput
    >;
    /**
     * Filter which QuoteRequests to update
     */
    where?: QuoteRequestWhereInput;
  };

  /**
   * QuoteRequest upsert
   */
  export type QuoteRequestUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the QuoteRequest
     */
    select?: QuoteRequestSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuoteRequestInclude<ExtArgs> | null;
    /**
     * The filter to search for the QuoteRequest to update in case it exists.
     */
    where: QuoteRequestWhereUniqueInput;
    /**
     * In case the QuoteRequest found by the `where` argument doesn't exist, create a new QuoteRequest with this data.
     */
    create: XOR<QuoteRequestCreateInput, QuoteRequestUncheckedCreateInput>;
    /**
     * In case the QuoteRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuoteRequestUpdateInput, QuoteRequestUncheckedUpdateInput>;
  };

  /**
   * QuoteRequest delete
   */
  export type QuoteRequestDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the QuoteRequest
     */
    select?: QuoteRequestSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuoteRequestInclude<ExtArgs> | null;
    /**
     * Filter which QuoteRequest to delete.
     */
    where: QuoteRequestWhereUniqueInput;
  };

  /**
   * QuoteRequest deleteMany
   */
  export type QuoteRequestDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which QuoteRequests to delete
     */
    where?: QuoteRequestWhereInput;
  };

  /**
   * QuoteRequest without action
   */
  export type QuoteRequestDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the QuoteRequest
     */
    select?: QuoteRequestSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuoteRequestInclude<ExtArgs> | null;
  };

  /**
   * Model Jobs
   */

  export type AggregateJobs = {
    _count: JobsCountAggregateOutputType | null;
    _avg: JobsAvgAggregateOutputType | null;
    _sum: JobsSumAggregateOutputType | null;
    _min: JobsMinAggregateOutputType | null;
    _max: JobsMaxAggregateOutputType | null;
  };

  export type JobsAvgAggregateOutputType = {
    id: number | null;
    client_id: number | null;
    belongs_to_id: number | null;
  };

  export type JobsSumAggregateOutputType = {
    id: number | null;
    client_id: number | null;
    belongs_to_id: number | null;
  };

  export type JobsMinAggregateOutputType = {
    id: number | null;
    emailed_to_client: boolean | null;
    texted_to_client: boolean | null;
    status: string | null;
    client_id: number | null;
    title: string | null;
    instructions: string | null;
    number: string | null;
    schedule_type: string | null;
    recurring_frequency: string | null;
    recurring_interval: string | null;
    day_of_week: string | null;
    day_of_year: string | null;
    duration: string | null;
    start_date: Date | null;
    end_date: Date | null;
    start_time: Date | null;
    end_time: Date | null;
    schedule_later: boolean | null;
    team: string | null;
    email_team: boolean | null;
    invoice_reminder: boolean | null;
    internal_notes: string | null;
    internal_attachment_url: string | null;
    link_to_related_invoices: boolean | null;
    belongs_to_id: number | null;
  };

  export type JobsMaxAggregateOutputType = {
    id: number | null;
    emailed_to_client: boolean | null;
    texted_to_client: boolean | null;
    status: string | null;
    client_id: number | null;
    title: string | null;
    instructions: string | null;
    number: string | null;
    schedule_type: string | null;
    recurring_frequency: string | null;
    recurring_interval: string | null;
    day_of_week: string | null;
    day_of_year: string | null;
    duration: string | null;
    start_date: Date | null;
    end_date: Date | null;
    start_time: Date | null;
    end_time: Date | null;
    schedule_later: boolean | null;
    team: string | null;
    email_team: boolean | null;
    invoice_reminder: boolean | null;
    internal_notes: string | null;
    internal_attachment_url: string | null;
    link_to_related_invoices: boolean | null;
    belongs_to_id: number | null;
  };

  export type JobsCountAggregateOutputType = {
    id: number;
    tags: number;
    emailed_to_client: number;
    texted_to_client: number;
    status: number;
    client_id: number;
    title: number;
    instructions: number;
    number: number;
    schedule_type: number;
    recurring_frequency: number;
    recurring_interval: number;
    day_of_week: number;
    day_of_year: number;
    duration: number;
    start_date: number;
    end_date: number;
    start_time: number;
    end_time: number;
    schedule_later: number;
    team: number;
    email_team: number;
    invoice_reminder: number;
    internal_notes: number;
    internal_attachment_url: number;
    link_to_related_invoices: number;
    belongs_to_id: number;
    _all: number;
  };

  export type JobsAvgAggregateInputType = {
    id?: true;
    client_id?: true;
    belongs_to_id?: true;
  };

  export type JobsSumAggregateInputType = {
    id?: true;
    client_id?: true;
    belongs_to_id?: true;
  };

  export type JobsMinAggregateInputType = {
    id?: true;
    emailed_to_client?: true;
    texted_to_client?: true;
    status?: true;
    client_id?: true;
    title?: true;
    instructions?: true;
    number?: true;
    schedule_type?: true;
    recurring_frequency?: true;
    recurring_interval?: true;
    day_of_week?: true;
    day_of_year?: true;
    duration?: true;
    start_date?: true;
    end_date?: true;
    start_time?: true;
    end_time?: true;
    schedule_later?: true;
    team?: true;
    email_team?: true;
    invoice_reminder?: true;
    internal_notes?: true;
    internal_attachment_url?: true;
    link_to_related_invoices?: true;
    belongs_to_id?: true;
  };

  export type JobsMaxAggregateInputType = {
    id?: true;
    emailed_to_client?: true;
    texted_to_client?: true;
    status?: true;
    client_id?: true;
    title?: true;
    instructions?: true;
    number?: true;
    schedule_type?: true;
    recurring_frequency?: true;
    recurring_interval?: true;
    day_of_week?: true;
    day_of_year?: true;
    duration?: true;
    start_date?: true;
    end_date?: true;
    start_time?: true;
    end_time?: true;
    schedule_later?: true;
    team?: true;
    email_team?: true;
    invoice_reminder?: true;
    internal_notes?: true;
    internal_attachment_url?: true;
    link_to_related_invoices?: true;
    belongs_to_id?: true;
  };

  export type JobsCountAggregateInputType = {
    id?: true;
    tags?: true;
    emailed_to_client?: true;
    texted_to_client?: true;
    status?: true;
    client_id?: true;
    title?: true;
    instructions?: true;
    number?: true;
    schedule_type?: true;
    recurring_frequency?: true;
    recurring_interval?: true;
    day_of_week?: true;
    day_of_year?: true;
    duration?: true;
    start_date?: true;
    end_date?: true;
    start_time?: true;
    end_time?: true;
    schedule_later?: true;
    team?: true;
    email_team?: true;
    invoice_reminder?: true;
    internal_notes?: true;
    internal_attachment_url?: true;
    link_to_related_invoices?: true;
    belongs_to_id?: true;
    _all?: true;
  };

  export type JobsAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which Jobs to aggregate.
     */
    where?: JobsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Jobs to fetch.
     */
    orderBy?: JobsOrderByWithRelationInput | JobsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: JobsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Jobs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Jobs.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Jobs
     **/
    _count?: true | JobsCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: JobsAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: JobsSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: JobsMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: JobsMaxAggregateInputType;
  };

  export type GetJobsAggregateType<T extends JobsAggregateArgs> = {
    [P in keyof T & keyof AggregateJobs]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJobs[P]>
      : GetScalarType<T[P], AggregateJobs[P]>;
  };

  export type JobsGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: JobsWhereInput;
    orderBy?:
      | JobsOrderByWithAggregationInput
      | JobsOrderByWithAggregationInput[];
    by: JobsScalarFieldEnum[] | JobsScalarFieldEnum;
    having?: JobsScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: JobsCountAggregateInputType | true;
    _avg?: JobsAvgAggregateInputType;
    _sum?: JobsSumAggregateInputType;
    _min?: JobsMinAggregateInputType;
    _max?: JobsMaxAggregateInputType;
  };

  export type JobsGroupByOutputType = {
    id: number;
    tags: JsonValue | null;
    emailed_to_client: boolean;
    texted_to_client: boolean;
    status: string;
    client_id: number;
    title: string;
    instructions: string | null;
    number: string;
    schedule_type: string;
    recurring_frequency: string | null;
    recurring_interval: string | null;
    day_of_week: string | null;
    day_of_year: string | null;
    duration: string | null;
    start_date: Date | null;
    end_date: Date | null;
    start_time: Date | null;
    end_time: Date | null;
    schedule_later: boolean;
    team: string | null;
    email_team: boolean;
    invoice_reminder: boolean;
    internal_notes: string | null;
    internal_attachment_url: string | null;
    link_to_related_invoices: boolean;
    belongs_to_id: number;
    _count: JobsCountAggregateOutputType | null;
    _avg: JobsAvgAggregateOutputType | null;
    _sum: JobsSumAggregateOutputType | null;
    _min: JobsMinAggregateOutputType | null;
    _max: JobsMaxAggregateOutputType | null;
  };

  type GetJobsGroupByPayload<T extends JobsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JobsGroupByOutputType, T["by"]> & {
        [P in keyof T & keyof JobsGroupByOutputType]: P extends "_count"
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], JobsGroupByOutputType[P]>
          : GetScalarType<T[P], JobsGroupByOutputType[P]>;
      }
    >
  >;

  export type JobsSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      tags?: boolean;
      emailed_to_client?: boolean;
      texted_to_client?: boolean;
      status?: boolean;
      client_id?: boolean;
      title?: boolean;
      instructions?: boolean;
      number?: boolean;
      schedule_type?: boolean;
      recurring_frequency?: boolean;
      recurring_interval?: boolean;
      day_of_week?: boolean;
      day_of_year?: boolean;
      duration?: boolean;
      start_date?: boolean;
      end_date?: boolean;
      start_time?: boolean;
      end_time?: boolean;
      schedule_later?: boolean;
      team?: boolean;
      email_team?: boolean;
      invoice_reminder?: boolean;
      internal_notes?: boolean;
      internal_attachment_url?: boolean;
      link_to_related_invoices?: boolean;
      belongs_to_id?: boolean;
      client?: boolean | ClientsDefaultArgs<ExtArgs>;
      line_items?: boolean | Jobs$line_itemsArgs<ExtArgs>;
      job_requests?: boolean | Jobs$job_requestsArgs<ExtArgs>;
      job_quotes?: boolean | Jobs$job_quotesArgs<ExtArgs>;
      invoices?: boolean | Jobs$invoicesArgs<ExtArgs>;
      belongs_to?: boolean | UsersDefaultArgs<ExtArgs>;
      _count?: boolean | JobsCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["jobs"]
  >;

  export type JobsSelectScalar = {
    id?: boolean;
    tags?: boolean;
    emailed_to_client?: boolean;
    texted_to_client?: boolean;
    status?: boolean;
    client_id?: boolean;
    title?: boolean;
    instructions?: boolean;
    number?: boolean;
    schedule_type?: boolean;
    recurring_frequency?: boolean;
    recurring_interval?: boolean;
    day_of_week?: boolean;
    day_of_year?: boolean;
    duration?: boolean;
    start_date?: boolean;
    end_date?: boolean;
    start_time?: boolean;
    end_time?: boolean;
    schedule_later?: boolean;
    team?: boolean;
    email_team?: boolean;
    invoice_reminder?: boolean;
    internal_notes?: boolean;
    internal_attachment_url?: boolean;
    link_to_related_invoices?: boolean;
    belongs_to_id?: boolean;
  };

  export type JobsInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    client?: boolean | ClientsDefaultArgs<ExtArgs>;
    line_items?: boolean | Jobs$line_itemsArgs<ExtArgs>;
    job_requests?: boolean | Jobs$job_requestsArgs<ExtArgs>;
    job_quotes?: boolean | Jobs$job_quotesArgs<ExtArgs>;
    invoices?: boolean | Jobs$invoicesArgs<ExtArgs>;
    belongs_to?: boolean | UsersDefaultArgs<ExtArgs>;
    _count?: boolean | JobsCountOutputTypeDefaultArgs<ExtArgs>;
  };

  export type $JobsPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: "Jobs";
    objects: {
      client: Prisma.$ClientsPayload<ExtArgs>;
      line_items: Prisma.$LineItemJobPayload<ExtArgs>[];
      job_requests: Prisma.$JobRequestPayload<ExtArgs>[];
      job_quotes: Prisma.$JobQuotePayload<ExtArgs>[];
      invoices: Prisma.$InvoicesPayload<ExtArgs>[];
      belongs_to: Prisma.$UsersPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: number;
        tags: Prisma.JsonValue | null;
        emailed_to_client: boolean;
        texted_to_client: boolean;
        status: string;
        client_id: number;
        title: string;
        instructions: string | null;
        number: string;
        schedule_type: string;
        recurring_frequency: string | null;
        recurring_interval: string | null;
        day_of_week: string | null;
        day_of_year: string | null;
        duration: string | null;
        start_date: Date | null;
        end_date: Date | null;
        start_time: Date | null;
        end_time: Date | null;
        schedule_later: boolean;
        team: string | null;
        email_team: boolean;
        invoice_reminder: boolean;
        internal_notes: string | null;
        internal_attachment_url: string | null;
        link_to_related_invoices: boolean;
        belongs_to_id: number;
      },
      ExtArgs["result"]["jobs"]
    >;
    composites: {};
  };

  type JobsGetPayload<S extends boolean | null | undefined | JobsDefaultArgs> =
    $Result.GetResult<Prisma.$JobsPayload, S>;

  type JobsCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<JobsFindManyArgs, "select" | "include" | "distinct"> & {
    select?: JobsCountAggregateInputType | true;
  };

  export interface JobsDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["Jobs"];
      meta: { name: "Jobs" };
    };
    /**
     * Find zero or one Jobs that matches the filter.
     * @param {JobsFindUniqueArgs} args - Arguments to find a Jobs
     * @example
     * // Get one Jobs
     * const jobs = await prisma.jobs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     **/
    findUnique<T extends JobsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, JobsFindUniqueArgs<ExtArgs>>
    ): Prisma__JobsClient<
      $Result.GetResult<Prisma.$JobsPayload<ExtArgs>, T, "findUnique"> | null,
      null,
      ExtArgs
    >;

    /**
     * Find one Jobs that matches the filter or throw an error  with `error.code='P2025'`
     *     if no matches were found.
     * @param {JobsFindUniqueOrThrowArgs} args - Arguments to find a Jobs
     * @example
     * // Get one Jobs
     * const jobs = await prisma.jobs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     **/
    findUniqueOrThrow<T extends JobsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, JobsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__JobsClient<
      $Result.GetResult<Prisma.$JobsPayload<ExtArgs>, T, "findUniqueOrThrow">,
      never,
      ExtArgs
    >;

    /**
     * Find the first Jobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobsFindFirstArgs} args - Arguments to find a Jobs
     * @example
     * // Get one Jobs
     * const jobs = await prisma.jobs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     **/
    findFirst<T extends JobsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, JobsFindFirstArgs<ExtArgs>>
    ): Prisma__JobsClient<
      $Result.GetResult<Prisma.$JobsPayload<ExtArgs>, T, "findFirst"> | null,
      null,
      ExtArgs
    >;

    /**
     * Find the first Jobs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobsFindFirstOrThrowArgs} args - Arguments to find a Jobs
     * @example
     * // Get one Jobs
     * const jobs = await prisma.jobs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     **/
    findFirstOrThrow<T extends JobsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, JobsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__JobsClient<
      $Result.GetResult<Prisma.$JobsPayload<ExtArgs>, T, "findFirstOrThrow">,
      never,
      ExtArgs
    >;

    /**
     * Find zero or more Jobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Jobs
     * const jobs = await prisma.jobs.findMany()
     *
     * // Get first 10 Jobs
     * const jobs = await prisma.jobs.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const jobsWithIdOnly = await prisma.jobs.findMany({ select: { id: true } })
     *
     **/
    findMany<T extends JobsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, JobsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$JobsPayload<ExtArgs>, T, "findMany">
    >;

    /**
     * Create a Jobs.
     * @param {JobsCreateArgs} args - Arguments to create a Jobs.
     * @example
     * // Create one Jobs
     * const Jobs = await prisma.jobs.create({
     *   data: {
     *     // ... data to create a Jobs
     *   }
     * })
     *
     **/
    create<T extends JobsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, JobsCreateArgs<ExtArgs>>
    ): Prisma__JobsClient<
      $Result.GetResult<Prisma.$JobsPayload<ExtArgs>, T, "create">,
      never,
      ExtArgs
    >;

    /**
     * Create many Jobs.
     *     @param {JobsCreateManyArgs} args - Arguments to create many Jobs.
     *     @example
     *     // Create many Jobs
     *     const jobs = await prisma.jobs.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *
     **/
    createMany<T extends JobsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, JobsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a Jobs.
     * @param {JobsDeleteArgs} args - Arguments to delete one Jobs.
     * @example
     * // Delete one Jobs
     * const Jobs = await prisma.jobs.delete({
     *   where: {
     *     // ... filter to delete one Jobs
     *   }
     * })
     *
     **/
    delete<T extends JobsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, JobsDeleteArgs<ExtArgs>>
    ): Prisma__JobsClient<
      $Result.GetResult<Prisma.$JobsPayload<ExtArgs>, T, "delete">,
      never,
      ExtArgs
    >;

    /**
     * Update one Jobs.
     * @param {JobsUpdateArgs} args - Arguments to update one Jobs.
     * @example
     * // Update one Jobs
     * const jobs = await prisma.jobs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     **/
    update<T extends JobsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, JobsUpdateArgs<ExtArgs>>
    ): Prisma__JobsClient<
      $Result.GetResult<Prisma.$JobsPayload<ExtArgs>, T, "update">,
      never,
      ExtArgs
    >;

    /**
     * Delete zero or more Jobs.
     * @param {JobsDeleteManyArgs} args - Arguments to filter Jobs to delete.
     * @example
     * // Delete a few Jobs
     * const { count } = await prisma.jobs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     **/
    deleteMany<T extends JobsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, JobsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Jobs
     * const jobs = await prisma.jobs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     **/
    updateMany<T extends JobsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, JobsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one Jobs.
     * @param {JobsUpsertArgs} args - Arguments to update or create a Jobs.
     * @example
     * // Update or create a Jobs
     * const jobs = await prisma.jobs.upsert({
     *   create: {
     *     // ... data to create a Jobs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Jobs we want to update
     *   }
     * })
     **/
    upsert<T extends JobsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, JobsUpsertArgs<ExtArgs>>
    ): Prisma__JobsClient<
      $Result.GetResult<Prisma.$JobsPayload<ExtArgs>, T, "upsert">,
      never,
      ExtArgs
    >;

    /**
     * Count the number of Jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobsCountArgs} args - Arguments to filter Jobs to count.
     * @example
     * // Count the number of Jobs
     * const count = await prisma.jobs.count({
     *   where: {
     *     // ... the filter for the Jobs we want to count
     *   }
     * })
     **/
    count<T extends JobsCountArgs>(
      args?: Subset<T, JobsCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], JobsCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends JobsAggregateArgs>(
      args: Subset<T, JobsAggregateArgs>
    ): Prisma.PrismaPromise<GetJobsAggregateType<T>>;

    /**
     * Group by Jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends JobsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JobsGroupByArgs["orderBy"] }
        : { orderBy?: JobsGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
        ? {
            [P in HavingFields]: P extends ByFields
              ? never
              : P extends string
              ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
              : [
                  Error,
                  "Field ",
                  P,
                  ` in "having" needs to be provided in "by"`
                ];
          }[HavingFields]
        : "take" extends Keys<T>
        ? "orderBy" extends Keys<T>
          ? ByValid extends True
            ? {}
            : {
                [P in OrderFields]: P extends ByFields
                  ? never
                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
              }[OrderFields]
          : 'Error: If you provide "take", you also need to provide "orderBy"'
        : "skip" extends Keys<T>
        ? "orderBy" extends Keys<T>
          ? ByValid extends True
            ? {}
            : {
                [P in OrderFields]: P extends ByFields
                  ? never
                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
              }[OrderFields]
          : 'Error: If you provide "skip", you also need to provide "orderBy"'
        : ByValid extends True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
          }[OrderFields]
    >(
      args: SubsetIntersection<T, JobsGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetJobsGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Jobs model
     */
    readonly fields: JobsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Jobs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JobsClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";

    client<T extends ClientsDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, ClientsDefaultArgs<ExtArgs>>
    ): Prisma__ClientsClient<
      | $Result.GetResult<
          Prisma.$ClientsPayload<ExtArgs>,
          T,
          "findUniqueOrThrow"
        >
      | Null,
      Null,
      ExtArgs
    >;

    line_items<T extends Jobs$line_itemsArgs<ExtArgs> = {}>(
      args?: Subset<T, Jobs$line_itemsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<Prisma.$LineItemJobPayload<ExtArgs>, T, "findMany">
      | Null
    >;

    job_requests<T extends Jobs$job_requestsArgs<ExtArgs> = {}>(
      args?: Subset<T, Jobs$job_requestsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<Prisma.$JobRequestPayload<ExtArgs>, T, "findMany">
      | Null
    >;

    job_quotes<T extends Jobs$job_quotesArgs<ExtArgs> = {}>(
      args?: Subset<T, Jobs$job_quotesArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$JobQuotePayload<ExtArgs>, T, "findMany"> | Null
    >;

    invoices<T extends Jobs$invoicesArgs<ExtArgs> = {}>(
      args?: Subset<T, Jobs$invoicesArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$InvoicesPayload<ExtArgs>, T, "findMany"> | Null
    >;

    belongs_to<T extends UsersDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UsersDefaultArgs<ExtArgs>>
    ): Prisma__UsersClient<
      | $Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow">
      | Null,
      Null,
      ExtArgs
    >;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Jobs model
   */
  interface JobsFieldRefs {
    readonly id: FieldRef<"Jobs", "Int">;
    readonly tags: FieldRef<"Jobs", "Json">;
    readonly emailed_to_client: FieldRef<"Jobs", "Boolean">;
    readonly texted_to_client: FieldRef<"Jobs", "Boolean">;
    readonly status: FieldRef<"Jobs", "String">;
    readonly client_id: FieldRef<"Jobs", "Int">;
    readonly title: FieldRef<"Jobs", "String">;
    readonly instructions: FieldRef<"Jobs", "String">;
    readonly number: FieldRef<"Jobs", "String">;
    readonly schedule_type: FieldRef<"Jobs", "String">;
    readonly recurring_frequency: FieldRef<"Jobs", "String">;
    readonly recurring_interval: FieldRef<"Jobs", "String">;
    readonly day_of_week: FieldRef<"Jobs", "String">;
    readonly day_of_year: FieldRef<"Jobs", "String">;
    readonly duration: FieldRef<"Jobs", "String">;
    readonly start_date: FieldRef<"Jobs", "DateTime">;
    readonly end_date: FieldRef<"Jobs", "DateTime">;
    readonly start_time: FieldRef<"Jobs", "DateTime">;
    readonly end_time: FieldRef<"Jobs", "DateTime">;
    readonly schedule_later: FieldRef<"Jobs", "Boolean">;
    readonly team: FieldRef<"Jobs", "String">;
    readonly email_team: FieldRef<"Jobs", "Boolean">;
    readonly invoice_reminder: FieldRef<"Jobs", "Boolean">;
    readonly internal_notes: FieldRef<"Jobs", "String">;
    readonly internal_attachment_url: FieldRef<"Jobs", "String">;
    readonly link_to_related_invoices: FieldRef<"Jobs", "Boolean">;
    readonly belongs_to_id: FieldRef<"Jobs", "Int">;
  }

  // Custom InputTypes

  /**
   * Jobs findUnique
   */
  export type JobsFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Jobs
     */
    select?: JobsSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobsInclude<ExtArgs> | null;
    /**
     * Filter, which Jobs to fetch.
     */
    where: JobsWhereUniqueInput;
  };

  /**
   * Jobs findUniqueOrThrow
   */
  export type JobsFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Jobs
     */
    select?: JobsSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobsInclude<ExtArgs> | null;
    /**
     * Filter, which Jobs to fetch.
     */
    where: JobsWhereUniqueInput;
  };

  /**
   * Jobs findFirst
   */
  export type JobsFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Jobs
     */
    select?: JobsSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobsInclude<ExtArgs> | null;
    /**
     * Filter, which Jobs to fetch.
     */
    where?: JobsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Jobs to fetch.
     */
    orderBy?: JobsOrderByWithRelationInput | JobsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Jobs.
     */
    cursor?: JobsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Jobs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Jobs.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Jobs.
     */
    distinct?: JobsScalarFieldEnum | JobsScalarFieldEnum[];
  };

  /**
   * Jobs findFirstOrThrow
   */
  export type JobsFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Jobs
     */
    select?: JobsSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobsInclude<ExtArgs> | null;
    /**
     * Filter, which Jobs to fetch.
     */
    where?: JobsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Jobs to fetch.
     */
    orderBy?: JobsOrderByWithRelationInput | JobsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Jobs.
     */
    cursor?: JobsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Jobs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Jobs.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Jobs.
     */
    distinct?: JobsScalarFieldEnum | JobsScalarFieldEnum[];
  };

  /**
   * Jobs findMany
   */
  export type JobsFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Jobs
     */
    select?: JobsSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobsInclude<ExtArgs> | null;
    /**
     * Filter, which Jobs to fetch.
     */
    where?: JobsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Jobs to fetch.
     */
    orderBy?: JobsOrderByWithRelationInput | JobsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Jobs.
     */
    cursor?: JobsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Jobs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Jobs.
     */
    skip?: number;
    distinct?: JobsScalarFieldEnum | JobsScalarFieldEnum[];
  };

  /**
   * Jobs create
   */
  export type JobsCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Jobs
     */
    select?: JobsSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobsInclude<ExtArgs> | null;
    /**
     * The data needed to create a Jobs.
     */
    data: XOR<JobsCreateInput, JobsUncheckedCreateInput>;
  };

  /**
   * Jobs createMany
   */
  export type JobsCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many Jobs.
     */
    data: JobsCreateManyInput | JobsCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Jobs update
   */
  export type JobsUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Jobs
     */
    select?: JobsSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobsInclude<ExtArgs> | null;
    /**
     * The data needed to update a Jobs.
     */
    data: XOR<JobsUpdateInput, JobsUncheckedUpdateInput>;
    /**
     * Choose, which Jobs to update.
     */
    where: JobsWhereUniqueInput;
  };

  /**
   * Jobs updateMany
   */
  export type JobsUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update Jobs.
     */
    data: XOR<JobsUpdateManyMutationInput, JobsUncheckedUpdateManyInput>;
    /**
     * Filter which Jobs to update
     */
    where?: JobsWhereInput;
  };

  /**
   * Jobs upsert
   */
  export type JobsUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Jobs
     */
    select?: JobsSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobsInclude<ExtArgs> | null;
    /**
     * The filter to search for the Jobs to update in case it exists.
     */
    where: JobsWhereUniqueInput;
    /**
     * In case the Jobs found by the `where` argument doesn't exist, create a new Jobs with this data.
     */
    create: XOR<JobsCreateInput, JobsUncheckedCreateInput>;
    /**
     * In case the Jobs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JobsUpdateInput, JobsUncheckedUpdateInput>;
  };

  /**
   * Jobs delete
   */
  export type JobsDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Jobs
     */
    select?: JobsSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobsInclude<ExtArgs> | null;
    /**
     * Filter which Jobs to delete.
     */
    where: JobsWhereUniqueInput;
  };

  /**
   * Jobs deleteMany
   */
  export type JobsDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which Jobs to delete
     */
    where?: JobsWhereInput;
  };

  /**
   * Jobs.line_items
   */
  export type Jobs$line_itemsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the LineItemJob
     */
    select?: LineItemJobSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LineItemJobInclude<ExtArgs> | null;
    where?: LineItemJobWhereInput;
    orderBy?:
      | LineItemJobOrderByWithRelationInput
      | LineItemJobOrderByWithRelationInput[];
    cursor?: LineItemJobWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: LineItemJobScalarFieldEnum | LineItemJobScalarFieldEnum[];
  };

  /**
   * Jobs.job_requests
   */
  export type Jobs$job_requestsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the JobRequest
     */
    select?: JobRequestSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobRequestInclude<ExtArgs> | null;
    where?: JobRequestWhereInput;
    orderBy?:
      | JobRequestOrderByWithRelationInput
      | JobRequestOrderByWithRelationInput[];
    cursor?: JobRequestWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: JobRequestScalarFieldEnum | JobRequestScalarFieldEnum[];
  };

  /**
   * Jobs.job_quotes
   */
  export type Jobs$job_quotesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the JobQuote
     */
    select?: JobQuoteSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobQuoteInclude<ExtArgs> | null;
    where?: JobQuoteWhereInput;
    orderBy?:
      | JobQuoteOrderByWithRelationInput
      | JobQuoteOrderByWithRelationInput[];
    cursor?: JobQuoteWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: JobQuoteScalarFieldEnum | JobQuoteScalarFieldEnum[];
  };

  /**
   * Jobs.invoices
   */
  export type Jobs$invoicesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Invoices
     */
    select?: InvoicesSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvoicesInclude<ExtArgs> | null;
    where?: InvoicesWhereInput;
    orderBy?:
      | InvoicesOrderByWithRelationInput
      | InvoicesOrderByWithRelationInput[];
    cursor?: InvoicesWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: InvoicesScalarFieldEnum | InvoicesScalarFieldEnum[];
  };

  /**
   * Jobs without action
   */
  export type JobsDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Jobs
     */
    select?: JobsSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobsInclude<ExtArgs> | null;
  };

  /**
   * Model LineItemJob
   */

  export type AggregateLineItemJob = {
    _count: LineItemJobCountAggregateOutputType | null;
    _avg: LineItemJobAvgAggregateOutputType | null;
    _sum: LineItemJobSumAggregateOutputType | null;
    _min: LineItemJobMinAggregateOutputType | null;
    _max: LineItemJobMaxAggregateOutputType | null;
  };

  export type LineItemJobAvgAggregateOutputType = {
    id: number | null;
    job_id: number | null;
    line_item_id: number | null;
  };

  export type LineItemJobSumAggregateOutputType = {
    id: number | null;
    job_id: number | null;
    line_item_id: number | null;
  };

  export type LineItemJobMinAggregateOutputType = {
    id: number | null;
    job_id: number | null;
    line_item_id: number | null;
  };

  export type LineItemJobMaxAggregateOutputType = {
    id: number | null;
    job_id: number | null;
    line_item_id: number | null;
  };

  export type LineItemJobCountAggregateOutputType = {
    id: number;
    job_id: number;
    line_item_id: number;
    _all: number;
  };

  export type LineItemJobAvgAggregateInputType = {
    id?: true;
    job_id?: true;
    line_item_id?: true;
  };

  export type LineItemJobSumAggregateInputType = {
    id?: true;
    job_id?: true;
    line_item_id?: true;
  };

  export type LineItemJobMinAggregateInputType = {
    id?: true;
    job_id?: true;
    line_item_id?: true;
  };

  export type LineItemJobMaxAggregateInputType = {
    id?: true;
    job_id?: true;
    line_item_id?: true;
  };

  export type LineItemJobCountAggregateInputType = {
    id?: true;
    job_id?: true;
    line_item_id?: true;
    _all?: true;
  };

  export type LineItemJobAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which LineItemJob to aggregate.
     */
    where?: LineItemJobWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of LineItemJobs to fetch.
     */
    orderBy?:
      | LineItemJobOrderByWithRelationInput
      | LineItemJobOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: LineItemJobWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` LineItemJobs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` LineItemJobs.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned LineItemJobs
     **/
    _count?: true | LineItemJobCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: LineItemJobAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: LineItemJobSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: LineItemJobMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: LineItemJobMaxAggregateInputType;
  };

  export type GetLineItemJobAggregateType<T extends LineItemJobAggregateArgs> =
    {
      [P in keyof T & keyof AggregateLineItemJob]: P extends "_count" | "count"
        ? T[P] extends true
          ? number
          : GetScalarType<T[P], AggregateLineItemJob[P]>
        : GetScalarType<T[P], AggregateLineItemJob[P]>;
    };

  export type LineItemJobGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: LineItemJobWhereInput;
    orderBy?:
      | LineItemJobOrderByWithAggregationInput
      | LineItemJobOrderByWithAggregationInput[];
    by: LineItemJobScalarFieldEnum[] | LineItemJobScalarFieldEnum;
    having?: LineItemJobScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: LineItemJobCountAggregateInputType | true;
    _avg?: LineItemJobAvgAggregateInputType;
    _sum?: LineItemJobSumAggregateInputType;
    _min?: LineItemJobMinAggregateInputType;
    _max?: LineItemJobMaxAggregateInputType;
  };

  export type LineItemJobGroupByOutputType = {
    id: number;
    job_id: number;
    line_item_id: number;
    _count: LineItemJobCountAggregateOutputType | null;
    _avg: LineItemJobAvgAggregateOutputType | null;
    _sum: LineItemJobSumAggregateOutputType | null;
    _min: LineItemJobMinAggregateOutputType | null;
    _max: LineItemJobMaxAggregateOutputType | null;
  };

  type GetLineItemJobGroupByPayload<T extends LineItemJobGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<LineItemJobGroupByOutputType, T["by"]> & {
          [P in keyof T &
            keyof LineItemJobGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LineItemJobGroupByOutputType[P]>
            : GetScalarType<T[P], LineItemJobGroupByOutputType[P]>;
        }
      >
    >;

  export type LineItemJobSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      job_id?: boolean;
      line_item_id?: boolean;
      job?: boolean | JobsDefaultArgs<ExtArgs>;
      line_item?: boolean | LineItemsDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["lineItemJob"]
  >;

  export type LineItemJobSelectScalar = {
    id?: boolean;
    job_id?: boolean;
    line_item_id?: boolean;
  };

  export type LineItemJobInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    job?: boolean | JobsDefaultArgs<ExtArgs>;
    line_item?: boolean | LineItemsDefaultArgs<ExtArgs>;
  };

  export type $LineItemJobPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: "LineItemJob";
    objects: {
      job: Prisma.$JobsPayload<ExtArgs>;
      line_item: Prisma.$LineItemsPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: number;
        job_id: number;
        line_item_id: number;
      },
      ExtArgs["result"]["lineItemJob"]
    >;
    composites: {};
  };

  type LineItemJobGetPayload<
    S extends boolean | null | undefined | LineItemJobDefaultArgs
  > = $Result.GetResult<Prisma.$LineItemJobPayload, S>;

  type LineItemJobCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<LineItemJobFindManyArgs, "select" | "include" | "distinct"> & {
    select?: LineItemJobCountAggregateInputType | true;
  };

  export interface LineItemJobDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["LineItemJob"];
      meta: { name: "LineItemJob" };
    };
    /**
     * Find zero or one LineItemJob that matches the filter.
     * @param {LineItemJobFindUniqueArgs} args - Arguments to find a LineItemJob
     * @example
     * // Get one LineItemJob
     * const lineItemJob = await prisma.lineItemJob.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     **/
    findUnique<T extends LineItemJobFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, LineItemJobFindUniqueArgs<ExtArgs>>
    ): Prisma__LineItemJobClient<
      $Result.GetResult<
        Prisma.$LineItemJobPayload<ExtArgs>,
        T,
        "findUnique"
      > | null,
      null,
      ExtArgs
    >;

    /**
     * Find one LineItemJob that matches the filter or throw an error  with `error.code='P2025'`
     *     if no matches were found.
     * @param {LineItemJobFindUniqueOrThrowArgs} args - Arguments to find a LineItemJob
     * @example
     * // Get one LineItemJob
     * const lineItemJob = await prisma.lineItemJob.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     **/
    findUniqueOrThrow<T extends LineItemJobFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LineItemJobFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__LineItemJobClient<
      $Result.GetResult<
        Prisma.$LineItemJobPayload<ExtArgs>,
        T,
        "findUniqueOrThrow"
      >,
      never,
      ExtArgs
    >;

    /**
     * Find the first LineItemJob that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LineItemJobFindFirstArgs} args - Arguments to find a LineItemJob
     * @example
     * // Get one LineItemJob
     * const lineItemJob = await prisma.lineItemJob.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     **/
    findFirst<T extends LineItemJobFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, LineItemJobFindFirstArgs<ExtArgs>>
    ): Prisma__LineItemJobClient<
      $Result.GetResult<
        Prisma.$LineItemJobPayload<ExtArgs>,
        T,
        "findFirst"
      > | null,
      null,
      ExtArgs
    >;

    /**
     * Find the first LineItemJob that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LineItemJobFindFirstOrThrowArgs} args - Arguments to find a LineItemJob
     * @example
     * // Get one LineItemJob
     * const lineItemJob = await prisma.lineItemJob.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     **/
    findFirstOrThrow<T extends LineItemJobFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LineItemJobFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__LineItemJobClient<
      $Result.GetResult<
        Prisma.$LineItemJobPayload<ExtArgs>,
        T,
        "findFirstOrThrow"
      >,
      never,
      ExtArgs
    >;

    /**
     * Find zero or more LineItemJobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LineItemJobFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LineItemJobs
     * const lineItemJobs = await prisma.lineItemJob.findMany()
     *
     * // Get first 10 LineItemJobs
     * const lineItemJobs = await prisma.lineItemJob.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const lineItemJobWithIdOnly = await prisma.lineItemJob.findMany({ select: { id: true } })
     *
     **/
    findMany<T extends LineItemJobFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LineItemJobFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$LineItemJobPayload<ExtArgs>, T, "findMany">
    >;

    /**
     * Create a LineItemJob.
     * @param {LineItemJobCreateArgs} args - Arguments to create a LineItemJob.
     * @example
     * // Create one LineItemJob
     * const LineItemJob = await prisma.lineItemJob.create({
     *   data: {
     *     // ... data to create a LineItemJob
     *   }
     * })
     *
     **/
    create<T extends LineItemJobCreateArgs<ExtArgs>>(
      args: SelectSubset<T, LineItemJobCreateArgs<ExtArgs>>
    ): Prisma__LineItemJobClient<
      $Result.GetResult<Prisma.$LineItemJobPayload<ExtArgs>, T, "create">,
      never,
      ExtArgs
    >;

    /**
     * Create many LineItemJobs.
     *     @param {LineItemJobCreateManyArgs} args - Arguments to create many LineItemJobs.
     *     @example
     *     // Create many LineItemJobs
     *     const lineItemJob = await prisma.lineItemJob.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *
     **/
    createMany<T extends LineItemJobCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LineItemJobCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a LineItemJob.
     * @param {LineItemJobDeleteArgs} args - Arguments to delete one LineItemJob.
     * @example
     * // Delete one LineItemJob
     * const LineItemJob = await prisma.lineItemJob.delete({
     *   where: {
     *     // ... filter to delete one LineItemJob
     *   }
     * })
     *
     **/
    delete<T extends LineItemJobDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, LineItemJobDeleteArgs<ExtArgs>>
    ): Prisma__LineItemJobClient<
      $Result.GetResult<Prisma.$LineItemJobPayload<ExtArgs>, T, "delete">,
      never,
      ExtArgs
    >;

    /**
     * Update one LineItemJob.
     * @param {LineItemJobUpdateArgs} args - Arguments to update one LineItemJob.
     * @example
     * // Update one LineItemJob
     * const lineItemJob = await prisma.lineItemJob.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     **/
    update<T extends LineItemJobUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, LineItemJobUpdateArgs<ExtArgs>>
    ): Prisma__LineItemJobClient<
      $Result.GetResult<Prisma.$LineItemJobPayload<ExtArgs>, T, "update">,
      never,
      ExtArgs
    >;

    /**
     * Delete zero or more LineItemJobs.
     * @param {LineItemJobDeleteManyArgs} args - Arguments to filter LineItemJobs to delete.
     * @example
     * // Delete a few LineItemJobs
     * const { count } = await prisma.lineItemJob.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     **/
    deleteMany<T extends LineItemJobDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LineItemJobDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more LineItemJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LineItemJobUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LineItemJobs
     * const lineItemJob = await prisma.lineItemJob.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     **/
    updateMany<T extends LineItemJobUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, LineItemJobUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one LineItemJob.
     * @param {LineItemJobUpsertArgs} args - Arguments to update or create a LineItemJob.
     * @example
     * // Update or create a LineItemJob
     * const lineItemJob = await prisma.lineItemJob.upsert({
     *   create: {
     *     // ... data to create a LineItemJob
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LineItemJob we want to update
     *   }
     * })
     **/
    upsert<T extends LineItemJobUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, LineItemJobUpsertArgs<ExtArgs>>
    ): Prisma__LineItemJobClient<
      $Result.GetResult<Prisma.$LineItemJobPayload<ExtArgs>, T, "upsert">,
      never,
      ExtArgs
    >;

    /**
     * Count the number of LineItemJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LineItemJobCountArgs} args - Arguments to filter LineItemJobs to count.
     * @example
     * // Count the number of LineItemJobs
     * const count = await prisma.lineItemJob.count({
     *   where: {
     *     // ... the filter for the LineItemJobs we want to count
     *   }
     * })
     **/
    count<T extends LineItemJobCountArgs>(
      args?: Subset<T, LineItemJobCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], LineItemJobCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a LineItemJob.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LineItemJobAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends LineItemJobAggregateArgs>(
      args: Subset<T, LineItemJobAggregateArgs>
    ): Prisma.PrismaPromise<GetLineItemJobAggregateType<T>>;

    /**
     * Group by LineItemJob.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LineItemJobGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends LineItemJobGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LineItemJobGroupByArgs["orderBy"] }
        : { orderBy?: LineItemJobGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
        ? {
            [P in HavingFields]: P extends ByFields
              ? never
              : P extends string
              ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
              : [
                  Error,
                  "Field ",
                  P,
                  ` in "having" needs to be provided in "by"`
                ];
          }[HavingFields]
        : "take" extends Keys<T>
        ? "orderBy" extends Keys<T>
          ? ByValid extends True
            ? {}
            : {
                [P in OrderFields]: P extends ByFields
                  ? never
                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
              }[OrderFields]
          : 'Error: If you provide "take", you also need to provide "orderBy"'
        : "skip" extends Keys<T>
        ? "orderBy" extends Keys<T>
          ? ByValid extends True
            ? {}
            : {
                [P in OrderFields]: P extends ByFields
                  ? never
                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
              }[OrderFields]
          : 'Error: If you provide "skip", you also need to provide "orderBy"'
        : ByValid extends True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
          }[OrderFields]
    >(
      args: SubsetIntersection<T, LineItemJobGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetLineItemJobGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the LineItemJob model
     */
    readonly fields: LineItemJobFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LineItemJob.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LineItemJobClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";

    job<T extends JobsDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, JobsDefaultArgs<ExtArgs>>
    ): Prisma__JobsClient<
      | $Result.GetResult<Prisma.$JobsPayload<ExtArgs>, T, "findUniqueOrThrow">
      | Null,
      Null,
      ExtArgs
    >;

    line_item<T extends LineItemsDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, LineItemsDefaultArgs<ExtArgs>>
    ): Prisma__LineItemsClient<
      | $Result.GetResult<
          Prisma.$LineItemsPayload<ExtArgs>,
          T,
          "findUniqueOrThrow"
        >
      | Null,
      Null,
      ExtArgs
    >;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the LineItemJob model
   */
  interface LineItemJobFieldRefs {
    readonly id: FieldRef<"LineItemJob", "Int">;
    readonly job_id: FieldRef<"LineItemJob", "Int">;
    readonly line_item_id: FieldRef<"LineItemJob", "Int">;
  }

  // Custom InputTypes

  /**
   * LineItemJob findUnique
   */
  export type LineItemJobFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the LineItemJob
     */
    select?: LineItemJobSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LineItemJobInclude<ExtArgs> | null;
    /**
     * Filter, which LineItemJob to fetch.
     */
    where: LineItemJobWhereUniqueInput;
  };

  /**
   * LineItemJob findUniqueOrThrow
   */
  export type LineItemJobFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the LineItemJob
     */
    select?: LineItemJobSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LineItemJobInclude<ExtArgs> | null;
    /**
     * Filter, which LineItemJob to fetch.
     */
    where: LineItemJobWhereUniqueInput;
  };

  /**
   * LineItemJob findFirst
   */
  export type LineItemJobFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the LineItemJob
     */
    select?: LineItemJobSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LineItemJobInclude<ExtArgs> | null;
    /**
     * Filter, which LineItemJob to fetch.
     */
    where?: LineItemJobWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of LineItemJobs to fetch.
     */
    orderBy?:
      | LineItemJobOrderByWithRelationInput
      | LineItemJobOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for LineItemJobs.
     */
    cursor?: LineItemJobWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` LineItemJobs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` LineItemJobs.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of LineItemJobs.
     */
    distinct?: LineItemJobScalarFieldEnum | LineItemJobScalarFieldEnum[];
  };

  /**
   * LineItemJob findFirstOrThrow
   */
  export type LineItemJobFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the LineItemJob
     */
    select?: LineItemJobSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LineItemJobInclude<ExtArgs> | null;
    /**
     * Filter, which LineItemJob to fetch.
     */
    where?: LineItemJobWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of LineItemJobs to fetch.
     */
    orderBy?:
      | LineItemJobOrderByWithRelationInput
      | LineItemJobOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for LineItemJobs.
     */
    cursor?: LineItemJobWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` LineItemJobs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` LineItemJobs.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of LineItemJobs.
     */
    distinct?: LineItemJobScalarFieldEnum | LineItemJobScalarFieldEnum[];
  };

  /**
   * LineItemJob findMany
   */
  export type LineItemJobFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the LineItemJob
     */
    select?: LineItemJobSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LineItemJobInclude<ExtArgs> | null;
    /**
     * Filter, which LineItemJobs to fetch.
     */
    where?: LineItemJobWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of LineItemJobs to fetch.
     */
    orderBy?:
      | LineItemJobOrderByWithRelationInput
      | LineItemJobOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing LineItemJobs.
     */
    cursor?: LineItemJobWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` LineItemJobs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` LineItemJobs.
     */
    skip?: number;
    distinct?: LineItemJobScalarFieldEnum | LineItemJobScalarFieldEnum[];
  };

  /**
   * LineItemJob create
   */
  export type LineItemJobCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the LineItemJob
     */
    select?: LineItemJobSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LineItemJobInclude<ExtArgs> | null;
    /**
     * The data needed to create a LineItemJob.
     */
    data: XOR<LineItemJobCreateInput, LineItemJobUncheckedCreateInput>;
  };

  /**
   * LineItemJob createMany
   */
  export type LineItemJobCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many LineItemJobs.
     */
    data: LineItemJobCreateManyInput | LineItemJobCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * LineItemJob update
   */
  export type LineItemJobUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the LineItemJob
     */
    select?: LineItemJobSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LineItemJobInclude<ExtArgs> | null;
    /**
     * The data needed to update a LineItemJob.
     */
    data: XOR<LineItemJobUpdateInput, LineItemJobUncheckedUpdateInput>;
    /**
     * Choose, which LineItemJob to update.
     */
    where: LineItemJobWhereUniqueInput;
  };

  /**
   * LineItemJob updateMany
   */
  export type LineItemJobUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update LineItemJobs.
     */
    data: XOR<
      LineItemJobUpdateManyMutationInput,
      LineItemJobUncheckedUpdateManyInput
    >;
    /**
     * Filter which LineItemJobs to update
     */
    where?: LineItemJobWhereInput;
  };

  /**
   * LineItemJob upsert
   */
  export type LineItemJobUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the LineItemJob
     */
    select?: LineItemJobSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LineItemJobInclude<ExtArgs> | null;
    /**
     * The filter to search for the LineItemJob to update in case it exists.
     */
    where: LineItemJobWhereUniqueInput;
    /**
     * In case the LineItemJob found by the `where` argument doesn't exist, create a new LineItemJob with this data.
     */
    create: XOR<LineItemJobCreateInput, LineItemJobUncheckedCreateInput>;
    /**
     * In case the LineItemJob was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LineItemJobUpdateInput, LineItemJobUncheckedUpdateInput>;
  };

  /**
   * LineItemJob delete
   */
  export type LineItemJobDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the LineItemJob
     */
    select?: LineItemJobSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LineItemJobInclude<ExtArgs> | null;
    /**
     * Filter which LineItemJob to delete.
     */
    where: LineItemJobWhereUniqueInput;
  };

  /**
   * LineItemJob deleteMany
   */
  export type LineItemJobDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which LineItemJobs to delete
     */
    where?: LineItemJobWhereInput;
  };

  /**
   * LineItemJob without action
   */
  export type LineItemJobDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the LineItemJob
     */
    select?: LineItemJobSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LineItemJobInclude<ExtArgs> | null;
  };

  /**
   * Model JobRequest
   */

  export type AggregateJobRequest = {
    _count: JobRequestCountAggregateOutputType | null;
    _avg: JobRequestAvgAggregateOutputType | null;
    _sum: JobRequestSumAggregateOutputType | null;
    _min: JobRequestMinAggregateOutputType | null;
    _max: JobRequestMaxAggregateOutputType | null;
  };

  export type JobRequestAvgAggregateOutputType = {
    id: number | null;
    job_id: number | null;
    request_id: number | null;
  };

  export type JobRequestSumAggregateOutputType = {
    id: number | null;
    job_id: number | null;
    request_id: number | null;
  };

  export type JobRequestMinAggregateOutputType = {
    id: number | null;
    job_id: number | null;
    request_id: number | null;
  };

  export type JobRequestMaxAggregateOutputType = {
    id: number | null;
    job_id: number | null;
    request_id: number | null;
  };

  export type JobRequestCountAggregateOutputType = {
    id: number;
    job_id: number;
    request_id: number;
    _all: number;
  };

  export type JobRequestAvgAggregateInputType = {
    id?: true;
    job_id?: true;
    request_id?: true;
  };

  export type JobRequestSumAggregateInputType = {
    id?: true;
    job_id?: true;
    request_id?: true;
  };

  export type JobRequestMinAggregateInputType = {
    id?: true;
    job_id?: true;
    request_id?: true;
  };

  export type JobRequestMaxAggregateInputType = {
    id?: true;
    job_id?: true;
    request_id?: true;
  };

  export type JobRequestCountAggregateInputType = {
    id?: true;
    job_id?: true;
    request_id?: true;
    _all?: true;
  };

  export type JobRequestAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which JobRequest to aggregate.
     */
    where?: JobRequestWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of JobRequests to fetch.
     */
    orderBy?:
      | JobRequestOrderByWithRelationInput
      | JobRequestOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: JobRequestWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` JobRequests from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` JobRequests.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned JobRequests
     **/
    _count?: true | JobRequestCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: JobRequestAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: JobRequestSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: JobRequestMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: JobRequestMaxAggregateInputType;
  };

  export type GetJobRequestAggregateType<T extends JobRequestAggregateArgs> = {
    [P in keyof T & keyof AggregateJobRequest]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJobRequest[P]>
      : GetScalarType<T[P], AggregateJobRequest[P]>;
  };

  export type JobRequestGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: JobRequestWhereInput;
    orderBy?:
      | JobRequestOrderByWithAggregationInput
      | JobRequestOrderByWithAggregationInput[];
    by: JobRequestScalarFieldEnum[] | JobRequestScalarFieldEnum;
    having?: JobRequestScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: JobRequestCountAggregateInputType | true;
    _avg?: JobRequestAvgAggregateInputType;
    _sum?: JobRequestSumAggregateInputType;
    _min?: JobRequestMinAggregateInputType;
    _max?: JobRequestMaxAggregateInputType;
  };

  export type JobRequestGroupByOutputType = {
    id: number;
    job_id: number;
    request_id: number;
    _count: JobRequestCountAggregateOutputType | null;
    _avg: JobRequestAvgAggregateOutputType | null;
    _sum: JobRequestSumAggregateOutputType | null;
    _min: JobRequestMinAggregateOutputType | null;
    _max: JobRequestMaxAggregateOutputType | null;
  };

  type GetJobRequestGroupByPayload<T extends JobRequestGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<JobRequestGroupByOutputType, T["by"]> & {
          [P in keyof T & keyof JobRequestGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JobRequestGroupByOutputType[P]>
            : GetScalarType<T[P], JobRequestGroupByOutputType[P]>;
        }
      >
    >;

  export type JobRequestSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      job_id?: boolean;
      request_id?: boolean;
      job?: boolean | JobsDefaultArgs<ExtArgs>;
      request?: boolean | RequestsDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["jobRequest"]
  >;

  export type JobRequestSelectScalar = {
    id?: boolean;
    job_id?: boolean;
    request_id?: boolean;
  };

  export type JobRequestInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    job?: boolean | JobsDefaultArgs<ExtArgs>;
    request?: boolean | RequestsDefaultArgs<ExtArgs>;
  };

  export type $JobRequestPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: "JobRequest";
    objects: {
      job: Prisma.$JobsPayload<ExtArgs>;
      request: Prisma.$RequestsPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: number;
        job_id: number;
        request_id: number;
      },
      ExtArgs["result"]["jobRequest"]
    >;
    composites: {};
  };

  type JobRequestGetPayload<
    S extends boolean | null | undefined | JobRequestDefaultArgs
  > = $Result.GetResult<Prisma.$JobRequestPayload, S>;

  type JobRequestCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<JobRequestFindManyArgs, "select" | "include" | "distinct"> & {
    select?: JobRequestCountAggregateInputType | true;
  };

  export interface JobRequestDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["JobRequest"];
      meta: { name: "JobRequest" };
    };
    /**
     * Find zero or one JobRequest that matches the filter.
     * @param {JobRequestFindUniqueArgs} args - Arguments to find a JobRequest
     * @example
     * // Get one JobRequest
     * const jobRequest = await prisma.jobRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     **/
    findUnique<T extends JobRequestFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, JobRequestFindUniqueArgs<ExtArgs>>
    ): Prisma__JobRequestClient<
      $Result.GetResult<
        Prisma.$JobRequestPayload<ExtArgs>,
        T,
        "findUnique"
      > | null,
      null,
      ExtArgs
    >;

    /**
     * Find one JobRequest that matches the filter or throw an error  with `error.code='P2025'`
     *     if no matches were found.
     * @param {JobRequestFindUniqueOrThrowArgs} args - Arguments to find a JobRequest
     * @example
     * // Get one JobRequest
     * const jobRequest = await prisma.jobRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     **/
    findUniqueOrThrow<T extends JobRequestFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, JobRequestFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__JobRequestClient<
      $Result.GetResult<
        Prisma.$JobRequestPayload<ExtArgs>,
        T,
        "findUniqueOrThrow"
      >,
      never,
      ExtArgs
    >;

    /**
     * Find the first JobRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobRequestFindFirstArgs} args - Arguments to find a JobRequest
     * @example
     * // Get one JobRequest
     * const jobRequest = await prisma.jobRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     **/
    findFirst<T extends JobRequestFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, JobRequestFindFirstArgs<ExtArgs>>
    ): Prisma__JobRequestClient<
      $Result.GetResult<
        Prisma.$JobRequestPayload<ExtArgs>,
        T,
        "findFirst"
      > | null,
      null,
      ExtArgs
    >;

    /**
     * Find the first JobRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobRequestFindFirstOrThrowArgs} args - Arguments to find a JobRequest
     * @example
     * // Get one JobRequest
     * const jobRequest = await prisma.jobRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     **/
    findFirstOrThrow<T extends JobRequestFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, JobRequestFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__JobRequestClient<
      $Result.GetResult<
        Prisma.$JobRequestPayload<ExtArgs>,
        T,
        "findFirstOrThrow"
      >,
      never,
      ExtArgs
    >;

    /**
     * Find zero or more JobRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobRequestFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JobRequests
     * const jobRequests = await prisma.jobRequest.findMany()
     *
     * // Get first 10 JobRequests
     * const jobRequests = await prisma.jobRequest.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const jobRequestWithIdOnly = await prisma.jobRequest.findMany({ select: { id: true } })
     *
     **/
    findMany<T extends JobRequestFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, JobRequestFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$JobRequestPayload<ExtArgs>, T, "findMany">
    >;

    /**
     * Create a JobRequest.
     * @param {JobRequestCreateArgs} args - Arguments to create a JobRequest.
     * @example
     * // Create one JobRequest
     * const JobRequest = await prisma.jobRequest.create({
     *   data: {
     *     // ... data to create a JobRequest
     *   }
     * })
     *
     **/
    create<T extends JobRequestCreateArgs<ExtArgs>>(
      args: SelectSubset<T, JobRequestCreateArgs<ExtArgs>>
    ): Prisma__JobRequestClient<
      $Result.GetResult<Prisma.$JobRequestPayload<ExtArgs>, T, "create">,
      never,
      ExtArgs
    >;

    /**
     * Create many JobRequests.
     *     @param {JobRequestCreateManyArgs} args - Arguments to create many JobRequests.
     *     @example
     *     // Create many JobRequests
     *     const jobRequest = await prisma.jobRequest.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *
     **/
    createMany<T extends JobRequestCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, JobRequestCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a JobRequest.
     * @param {JobRequestDeleteArgs} args - Arguments to delete one JobRequest.
     * @example
     * // Delete one JobRequest
     * const JobRequest = await prisma.jobRequest.delete({
     *   where: {
     *     // ... filter to delete one JobRequest
     *   }
     * })
     *
     **/
    delete<T extends JobRequestDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, JobRequestDeleteArgs<ExtArgs>>
    ): Prisma__JobRequestClient<
      $Result.GetResult<Prisma.$JobRequestPayload<ExtArgs>, T, "delete">,
      never,
      ExtArgs
    >;

    /**
     * Update one JobRequest.
     * @param {JobRequestUpdateArgs} args - Arguments to update one JobRequest.
     * @example
     * // Update one JobRequest
     * const jobRequest = await prisma.jobRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     **/
    update<T extends JobRequestUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, JobRequestUpdateArgs<ExtArgs>>
    ): Prisma__JobRequestClient<
      $Result.GetResult<Prisma.$JobRequestPayload<ExtArgs>, T, "update">,
      never,
      ExtArgs
    >;

    /**
     * Delete zero or more JobRequests.
     * @param {JobRequestDeleteManyArgs} args - Arguments to filter JobRequests to delete.
     * @example
     * // Delete a few JobRequests
     * const { count } = await prisma.jobRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     **/
    deleteMany<T extends JobRequestDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, JobRequestDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more JobRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JobRequests
     * const jobRequest = await prisma.jobRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     **/
    updateMany<T extends JobRequestUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, JobRequestUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one JobRequest.
     * @param {JobRequestUpsertArgs} args - Arguments to update or create a JobRequest.
     * @example
     * // Update or create a JobRequest
     * const jobRequest = await prisma.jobRequest.upsert({
     *   create: {
     *     // ... data to create a JobRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JobRequest we want to update
     *   }
     * })
     **/
    upsert<T extends JobRequestUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, JobRequestUpsertArgs<ExtArgs>>
    ): Prisma__JobRequestClient<
      $Result.GetResult<Prisma.$JobRequestPayload<ExtArgs>, T, "upsert">,
      never,
      ExtArgs
    >;

    /**
     * Count the number of JobRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobRequestCountArgs} args - Arguments to filter JobRequests to count.
     * @example
     * // Count the number of JobRequests
     * const count = await prisma.jobRequest.count({
     *   where: {
     *     // ... the filter for the JobRequests we want to count
     *   }
     * })
     **/
    count<T extends JobRequestCountArgs>(
      args?: Subset<T, JobRequestCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], JobRequestCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a JobRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends JobRequestAggregateArgs>(
      args: Subset<T, JobRequestAggregateArgs>
    ): Prisma.PrismaPromise<GetJobRequestAggregateType<T>>;

    /**
     * Group by JobRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends JobRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JobRequestGroupByArgs["orderBy"] }
        : { orderBy?: JobRequestGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
        ? {
            [P in HavingFields]: P extends ByFields
              ? never
              : P extends string
              ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
              : [
                  Error,
                  "Field ",
                  P,
                  ` in "having" needs to be provided in "by"`
                ];
          }[HavingFields]
        : "take" extends Keys<T>
        ? "orderBy" extends Keys<T>
          ? ByValid extends True
            ? {}
            : {
                [P in OrderFields]: P extends ByFields
                  ? never
                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
              }[OrderFields]
          : 'Error: If you provide "take", you also need to provide "orderBy"'
        : "skip" extends Keys<T>
        ? "orderBy" extends Keys<T>
          ? ByValid extends True
            ? {}
            : {
                [P in OrderFields]: P extends ByFields
                  ? never
                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
              }[OrderFields]
          : 'Error: If you provide "skip", you also need to provide "orderBy"'
        : ByValid extends True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
          }[OrderFields]
    >(
      args: SubsetIntersection<T, JobRequestGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetJobRequestGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the JobRequest model
     */
    readonly fields: JobRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JobRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JobRequestClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";

    job<T extends JobsDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, JobsDefaultArgs<ExtArgs>>
    ): Prisma__JobsClient<
      | $Result.GetResult<Prisma.$JobsPayload<ExtArgs>, T, "findUniqueOrThrow">
      | Null,
      Null,
      ExtArgs
    >;

    request<T extends RequestsDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, RequestsDefaultArgs<ExtArgs>>
    ): Prisma__RequestsClient<
      | $Result.GetResult<
          Prisma.$RequestsPayload<ExtArgs>,
          T,
          "findUniqueOrThrow"
        >
      | Null,
      Null,
      ExtArgs
    >;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the JobRequest model
   */
  interface JobRequestFieldRefs {
    readonly id: FieldRef<"JobRequest", "Int">;
    readonly job_id: FieldRef<"JobRequest", "Int">;
    readonly request_id: FieldRef<"JobRequest", "Int">;
  }

  // Custom InputTypes

  /**
   * JobRequest findUnique
   */
  export type JobRequestFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the JobRequest
     */
    select?: JobRequestSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobRequestInclude<ExtArgs> | null;
    /**
     * Filter, which JobRequest to fetch.
     */
    where: JobRequestWhereUniqueInput;
  };

  /**
   * JobRequest findUniqueOrThrow
   */
  export type JobRequestFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the JobRequest
     */
    select?: JobRequestSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobRequestInclude<ExtArgs> | null;
    /**
     * Filter, which JobRequest to fetch.
     */
    where: JobRequestWhereUniqueInput;
  };

  /**
   * JobRequest findFirst
   */
  export type JobRequestFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the JobRequest
     */
    select?: JobRequestSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobRequestInclude<ExtArgs> | null;
    /**
     * Filter, which JobRequest to fetch.
     */
    where?: JobRequestWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of JobRequests to fetch.
     */
    orderBy?:
      | JobRequestOrderByWithRelationInput
      | JobRequestOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for JobRequests.
     */
    cursor?: JobRequestWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` JobRequests from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` JobRequests.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of JobRequests.
     */
    distinct?: JobRequestScalarFieldEnum | JobRequestScalarFieldEnum[];
  };

  /**
   * JobRequest findFirstOrThrow
   */
  export type JobRequestFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the JobRequest
     */
    select?: JobRequestSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobRequestInclude<ExtArgs> | null;
    /**
     * Filter, which JobRequest to fetch.
     */
    where?: JobRequestWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of JobRequests to fetch.
     */
    orderBy?:
      | JobRequestOrderByWithRelationInput
      | JobRequestOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for JobRequests.
     */
    cursor?: JobRequestWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` JobRequests from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` JobRequests.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of JobRequests.
     */
    distinct?: JobRequestScalarFieldEnum | JobRequestScalarFieldEnum[];
  };

  /**
   * JobRequest findMany
   */
  export type JobRequestFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the JobRequest
     */
    select?: JobRequestSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobRequestInclude<ExtArgs> | null;
    /**
     * Filter, which JobRequests to fetch.
     */
    where?: JobRequestWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of JobRequests to fetch.
     */
    orderBy?:
      | JobRequestOrderByWithRelationInput
      | JobRequestOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing JobRequests.
     */
    cursor?: JobRequestWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` JobRequests from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` JobRequests.
     */
    skip?: number;
    distinct?: JobRequestScalarFieldEnum | JobRequestScalarFieldEnum[];
  };

  /**
   * JobRequest create
   */
  export type JobRequestCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the JobRequest
     */
    select?: JobRequestSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobRequestInclude<ExtArgs> | null;
    /**
     * The data needed to create a JobRequest.
     */
    data: XOR<JobRequestCreateInput, JobRequestUncheckedCreateInput>;
  };

  /**
   * JobRequest createMany
   */
  export type JobRequestCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many JobRequests.
     */
    data: JobRequestCreateManyInput | JobRequestCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * JobRequest update
   */
  export type JobRequestUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the JobRequest
     */
    select?: JobRequestSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobRequestInclude<ExtArgs> | null;
    /**
     * The data needed to update a JobRequest.
     */
    data: XOR<JobRequestUpdateInput, JobRequestUncheckedUpdateInput>;
    /**
     * Choose, which JobRequest to update.
     */
    where: JobRequestWhereUniqueInput;
  };

  /**
   * JobRequest updateMany
   */
  export type JobRequestUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update JobRequests.
     */
    data: XOR<
      JobRequestUpdateManyMutationInput,
      JobRequestUncheckedUpdateManyInput
    >;
    /**
     * Filter which JobRequests to update
     */
    where?: JobRequestWhereInput;
  };

  /**
   * JobRequest upsert
   */
  export type JobRequestUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the JobRequest
     */
    select?: JobRequestSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobRequestInclude<ExtArgs> | null;
    /**
     * The filter to search for the JobRequest to update in case it exists.
     */
    where: JobRequestWhereUniqueInput;
    /**
     * In case the JobRequest found by the `where` argument doesn't exist, create a new JobRequest with this data.
     */
    create: XOR<JobRequestCreateInput, JobRequestUncheckedCreateInput>;
    /**
     * In case the JobRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JobRequestUpdateInput, JobRequestUncheckedUpdateInput>;
  };

  /**
   * JobRequest delete
   */
  export type JobRequestDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the JobRequest
     */
    select?: JobRequestSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobRequestInclude<ExtArgs> | null;
    /**
     * Filter which JobRequest to delete.
     */
    where: JobRequestWhereUniqueInput;
  };

  /**
   * JobRequest deleteMany
   */
  export type JobRequestDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which JobRequests to delete
     */
    where?: JobRequestWhereInput;
  };

  /**
   * JobRequest without action
   */
  export type JobRequestDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the JobRequest
     */
    select?: JobRequestSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobRequestInclude<ExtArgs> | null;
  };

  /**
   * Model JobQuote
   */

  export type AggregateJobQuote = {
    _count: JobQuoteCountAggregateOutputType | null;
    _avg: JobQuoteAvgAggregateOutputType | null;
    _sum: JobQuoteSumAggregateOutputType | null;
    _min: JobQuoteMinAggregateOutputType | null;
    _max: JobQuoteMaxAggregateOutputType | null;
  };

  export type JobQuoteAvgAggregateOutputType = {
    id: number | null;
    job_id: number | null;
    quote_id: number | null;
  };

  export type JobQuoteSumAggregateOutputType = {
    id: number | null;
    job_id: number | null;
    quote_id: number | null;
  };

  export type JobQuoteMinAggregateOutputType = {
    id: number | null;
    job_id: number | null;
    quote_id: number | null;
  };

  export type JobQuoteMaxAggregateOutputType = {
    id: number | null;
    job_id: number | null;
    quote_id: number | null;
  };

  export type JobQuoteCountAggregateOutputType = {
    id: number;
    job_id: number;
    quote_id: number;
    _all: number;
  };

  export type JobQuoteAvgAggregateInputType = {
    id?: true;
    job_id?: true;
    quote_id?: true;
  };

  export type JobQuoteSumAggregateInputType = {
    id?: true;
    job_id?: true;
    quote_id?: true;
  };

  export type JobQuoteMinAggregateInputType = {
    id?: true;
    job_id?: true;
    quote_id?: true;
  };

  export type JobQuoteMaxAggregateInputType = {
    id?: true;
    job_id?: true;
    quote_id?: true;
  };

  export type JobQuoteCountAggregateInputType = {
    id?: true;
    job_id?: true;
    quote_id?: true;
    _all?: true;
  };

  export type JobQuoteAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which JobQuote to aggregate.
     */
    where?: JobQuoteWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of JobQuotes to fetch.
     */
    orderBy?:
      | JobQuoteOrderByWithRelationInput
      | JobQuoteOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: JobQuoteWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` JobQuotes from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` JobQuotes.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned JobQuotes
     **/
    _count?: true | JobQuoteCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: JobQuoteAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: JobQuoteSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: JobQuoteMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: JobQuoteMaxAggregateInputType;
  };

  export type GetJobQuoteAggregateType<T extends JobQuoteAggregateArgs> = {
    [P in keyof T & keyof AggregateJobQuote]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJobQuote[P]>
      : GetScalarType<T[P], AggregateJobQuote[P]>;
  };

  export type JobQuoteGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: JobQuoteWhereInput;
    orderBy?:
      | JobQuoteOrderByWithAggregationInput
      | JobQuoteOrderByWithAggregationInput[];
    by: JobQuoteScalarFieldEnum[] | JobQuoteScalarFieldEnum;
    having?: JobQuoteScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: JobQuoteCountAggregateInputType | true;
    _avg?: JobQuoteAvgAggregateInputType;
    _sum?: JobQuoteSumAggregateInputType;
    _min?: JobQuoteMinAggregateInputType;
    _max?: JobQuoteMaxAggregateInputType;
  };

  export type JobQuoteGroupByOutputType = {
    id: number;
    job_id: number;
    quote_id: number;
    _count: JobQuoteCountAggregateOutputType | null;
    _avg: JobQuoteAvgAggregateOutputType | null;
    _sum: JobQuoteSumAggregateOutputType | null;
    _min: JobQuoteMinAggregateOutputType | null;
    _max: JobQuoteMaxAggregateOutputType | null;
  };

  type GetJobQuoteGroupByPayload<T extends JobQuoteGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<JobQuoteGroupByOutputType, T["by"]> & {
          [P in keyof T & keyof JobQuoteGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JobQuoteGroupByOutputType[P]>
            : GetScalarType<T[P], JobQuoteGroupByOutputType[P]>;
        }
      >
    >;

  export type JobQuoteSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      job_id?: boolean;
      quote_id?: boolean;
      job?: boolean | JobsDefaultArgs<ExtArgs>;
      quote?: boolean | QuotesDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["jobQuote"]
  >;

  export type JobQuoteSelectScalar = {
    id?: boolean;
    job_id?: boolean;
    quote_id?: boolean;
  };

  export type JobQuoteInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    job?: boolean | JobsDefaultArgs<ExtArgs>;
    quote?: boolean | QuotesDefaultArgs<ExtArgs>;
  };

  export type $JobQuotePayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: "JobQuote";
    objects: {
      job: Prisma.$JobsPayload<ExtArgs>;
      quote: Prisma.$QuotesPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: number;
        job_id: number;
        quote_id: number;
      },
      ExtArgs["result"]["jobQuote"]
    >;
    composites: {};
  };

  type JobQuoteGetPayload<
    S extends boolean | null | undefined | JobQuoteDefaultArgs
  > = $Result.GetResult<Prisma.$JobQuotePayload, S>;

  type JobQuoteCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<JobQuoteFindManyArgs, "select" | "include" | "distinct"> & {
    select?: JobQuoteCountAggregateInputType | true;
  };

  export interface JobQuoteDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["JobQuote"];
      meta: { name: "JobQuote" };
    };
    /**
     * Find zero or one JobQuote that matches the filter.
     * @param {JobQuoteFindUniqueArgs} args - Arguments to find a JobQuote
     * @example
     * // Get one JobQuote
     * const jobQuote = await prisma.jobQuote.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     **/
    findUnique<T extends JobQuoteFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, JobQuoteFindUniqueArgs<ExtArgs>>
    ): Prisma__JobQuoteClient<
      $Result.GetResult<
        Prisma.$JobQuotePayload<ExtArgs>,
        T,
        "findUnique"
      > | null,
      null,
      ExtArgs
    >;

    /**
     * Find one JobQuote that matches the filter or throw an error  with `error.code='P2025'`
     *     if no matches were found.
     * @param {JobQuoteFindUniqueOrThrowArgs} args - Arguments to find a JobQuote
     * @example
     * // Get one JobQuote
     * const jobQuote = await prisma.jobQuote.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     **/
    findUniqueOrThrow<T extends JobQuoteFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, JobQuoteFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__JobQuoteClient<
      $Result.GetResult<
        Prisma.$JobQuotePayload<ExtArgs>,
        T,
        "findUniqueOrThrow"
      >,
      never,
      ExtArgs
    >;

    /**
     * Find the first JobQuote that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobQuoteFindFirstArgs} args - Arguments to find a JobQuote
     * @example
     * // Get one JobQuote
     * const jobQuote = await prisma.jobQuote.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     **/
    findFirst<T extends JobQuoteFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, JobQuoteFindFirstArgs<ExtArgs>>
    ): Prisma__JobQuoteClient<
      $Result.GetResult<
        Prisma.$JobQuotePayload<ExtArgs>,
        T,
        "findFirst"
      > | null,
      null,
      ExtArgs
    >;

    /**
     * Find the first JobQuote that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobQuoteFindFirstOrThrowArgs} args - Arguments to find a JobQuote
     * @example
     * // Get one JobQuote
     * const jobQuote = await prisma.jobQuote.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     **/
    findFirstOrThrow<T extends JobQuoteFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, JobQuoteFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__JobQuoteClient<
      $Result.GetResult<
        Prisma.$JobQuotePayload<ExtArgs>,
        T,
        "findFirstOrThrow"
      >,
      never,
      ExtArgs
    >;

    /**
     * Find zero or more JobQuotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobQuoteFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JobQuotes
     * const jobQuotes = await prisma.jobQuote.findMany()
     *
     * // Get first 10 JobQuotes
     * const jobQuotes = await prisma.jobQuote.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const jobQuoteWithIdOnly = await prisma.jobQuote.findMany({ select: { id: true } })
     *
     **/
    findMany<T extends JobQuoteFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, JobQuoteFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$JobQuotePayload<ExtArgs>, T, "findMany">
    >;

    /**
     * Create a JobQuote.
     * @param {JobQuoteCreateArgs} args - Arguments to create a JobQuote.
     * @example
     * // Create one JobQuote
     * const JobQuote = await prisma.jobQuote.create({
     *   data: {
     *     // ... data to create a JobQuote
     *   }
     * })
     *
     **/
    create<T extends JobQuoteCreateArgs<ExtArgs>>(
      args: SelectSubset<T, JobQuoteCreateArgs<ExtArgs>>
    ): Prisma__JobQuoteClient<
      $Result.GetResult<Prisma.$JobQuotePayload<ExtArgs>, T, "create">,
      never,
      ExtArgs
    >;

    /**
     * Create many JobQuotes.
     *     @param {JobQuoteCreateManyArgs} args - Arguments to create many JobQuotes.
     *     @example
     *     // Create many JobQuotes
     *     const jobQuote = await prisma.jobQuote.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *
     **/
    createMany<T extends JobQuoteCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, JobQuoteCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a JobQuote.
     * @param {JobQuoteDeleteArgs} args - Arguments to delete one JobQuote.
     * @example
     * // Delete one JobQuote
     * const JobQuote = await prisma.jobQuote.delete({
     *   where: {
     *     // ... filter to delete one JobQuote
     *   }
     * })
     *
     **/
    delete<T extends JobQuoteDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, JobQuoteDeleteArgs<ExtArgs>>
    ): Prisma__JobQuoteClient<
      $Result.GetResult<Prisma.$JobQuotePayload<ExtArgs>, T, "delete">,
      never,
      ExtArgs
    >;

    /**
     * Update one JobQuote.
     * @param {JobQuoteUpdateArgs} args - Arguments to update one JobQuote.
     * @example
     * // Update one JobQuote
     * const jobQuote = await prisma.jobQuote.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     **/
    update<T extends JobQuoteUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, JobQuoteUpdateArgs<ExtArgs>>
    ): Prisma__JobQuoteClient<
      $Result.GetResult<Prisma.$JobQuotePayload<ExtArgs>, T, "update">,
      never,
      ExtArgs
    >;

    /**
     * Delete zero or more JobQuotes.
     * @param {JobQuoteDeleteManyArgs} args - Arguments to filter JobQuotes to delete.
     * @example
     * // Delete a few JobQuotes
     * const { count } = await prisma.jobQuote.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     **/
    deleteMany<T extends JobQuoteDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, JobQuoteDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more JobQuotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobQuoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JobQuotes
     * const jobQuote = await prisma.jobQuote.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     **/
    updateMany<T extends JobQuoteUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, JobQuoteUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one JobQuote.
     * @param {JobQuoteUpsertArgs} args - Arguments to update or create a JobQuote.
     * @example
     * // Update or create a JobQuote
     * const jobQuote = await prisma.jobQuote.upsert({
     *   create: {
     *     // ... data to create a JobQuote
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JobQuote we want to update
     *   }
     * })
     **/
    upsert<T extends JobQuoteUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, JobQuoteUpsertArgs<ExtArgs>>
    ): Prisma__JobQuoteClient<
      $Result.GetResult<Prisma.$JobQuotePayload<ExtArgs>, T, "upsert">,
      never,
      ExtArgs
    >;

    /**
     * Count the number of JobQuotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobQuoteCountArgs} args - Arguments to filter JobQuotes to count.
     * @example
     * // Count the number of JobQuotes
     * const count = await prisma.jobQuote.count({
     *   where: {
     *     // ... the filter for the JobQuotes we want to count
     *   }
     * })
     **/
    count<T extends JobQuoteCountArgs>(
      args?: Subset<T, JobQuoteCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], JobQuoteCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a JobQuote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobQuoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends JobQuoteAggregateArgs>(
      args: Subset<T, JobQuoteAggregateArgs>
    ): Prisma.PrismaPromise<GetJobQuoteAggregateType<T>>;

    /**
     * Group by JobQuote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobQuoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends JobQuoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JobQuoteGroupByArgs["orderBy"] }
        : { orderBy?: JobQuoteGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
        ? {
            [P in HavingFields]: P extends ByFields
              ? never
              : P extends string
              ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
              : [
                  Error,
                  "Field ",
                  P,
                  ` in "having" needs to be provided in "by"`
                ];
          }[HavingFields]
        : "take" extends Keys<T>
        ? "orderBy" extends Keys<T>
          ? ByValid extends True
            ? {}
            : {
                [P in OrderFields]: P extends ByFields
                  ? never
                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
              }[OrderFields]
          : 'Error: If you provide "take", you also need to provide "orderBy"'
        : "skip" extends Keys<T>
        ? "orderBy" extends Keys<T>
          ? ByValid extends True
            ? {}
            : {
                [P in OrderFields]: P extends ByFields
                  ? never
                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
              }[OrderFields]
          : 'Error: If you provide "skip", you also need to provide "orderBy"'
        : ByValid extends True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
          }[OrderFields]
    >(
      args: SubsetIntersection<T, JobQuoteGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetJobQuoteGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the JobQuote model
     */
    readonly fields: JobQuoteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JobQuote.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JobQuoteClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";

    job<T extends JobsDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, JobsDefaultArgs<ExtArgs>>
    ): Prisma__JobsClient<
      | $Result.GetResult<Prisma.$JobsPayload<ExtArgs>, T, "findUniqueOrThrow">
      | Null,
      Null,
      ExtArgs
    >;

    quote<T extends QuotesDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, QuotesDefaultArgs<ExtArgs>>
    ): Prisma__QuotesClient<
      | $Result.GetResult<
          Prisma.$QuotesPayload<ExtArgs>,
          T,
          "findUniqueOrThrow"
        >
      | Null,
      Null,
      ExtArgs
    >;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the JobQuote model
   */
  interface JobQuoteFieldRefs {
    readonly id: FieldRef<"JobQuote", "Int">;
    readonly job_id: FieldRef<"JobQuote", "Int">;
    readonly quote_id: FieldRef<"JobQuote", "Int">;
  }

  // Custom InputTypes

  /**
   * JobQuote findUnique
   */
  export type JobQuoteFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the JobQuote
     */
    select?: JobQuoteSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobQuoteInclude<ExtArgs> | null;
    /**
     * Filter, which JobQuote to fetch.
     */
    where: JobQuoteWhereUniqueInput;
  };

  /**
   * JobQuote findUniqueOrThrow
   */
  export type JobQuoteFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the JobQuote
     */
    select?: JobQuoteSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobQuoteInclude<ExtArgs> | null;
    /**
     * Filter, which JobQuote to fetch.
     */
    where: JobQuoteWhereUniqueInput;
  };

  /**
   * JobQuote findFirst
   */
  export type JobQuoteFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the JobQuote
     */
    select?: JobQuoteSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobQuoteInclude<ExtArgs> | null;
    /**
     * Filter, which JobQuote to fetch.
     */
    where?: JobQuoteWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of JobQuotes to fetch.
     */
    orderBy?:
      | JobQuoteOrderByWithRelationInput
      | JobQuoteOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for JobQuotes.
     */
    cursor?: JobQuoteWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` JobQuotes from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` JobQuotes.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of JobQuotes.
     */
    distinct?: JobQuoteScalarFieldEnum | JobQuoteScalarFieldEnum[];
  };

  /**
   * JobQuote findFirstOrThrow
   */
  export type JobQuoteFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the JobQuote
     */
    select?: JobQuoteSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobQuoteInclude<ExtArgs> | null;
    /**
     * Filter, which JobQuote to fetch.
     */
    where?: JobQuoteWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of JobQuotes to fetch.
     */
    orderBy?:
      | JobQuoteOrderByWithRelationInput
      | JobQuoteOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for JobQuotes.
     */
    cursor?: JobQuoteWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` JobQuotes from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` JobQuotes.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of JobQuotes.
     */
    distinct?: JobQuoteScalarFieldEnum | JobQuoteScalarFieldEnum[];
  };

  /**
   * JobQuote findMany
   */
  export type JobQuoteFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the JobQuote
     */
    select?: JobQuoteSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobQuoteInclude<ExtArgs> | null;
    /**
     * Filter, which JobQuotes to fetch.
     */
    where?: JobQuoteWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of JobQuotes to fetch.
     */
    orderBy?:
      | JobQuoteOrderByWithRelationInput
      | JobQuoteOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing JobQuotes.
     */
    cursor?: JobQuoteWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` JobQuotes from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` JobQuotes.
     */
    skip?: number;
    distinct?: JobQuoteScalarFieldEnum | JobQuoteScalarFieldEnum[];
  };

  /**
   * JobQuote create
   */
  export type JobQuoteCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the JobQuote
     */
    select?: JobQuoteSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobQuoteInclude<ExtArgs> | null;
    /**
     * The data needed to create a JobQuote.
     */
    data: XOR<JobQuoteCreateInput, JobQuoteUncheckedCreateInput>;
  };

  /**
   * JobQuote createMany
   */
  export type JobQuoteCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many JobQuotes.
     */
    data: JobQuoteCreateManyInput | JobQuoteCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * JobQuote update
   */
  export type JobQuoteUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the JobQuote
     */
    select?: JobQuoteSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobQuoteInclude<ExtArgs> | null;
    /**
     * The data needed to update a JobQuote.
     */
    data: XOR<JobQuoteUpdateInput, JobQuoteUncheckedUpdateInput>;
    /**
     * Choose, which JobQuote to update.
     */
    where: JobQuoteWhereUniqueInput;
  };

  /**
   * JobQuote updateMany
   */
  export type JobQuoteUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update JobQuotes.
     */
    data: XOR<
      JobQuoteUpdateManyMutationInput,
      JobQuoteUncheckedUpdateManyInput
    >;
    /**
     * Filter which JobQuotes to update
     */
    where?: JobQuoteWhereInput;
  };

  /**
   * JobQuote upsert
   */
  export type JobQuoteUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the JobQuote
     */
    select?: JobQuoteSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobQuoteInclude<ExtArgs> | null;
    /**
     * The filter to search for the JobQuote to update in case it exists.
     */
    where: JobQuoteWhereUniqueInput;
    /**
     * In case the JobQuote found by the `where` argument doesn't exist, create a new JobQuote with this data.
     */
    create: XOR<JobQuoteCreateInput, JobQuoteUncheckedCreateInput>;
    /**
     * In case the JobQuote was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JobQuoteUpdateInput, JobQuoteUncheckedUpdateInput>;
  };

  /**
   * JobQuote delete
   */
  export type JobQuoteDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the JobQuote
     */
    select?: JobQuoteSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobQuoteInclude<ExtArgs> | null;
    /**
     * Filter which JobQuote to delete.
     */
    where: JobQuoteWhereUniqueInput;
  };

  /**
   * JobQuote deleteMany
   */
  export type JobQuoteDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which JobQuotes to delete
     */
    where?: JobQuoteWhereInput;
  };

  /**
   * JobQuote without action
   */
  export type JobQuoteDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the JobQuote
     */
    select?: JobQuoteSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobQuoteInclude<ExtArgs> | null;
  };

  /**
   * Model Invoices
   */

  export type AggregateInvoices = {
    _count: InvoicesCountAggregateOutputType | null;
    _avg: InvoicesAvgAggregateOutputType | null;
    _sum: InvoicesSumAggregateOutputType | null;
    _min: InvoicesMinAggregateOutputType | null;
    _max: InvoicesMaxAggregateOutputType | null;
  };

  export type InvoicesAvgAggregateOutputType = {
    id: number | null;
    client_id: number | null;
    job_id: number | null;
    tax_id: number | null;
    belongs_to_id: number | null;
  };

  export type InvoicesSumAggregateOutputType = {
    id: number | null;
    client_id: number | null;
    job_id: number | null;
    tax_id: number | null;
    belongs_to_id: number | null;
  };

  export type InvoicesMinAggregateOutputType = {
    id: number | null;
    emailed_to_client: boolean | null;
    texted_to_client: boolean | null;
    issued_date: Date | null;
    due_date: Date | null;
    status: string | null;
    type: string | null;
    subject: string | null;
    client_id: number | null;
    job_id: number | null;
    tax_id: number | null;
    client_message: string | null;
    internal_notes: string | null;
    internalAttachmentUrl: string | null;
    belongs_to_id: number | null;
  };

  export type InvoicesMaxAggregateOutputType = {
    id: number | null;
    emailed_to_client: boolean | null;
    texted_to_client: boolean | null;
    issued_date: Date | null;
    due_date: Date | null;
    status: string | null;
    type: string | null;
    subject: string | null;
    client_id: number | null;
    job_id: number | null;
    tax_id: number | null;
    client_message: string | null;
    internal_notes: string | null;
    internalAttachmentUrl: string | null;
    belongs_to_id: number | null;
  };

  export type InvoicesCountAggregateOutputType = {
    id: number;
    tags: number;
    emailed_to_client: number;
    texted_to_client: number;
    issued_date: number;
    due_date: number;
    status: number;
    type: number;
    subject: number;
    client_id: number;
    job_id: number;
    tax_id: number;
    client_message: number;
    internal_notes: number;
    internalAttachmentUrl: number;
    belongs_to_id: number;
    _all: number;
  };

  export type InvoicesAvgAggregateInputType = {
    id?: true;
    client_id?: true;
    job_id?: true;
    tax_id?: true;
    belongs_to_id?: true;
  };

  export type InvoicesSumAggregateInputType = {
    id?: true;
    client_id?: true;
    job_id?: true;
    tax_id?: true;
    belongs_to_id?: true;
  };

  export type InvoicesMinAggregateInputType = {
    id?: true;
    emailed_to_client?: true;
    texted_to_client?: true;
    issued_date?: true;
    due_date?: true;
    status?: true;
    type?: true;
    subject?: true;
    client_id?: true;
    job_id?: true;
    tax_id?: true;
    client_message?: true;
    internal_notes?: true;
    internalAttachmentUrl?: true;
    belongs_to_id?: true;
  };

  export type InvoicesMaxAggregateInputType = {
    id?: true;
    emailed_to_client?: true;
    texted_to_client?: true;
    issued_date?: true;
    due_date?: true;
    status?: true;
    type?: true;
    subject?: true;
    client_id?: true;
    job_id?: true;
    tax_id?: true;
    client_message?: true;
    internal_notes?: true;
    internalAttachmentUrl?: true;
    belongs_to_id?: true;
  };

  export type InvoicesCountAggregateInputType = {
    id?: true;
    tags?: true;
    emailed_to_client?: true;
    texted_to_client?: true;
    issued_date?: true;
    due_date?: true;
    status?: true;
    type?: true;
    subject?: true;
    client_id?: true;
    job_id?: true;
    tax_id?: true;
    client_message?: true;
    internal_notes?: true;
    internalAttachmentUrl?: true;
    belongs_to_id?: true;
    _all?: true;
  };

  export type InvoicesAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which Invoices to aggregate.
     */
    where?: InvoicesWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Invoices to fetch.
     */
    orderBy?:
      | InvoicesOrderByWithRelationInput
      | InvoicesOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: InvoicesWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Invoices.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Invoices
     **/
    _count?: true | InvoicesCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: InvoicesAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: InvoicesSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: InvoicesMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: InvoicesMaxAggregateInputType;
  };

  export type GetInvoicesAggregateType<T extends InvoicesAggregateArgs> = {
    [P in keyof T & keyof AggregateInvoices]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoices[P]>
      : GetScalarType<T[P], AggregateInvoices[P]>;
  };

  export type InvoicesGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: InvoicesWhereInput;
    orderBy?:
      | InvoicesOrderByWithAggregationInput
      | InvoicesOrderByWithAggregationInput[];
    by: InvoicesScalarFieldEnum[] | InvoicesScalarFieldEnum;
    having?: InvoicesScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: InvoicesCountAggregateInputType | true;
    _avg?: InvoicesAvgAggregateInputType;
    _sum?: InvoicesSumAggregateInputType;
    _min?: InvoicesMinAggregateInputType;
    _max?: InvoicesMaxAggregateInputType;
  };

  export type InvoicesGroupByOutputType = {
    id: number;
    tags: JsonValue | null;
    emailed_to_client: boolean;
    texted_to_client: boolean;
    issued_date: Date;
    due_date: Date | null;
    status: string;
    type: string;
    subject: string;
    client_id: number;
    job_id: number | null;
    tax_id: number | null;
    client_message: string;
    internal_notes: string;
    internalAttachmentUrl: string;
    belongs_to_id: number;
    _count: InvoicesCountAggregateOutputType | null;
    _avg: InvoicesAvgAggregateOutputType | null;
    _sum: InvoicesSumAggregateOutputType | null;
    _min: InvoicesMinAggregateOutputType | null;
    _max: InvoicesMaxAggregateOutputType | null;
  };

  type GetInvoicesGroupByPayload<T extends InvoicesGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<InvoicesGroupByOutputType, T["by"]> & {
          [P in keyof T & keyof InvoicesGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoicesGroupByOutputType[P]>
            : GetScalarType<T[P], InvoicesGroupByOutputType[P]>;
        }
      >
    >;

  export type InvoicesSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      tags?: boolean;
      emailed_to_client?: boolean;
      texted_to_client?: boolean;
      issued_date?: boolean;
      due_date?: boolean;
      status?: boolean;
      type?: boolean;
      subject?: boolean;
      client_id?: boolean;
      job_id?: boolean;
      tax_id?: boolean;
      client_message?: boolean;
      internal_notes?: boolean;
      internalAttachmentUrl?: boolean;
      belongs_to_id?: boolean;
      client?: boolean | ClientsDefaultArgs<ExtArgs>;
      job?: boolean | Invoices$jobArgs<ExtArgs>;
      tax?: boolean | Invoices$taxArgs<ExtArgs>;
      additional_line_items?:
        | boolean
        | Invoices$additional_line_itemsArgs<ExtArgs>;
      belongs_to?: boolean | UsersDefaultArgs<ExtArgs>;
      _count?: boolean | InvoicesCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["invoices"]
  >;

  export type InvoicesSelectScalar = {
    id?: boolean;
    tags?: boolean;
    emailed_to_client?: boolean;
    texted_to_client?: boolean;
    issued_date?: boolean;
    due_date?: boolean;
    status?: boolean;
    type?: boolean;
    subject?: boolean;
    client_id?: boolean;
    job_id?: boolean;
    tax_id?: boolean;
    client_message?: boolean;
    internal_notes?: boolean;
    internalAttachmentUrl?: boolean;
    belongs_to_id?: boolean;
  };

  export type InvoicesInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    client?: boolean | ClientsDefaultArgs<ExtArgs>;
    job?: boolean | Invoices$jobArgs<ExtArgs>;
    tax?: boolean | Invoices$taxArgs<ExtArgs>;
    additional_line_items?:
      | boolean
      | Invoices$additional_line_itemsArgs<ExtArgs>;
    belongs_to?: boolean | UsersDefaultArgs<ExtArgs>;
    _count?: boolean | InvoicesCountOutputTypeDefaultArgs<ExtArgs>;
  };

  export type $InvoicesPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: "Invoices";
    objects: {
      client: Prisma.$ClientsPayload<ExtArgs>;
      job: Prisma.$JobsPayload<ExtArgs> | null;
      tax: Prisma.$TaxesPayload<ExtArgs> | null;
      additional_line_items: Prisma.$LineItemInvoicePayload<ExtArgs>[];
      belongs_to: Prisma.$UsersPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: number;
        tags: Prisma.JsonValue | null;
        emailed_to_client: boolean;
        texted_to_client: boolean;
        issued_date: Date;
        due_date: Date | null;
        status: string;
        type: string;
        subject: string;
        client_id: number;
        job_id: number | null;
        tax_id: number | null;
        client_message: string;
        internal_notes: string;
        internalAttachmentUrl: string;
        belongs_to_id: number;
      },
      ExtArgs["result"]["invoices"]
    >;
    composites: {};
  };

  type InvoicesGetPayload<
    S extends boolean | null | undefined | InvoicesDefaultArgs
  > = $Result.GetResult<Prisma.$InvoicesPayload, S>;

  type InvoicesCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<InvoicesFindManyArgs, "select" | "include" | "distinct"> & {
    select?: InvoicesCountAggregateInputType | true;
  };

  export interface InvoicesDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["Invoices"];
      meta: { name: "Invoices" };
    };
    /**
     * Find zero or one Invoices that matches the filter.
     * @param {InvoicesFindUniqueArgs} args - Arguments to find a Invoices
     * @example
     * // Get one Invoices
     * const invoices = await prisma.invoices.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     **/
    findUnique<T extends InvoicesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, InvoicesFindUniqueArgs<ExtArgs>>
    ): Prisma__InvoicesClient<
      $Result.GetResult<
        Prisma.$InvoicesPayload<ExtArgs>,
        T,
        "findUnique"
      > | null,
      null,
      ExtArgs
    >;

    /**
     * Find one Invoices that matches the filter or throw an error  with `error.code='P2025'`
     *     if no matches were found.
     * @param {InvoicesFindUniqueOrThrowArgs} args - Arguments to find a Invoices
     * @example
     * // Get one Invoices
     * const invoices = await prisma.invoices.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     **/
    findUniqueOrThrow<T extends InvoicesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, InvoicesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__InvoicesClient<
      $Result.GetResult<
        Prisma.$InvoicesPayload<ExtArgs>,
        T,
        "findUniqueOrThrow"
      >,
      never,
      ExtArgs
    >;

    /**
     * Find the first Invoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoicesFindFirstArgs} args - Arguments to find a Invoices
     * @example
     * // Get one Invoices
     * const invoices = await prisma.invoices.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     **/
    findFirst<T extends InvoicesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, InvoicesFindFirstArgs<ExtArgs>>
    ): Prisma__InvoicesClient<
      $Result.GetResult<
        Prisma.$InvoicesPayload<ExtArgs>,
        T,
        "findFirst"
      > | null,
      null,
      ExtArgs
    >;

    /**
     * Find the first Invoices that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoicesFindFirstOrThrowArgs} args - Arguments to find a Invoices
     * @example
     * // Get one Invoices
     * const invoices = await prisma.invoices.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     **/
    findFirstOrThrow<T extends InvoicesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, InvoicesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__InvoicesClient<
      $Result.GetResult<
        Prisma.$InvoicesPayload<ExtArgs>,
        T,
        "findFirstOrThrow"
      >,
      never,
      ExtArgs
    >;

    /**
     * Find zero or more Invoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoicesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invoices
     * const invoices = await prisma.invoices.findMany()
     *
     * // Get first 10 Invoices
     * const invoices = await prisma.invoices.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const invoicesWithIdOnly = await prisma.invoices.findMany({ select: { id: true } })
     *
     **/
    findMany<T extends InvoicesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InvoicesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$InvoicesPayload<ExtArgs>, T, "findMany">
    >;

    /**
     * Create a Invoices.
     * @param {InvoicesCreateArgs} args - Arguments to create a Invoices.
     * @example
     * // Create one Invoices
     * const Invoices = await prisma.invoices.create({
     *   data: {
     *     // ... data to create a Invoices
     *   }
     * })
     *
     **/
    create<T extends InvoicesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, InvoicesCreateArgs<ExtArgs>>
    ): Prisma__InvoicesClient<
      $Result.GetResult<Prisma.$InvoicesPayload<ExtArgs>, T, "create">,
      never,
      ExtArgs
    >;

    /**
     * Create many Invoices.
     *     @param {InvoicesCreateManyArgs} args - Arguments to create many Invoices.
     *     @example
     *     // Create many Invoices
     *     const invoices = await prisma.invoices.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *
     **/
    createMany<T extends InvoicesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InvoicesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a Invoices.
     * @param {InvoicesDeleteArgs} args - Arguments to delete one Invoices.
     * @example
     * // Delete one Invoices
     * const Invoices = await prisma.invoices.delete({
     *   where: {
     *     // ... filter to delete one Invoices
     *   }
     * })
     *
     **/
    delete<T extends InvoicesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, InvoicesDeleteArgs<ExtArgs>>
    ): Prisma__InvoicesClient<
      $Result.GetResult<Prisma.$InvoicesPayload<ExtArgs>, T, "delete">,
      never,
      ExtArgs
    >;

    /**
     * Update one Invoices.
     * @param {InvoicesUpdateArgs} args - Arguments to update one Invoices.
     * @example
     * // Update one Invoices
     * const invoices = await prisma.invoices.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     **/
    update<T extends InvoicesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, InvoicesUpdateArgs<ExtArgs>>
    ): Prisma__InvoicesClient<
      $Result.GetResult<Prisma.$InvoicesPayload<ExtArgs>, T, "update">,
      never,
      ExtArgs
    >;

    /**
     * Delete zero or more Invoices.
     * @param {InvoicesDeleteManyArgs} args - Arguments to filter Invoices to delete.
     * @example
     * // Delete a few Invoices
     * const { count } = await prisma.invoices.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     **/
    deleteMany<T extends InvoicesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InvoicesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoicesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invoices
     * const invoices = await prisma.invoices.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     **/
    updateMany<T extends InvoicesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, InvoicesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one Invoices.
     * @param {InvoicesUpsertArgs} args - Arguments to update or create a Invoices.
     * @example
     * // Update or create a Invoices
     * const invoices = await prisma.invoices.upsert({
     *   create: {
     *     // ... data to create a Invoices
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invoices we want to update
     *   }
     * })
     **/
    upsert<T extends InvoicesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, InvoicesUpsertArgs<ExtArgs>>
    ): Prisma__InvoicesClient<
      $Result.GetResult<Prisma.$InvoicesPayload<ExtArgs>, T, "upsert">,
      never,
      ExtArgs
    >;

    /**
     * Count the number of Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoicesCountArgs} args - Arguments to filter Invoices to count.
     * @example
     * // Count the number of Invoices
     * const count = await prisma.invoices.count({
     *   where: {
     *     // ... the filter for the Invoices we want to count
     *   }
     * })
     **/
    count<T extends InvoicesCountArgs>(
      args?: Subset<T, InvoicesCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], InvoicesCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoicesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends InvoicesAggregateArgs>(
      args: Subset<T, InvoicesAggregateArgs>
    ): Prisma.PrismaPromise<GetInvoicesAggregateType<T>>;

    /**
     * Group by Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoicesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends InvoicesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoicesGroupByArgs["orderBy"] }
        : { orderBy?: InvoicesGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
        ? {
            [P in HavingFields]: P extends ByFields
              ? never
              : P extends string
              ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
              : [
                  Error,
                  "Field ",
                  P,
                  ` in "having" needs to be provided in "by"`
                ];
          }[HavingFields]
        : "take" extends Keys<T>
        ? "orderBy" extends Keys<T>
          ? ByValid extends True
            ? {}
            : {
                [P in OrderFields]: P extends ByFields
                  ? never
                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
              }[OrderFields]
          : 'Error: If you provide "take", you also need to provide "orderBy"'
        : "skip" extends Keys<T>
        ? "orderBy" extends Keys<T>
          ? ByValid extends True
            ? {}
            : {
                [P in OrderFields]: P extends ByFields
                  ? never
                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
              }[OrderFields]
          : 'Error: If you provide "skip", you also need to provide "orderBy"'
        : ByValid extends True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
          }[OrderFields]
    >(
      args: SubsetIntersection<T, InvoicesGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetInvoicesGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Invoices model
     */
    readonly fields: InvoicesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Invoices.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoicesClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";

    client<T extends ClientsDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, ClientsDefaultArgs<ExtArgs>>
    ): Prisma__ClientsClient<
      | $Result.GetResult<
          Prisma.$ClientsPayload<ExtArgs>,
          T,
          "findUniqueOrThrow"
        >
      | Null,
      Null,
      ExtArgs
    >;

    job<T extends Invoices$jobArgs<ExtArgs> = {}>(
      args?: Subset<T, Invoices$jobArgs<ExtArgs>>
    ): Prisma__JobsClient<
      $Result.GetResult<
        Prisma.$JobsPayload<ExtArgs>,
        T,
        "findUniqueOrThrow"
      > | null,
      null,
      ExtArgs
    >;

    tax<T extends Invoices$taxArgs<ExtArgs> = {}>(
      args?: Subset<T, Invoices$taxArgs<ExtArgs>>
    ): Prisma__TaxesClient<
      $Result.GetResult<
        Prisma.$TaxesPayload<ExtArgs>,
        T,
        "findUniqueOrThrow"
      > | null,
      null,
      ExtArgs
    >;

    additional_line_items<
      T extends Invoices$additional_line_itemsArgs<ExtArgs> = {}
    >(
      args?: Subset<T, Invoices$additional_line_itemsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$LineItemInvoicePayload<ExtArgs>,
          T,
          "findMany"
        >
      | Null
    >;

    belongs_to<T extends UsersDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UsersDefaultArgs<ExtArgs>>
    ): Prisma__UsersClient<
      | $Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow">
      | Null,
      Null,
      ExtArgs
    >;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Invoices model
   */
  interface InvoicesFieldRefs {
    readonly id: FieldRef<"Invoices", "Int">;
    readonly tags: FieldRef<"Invoices", "Json">;
    readonly emailed_to_client: FieldRef<"Invoices", "Boolean">;
    readonly texted_to_client: FieldRef<"Invoices", "Boolean">;
    readonly issued_date: FieldRef<"Invoices", "DateTime">;
    readonly due_date: FieldRef<"Invoices", "DateTime">;
    readonly status: FieldRef<"Invoices", "String">;
    readonly type: FieldRef<"Invoices", "String">;
    readonly subject: FieldRef<"Invoices", "String">;
    readonly client_id: FieldRef<"Invoices", "Int">;
    readonly job_id: FieldRef<"Invoices", "Int">;
    readonly tax_id: FieldRef<"Invoices", "Int">;
    readonly client_message: FieldRef<"Invoices", "String">;
    readonly internal_notes: FieldRef<"Invoices", "String">;
    readonly internalAttachmentUrl: FieldRef<"Invoices", "String">;
    readonly belongs_to_id: FieldRef<"Invoices", "Int">;
  }

  // Custom InputTypes

  /**
   * Invoices findUnique
   */
  export type InvoicesFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Invoices
     */
    select?: InvoicesSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvoicesInclude<ExtArgs> | null;
    /**
     * Filter, which Invoices to fetch.
     */
    where: InvoicesWhereUniqueInput;
  };

  /**
   * Invoices findUniqueOrThrow
   */
  export type InvoicesFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Invoices
     */
    select?: InvoicesSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvoicesInclude<ExtArgs> | null;
    /**
     * Filter, which Invoices to fetch.
     */
    where: InvoicesWhereUniqueInput;
  };

  /**
   * Invoices findFirst
   */
  export type InvoicesFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Invoices
     */
    select?: InvoicesSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvoicesInclude<ExtArgs> | null;
    /**
     * Filter, which Invoices to fetch.
     */
    where?: InvoicesWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Invoices to fetch.
     */
    orderBy?:
      | InvoicesOrderByWithRelationInput
      | InvoicesOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoicesWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Invoices.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoicesScalarFieldEnum | InvoicesScalarFieldEnum[];
  };

  /**
   * Invoices findFirstOrThrow
   */
  export type InvoicesFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Invoices
     */
    select?: InvoicesSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvoicesInclude<ExtArgs> | null;
    /**
     * Filter, which Invoices to fetch.
     */
    where?: InvoicesWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Invoices to fetch.
     */
    orderBy?:
      | InvoicesOrderByWithRelationInput
      | InvoicesOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoicesWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Invoices.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoicesScalarFieldEnum | InvoicesScalarFieldEnum[];
  };

  /**
   * Invoices findMany
   */
  export type InvoicesFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Invoices
     */
    select?: InvoicesSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvoicesInclude<ExtArgs> | null;
    /**
     * Filter, which Invoices to fetch.
     */
    where?: InvoicesWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Invoices to fetch.
     */
    orderBy?:
      | InvoicesOrderByWithRelationInput
      | InvoicesOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Invoices.
     */
    cursor?: InvoicesWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Invoices.
     */
    skip?: number;
    distinct?: InvoicesScalarFieldEnum | InvoicesScalarFieldEnum[];
  };

  /**
   * Invoices create
   */
  export type InvoicesCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Invoices
     */
    select?: InvoicesSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvoicesInclude<ExtArgs> | null;
    /**
     * The data needed to create a Invoices.
     */
    data: XOR<InvoicesCreateInput, InvoicesUncheckedCreateInput>;
  };

  /**
   * Invoices createMany
   */
  export type InvoicesCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many Invoices.
     */
    data: InvoicesCreateManyInput | InvoicesCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Invoices update
   */
  export type InvoicesUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Invoices
     */
    select?: InvoicesSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvoicesInclude<ExtArgs> | null;
    /**
     * The data needed to update a Invoices.
     */
    data: XOR<InvoicesUpdateInput, InvoicesUncheckedUpdateInput>;
    /**
     * Choose, which Invoices to update.
     */
    where: InvoicesWhereUniqueInput;
  };

  /**
   * Invoices updateMany
   */
  export type InvoicesUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update Invoices.
     */
    data: XOR<
      InvoicesUpdateManyMutationInput,
      InvoicesUncheckedUpdateManyInput
    >;
    /**
     * Filter which Invoices to update
     */
    where?: InvoicesWhereInput;
  };

  /**
   * Invoices upsert
   */
  export type InvoicesUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Invoices
     */
    select?: InvoicesSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvoicesInclude<ExtArgs> | null;
    /**
     * The filter to search for the Invoices to update in case it exists.
     */
    where: InvoicesWhereUniqueInput;
    /**
     * In case the Invoices found by the `where` argument doesn't exist, create a new Invoices with this data.
     */
    create: XOR<InvoicesCreateInput, InvoicesUncheckedCreateInput>;
    /**
     * In case the Invoices was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoicesUpdateInput, InvoicesUncheckedUpdateInput>;
  };

  /**
   * Invoices delete
   */
  export type InvoicesDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Invoices
     */
    select?: InvoicesSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvoicesInclude<ExtArgs> | null;
    /**
     * Filter which Invoices to delete.
     */
    where: InvoicesWhereUniqueInput;
  };

  /**
   * Invoices deleteMany
   */
  export type InvoicesDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which Invoices to delete
     */
    where?: InvoicesWhereInput;
  };

  /**
   * Invoices.job
   */
  export type Invoices$jobArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Jobs
     */
    select?: JobsSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobsInclude<ExtArgs> | null;
    where?: JobsWhereInput;
  };

  /**
   * Invoices.tax
   */
  export type Invoices$taxArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Taxes
     */
    select?: TaxesSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TaxesInclude<ExtArgs> | null;
    where?: TaxesWhereInput;
  };

  /**
   * Invoices.additional_line_items
   */
  export type Invoices$additional_line_itemsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the LineItemInvoice
     */
    select?: LineItemInvoiceSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LineItemInvoiceInclude<ExtArgs> | null;
    where?: LineItemInvoiceWhereInput;
    orderBy?:
      | LineItemInvoiceOrderByWithRelationInput
      | LineItemInvoiceOrderByWithRelationInput[];
    cursor?: LineItemInvoiceWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?:
      | LineItemInvoiceScalarFieldEnum
      | LineItemInvoiceScalarFieldEnum[];
  };

  /**
   * Invoices without action
   */
  export type InvoicesDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the Invoices
     */
    select?: InvoicesSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvoicesInclude<ExtArgs> | null;
  };

  /**
   * Model LineItemInvoice
   */

  export type AggregateLineItemInvoice = {
    _count: LineItemInvoiceCountAggregateOutputType | null;
    _avg: LineItemInvoiceAvgAggregateOutputType | null;
    _sum: LineItemInvoiceSumAggregateOutputType | null;
    _min: LineItemInvoiceMinAggregateOutputType | null;
    _max: LineItemInvoiceMaxAggregateOutputType | null;
  };

  export type LineItemInvoiceAvgAggregateOutputType = {
    id: number | null;
    invoice_id: number | null;
    line_item_id: number | null;
  };

  export type LineItemInvoiceSumAggregateOutputType = {
    id: number | null;
    invoice_id: number | null;
    line_item_id: number | null;
  };

  export type LineItemInvoiceMinAggregateOutputType = {
    id: number | null;
    invoice_id: number | null;
    line_item_id: number | null;
  };

  export type LineItemInvoiceMaxAggregateOutputType = {
    id: number | null;
    invoice_id: number | null;
    line_item_id: number | null;
  };

  export type LineItemInvoiceCountAggregateOutputType = {
    id: number;
    invoice_id: number;
    line_item_id: number;
    _all: number;
  };

  export type LineItemInvoiceAvgAggregateInputType = {
    id?: true;
    invoice_id?: true;
    line_item_id?: true;
  };

  export type LineItemInvoiceSumAggregateInputType = {
    id?: true;
    invoice_id?: true;
    line_item_id?: true;
  };

  export type LineItemInvoiceMinAggregateInputType = {
    id?: true;
    invoice_id?: true;
    line_item_id?: true;
  };

  export type LineItemInvoiceMaxAggregateInputType = {
    id?: true;
    invoice_id?: true;
    line_item_id?: true;
  };

  export type LineItemInvoiceCountAggregateInputType = {
    id?: true;
    invoice_id?: true;
    line_item_id?: true;
    _all?: true;
  };

  export type LineItemInvoiceAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which LineItemInvoice to aggregate.
     */
    where?: LineItemInvoiceWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of LineItemInvoices to fetch.
     */
    orderBy?:
      | LineItemInvoiceOrderByWithRelationInput
      | LineItemInvoiceOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: LineItemInvoiceWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` LineItemInvoices from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` LineItemInvoices.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned LineItemInvoices
     **/
    _count?: true | LineItemInvoiceCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: LineItemInvoiceAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: LineItemInvoiceSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: LineItemInvoiceMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: LineItemInvoiceMaxAggregateInputType;
  };

  export type GetLineItemInvoiceAggregateType<
    T extends LineItemInvoiceAggregateArgs
  > = {
    [P in keyof T & keyof AggregateLineItemInvoice]: P extends
      | "_count"
      | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLineItemInvoice[P]>
      : GetScalarType<T[P], AggregateLineItemInvoice[P]>;
  };

  export type LineItemInvoiceGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    where?: LineItemInvoiceWhereInput;
    orderBy?:
      | LineItemInvoiceOrderByWithAggregationInput
      | LineItemInvoiceOrderByWithAggregationInput[];
    by: LineItemInvoiceScalarFieldEnum[] | LineItemInvoiceScalarFieldEnum;
    having?: LineItemInvoiceScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: LineItemInvoiceCountAggregateInputType | true;
    _avg?: LineItemInvoiceAvgAggregateInputType;
    _sum?: LineItemInvoiceSumAggregateInputType;
    _min?: LineItemInvoiceMinAggregateInputType;
    _max?: LineItemInvoiceMaxAggregateInputType;
  };

  export type LineItemInvoiceGroupByOutputType = {
    id: number;
    invoice_id: number;
    line_item_id: number;
    _count: LineItemInvoiceCountAggregateOutputType | null;
    _avg: LineItemInvoiceAvgAggregateOutputType | null;
    _sum: LineItemInvoiceSumAggregateOutputType | null;
    _min: LineItemInvoiceMinAggregateOutputType | null;
    _max: LineItemInvoiceMaxAggregateOutputType | null;
  };

  type GetLineItemInvoiceGroupByPayload<T extends LineItemInvoiceGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<LineItemInvoiceGroupByOutputType, T["by"]> & {
          [P in keyof T &
            keyof LineItemInvoiceGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LineItemInvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], LineItemInvoiceGroupByOutputType[P]>;
        }
      >
    >;

  export type LineItemInvoiceSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      invoice_id?: boolean;
      line_item_id?: boolean;
      invoice?: boolean | InvoicesDefaultArgs<ExtArgs>;
      line_item?: boolean | LineItemsDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["lineItemInvoice"]
  >;

  export type LineItemInvoiceSelectScalar = {
    id?: boolean;
    invoice_id?: boolean;
    line_item_id?: boolean;
  };

  export type LineItemInvoiceInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    invoice?: boolean | InvoicesDefaultArgs<ExtArgs>;
    line_item?: boolean | LineItemsDefaultArgs<ExtArgs>;
  };

  export type $LineItemInvoicePayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    name: "LineItemInvoice";
    objects: {
      invoice: Prisma.$InvoicesPayload<ExtArgs>;
      line_item: Prisma.$LineItemsPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: number;
        invoice_id: number;
        line_item_id: number;
      },
      ExtArgs["result"]["lineItemInvoice"]
    >;
    composites: {};
  };

  type LineItemInvoiceGetPayload<
    S extends boolean | null | undefined | LineItemInvoiceDefaultArgs
  > = $Result.GetResult<Prisma.$LineItemInvoicePayload, S>;

  type LineItemInvoiceCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = Omit<LineItemInvoiceFindManyArgs, "select" | "include" | "distinct"> & {
    select?: LineItemInvoiceCountAggregateInputType | true;
  };

  export interface LineItemInvoiceDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["LineItemInvoice"];
      meta: { name: "LineItemInvoice" };
    };
    /**
     * Find zero or one LineItemInvoice that matches the filter.
     * @param {LineItemInvoiceFindUniqueArgs} args - Arguments to find a LineItemInvoice
     * @example
     * // Get one LineItemInvoice
     * const lineItemInvoice = await prisma.lineItemInvoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     **/
    findUnique<T extends LineItemInvoiceFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, LineItemInvoiceFindUniqueArgs<ExtArgs>>
    ): Prisma__LineItemInvoiceClient<
      $Result.GetResult<
        Prisma.$LineItemInvoicePayload<ExtArgs>,
        T,
        "findUnique"
      > | null,
      null,
      ExtArgs
    >;

    /**
     * Find one LineItemInvoice that matches the filter or throw an error  with `error.code='P2025'`
     *     if no matches were found.
     * @param {LineItemInvoiceFindUniqueOrThrowArgs} args - Arguments to find a LineItemInvoice
     * @example
     * // Get one LineItemInvoice
     * const lineItemInvoice = await prisma.lineItemInvoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     **/
    findUniqueOrThrow<T extends LineItemInvoiceFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LineItemInvoiceFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__LineItemInvoiceClient<
      $Result.GetResult<
        Prisma.$LineItemInvoicePayload<ExtArgs>,
        T,
        "findUniqueOrThrow"
      >,
      never,
      ExtArgs
    >;

    /**
     * Find the first LineItemInvoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LineItemInvoiceFindFirstArgs} args - Arguments to find a LineItemInvoice
     * @example
     * // Get one LineItemInvoice
     * const lineItemInvoice = await prisma.lineItemInvoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     **/
    findFirst<T extends LineItemInvoiceFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, LineItemInvoiceFindFirstArgs<ExtArgs>>
    ): Prisma__LineItemInvoiceClient<
      $Result.GetResult<
        Prisma.$LineItemInvoicePayload<ExtArgs>,
        T,
        "findFirst"
      > | null,
      null,
      ExtArgs
    >;

    /**
     * Find the first LineItemInvoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LineItemInvoiceFindFirstOrThrowArgs} args - Arguments to find a LineItemInvoice
     * @example
     * // Get one LineItemInvoice
     * const lineItemInvoice = await prisma.lineItemInvoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     **/
    findFirstOrThrow<T extends LineItemInvoiceFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LineItemInvoiceFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__LineItemInvoiceClient<
      $Result.GetResult<
        Prisma.$LineItemInvoicePayload<ExtArgs>,
        T,
        "findFirstOrThrow"
      >,
      never,
      ExtArgs
    >;

    /**
     * Find zero or more LineItemInvoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LineItemInvoiceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LineItemInvoices
     * const lineItemInvoices = await prisma.lineItemInvoice.findMany()
     *
     * // Get first 10 LineItemInvoices
     * const lineItemInvoices = await prisma.lineItemInvoice.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const lineItemInvoiceWithIdOnly = await prisma.lineItemInvoice.findMany({ select: { id: true } })
     *
     **/
    findMany<T extends LineItemInvoiceFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LineItemInvoiceFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$LineItemInvoicePayload<ExtArgs>, T, "findMany">
    >;

    /**
     * Create a LineItemInvoice.
     * @param {LineItemInvoiceCreateArgs} args - Arguments to create a LineItemInvoice.
     * @example
     * // Create one LineItemInvoice
     * const LineItemInvoice = await prisma.lineItemInvoice.create({
     *   data: {
     *     // ... data to create a LineItemInvoice
     *   }
     * })
     *
     **/
    create<T extends LineItemInvoiceCreateArgs<ExtArgs>>(
      args: SelectSubset<T, LineItemInvoiceCreateArgs<ExtArgs>>
    ): Prisma__LineItemInvoiceClient<
      $Result.GetResult<Prisma.$LineItemInvoicePayload<ExtArgs>, T, "create">,
      never,
      ExtArgs
    >;

    /**
     * Create many LineItemInvoices.
     *     @param {LineItemInvoiceCreateManyArgs} args - Arguments to create many LineItemInvoices.
     *     @example
     *     // Create many LineItemInvoices
     *     const lineItemInvoice = await prisma.lineItemInvoice.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *
     **/
    createMany<T extends LineItemInvoiceCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LineItemInvoiceCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a LineItemInvoice.
     * @param {LineItemInvoiceDeleteArgs} args - Arguments to delete one LineItemInvoice.
     * @example
     * // Delete one LineItemInvoice
     * const LineItemInvoice = await prisma.lineItemInvoice.delete({
     *   where: {
     *     // ... filter to delete one LineItemInvoice
     *   }
     * })
     *
     **/
    delete<T extends LineItemInvoiceDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, LineItemInvoiceDeleteArgs<ExtArgs>>
    ): Prisma__LineItemInvoiceClient<
      $Result.GetResult<Prisma.$LineItemInvoicePayload<ExtArgs>, T, "delete">,
      never,
      ExtArgs
    >;

    /**
     * Update one LineItemInvoice.
     * @param {LineItemInvoiceUpdateArgs} args - Arguments to update one LineItemInvoice.
     * @example
     * // Update one LineItemInvoice
     * const lineItemInvoice = await prisma.lineItemInvoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     **/
    update<T extends LineItemInvoiceUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, LineItemInvoiceUpdateArgs<ExtArgs>>
    ): Prisma__LineItemInvoiceClient<
      $Result.GetResult<Prisma.$LineItemInvoicePayload<ExtArgs>, T, "update">,
      never,
      ExtArgs
    >;

    /**
     * Delete zero or more LineItemInvoices.
     * @param {LineItemInvoiceDeleteManyArgs} args - Arguments to filter LineItemInvoices to delete.
     * @example
     * // Delete a few LineItemInvoices
     * const { count } = await prisma.lineItemInvoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     **/
    deleteMany<T extends LineItemInvoiceDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LineItemInvoiceDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more LineItemInvoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LineItemInvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LineItemInvoices
     * const lineItemInvoice = await prisma.lineItemInvoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     **/
    updateMany<T extends LineItemInvoiceUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, LineItemInvoiceUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one LineItemInvoice.
     * @param {LineItemInvoiceUpsertArgs} args - Arguments to update or create a LineItemInvoice.
     * @example
     * // Update or create a LineItemInvoice
     * const lineItemInvoice = await prisma.lineItemInvoice.upsert({
     *   create: {
     *     // ... data to create a LineItemInvoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LineItemInvoice we want to update
     *   }
     * })
     **/
    upsert<T extends LineItemInvoiceUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, LineItemInvoiceUpsertArgs<ExtArgs>>
    ): Prisma__LineItemInvoiceClient<
      $Result.GetResult<Prisma.$LineItemInvoicePayload<ExtArgs>, T, "upsert">,
      never,
      ExtArgs
    >;

    /**
     * Count the number of LineItemInvoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LineItemInvoiceCountArgs} args - Arguments to filter LineItemInvoices to count.
     * @example
     * // Count the number of LineItemInvoices
     * const count = await prisma.lineItemInvoice.count({
     *   where: {
     *     // ... the filter for the LineItemInvoices we want to count
     *   }
     * })
     **/
    count<T extends LineItemInvoiceCountArgs>(
      args?: Subset<T, LineItemInvoiceCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], LineItemInvoiceCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a LineItemInvoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LineItemInvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends LineItemInvoiceAggregateArgs>(
      args: Subset<T, LineItemInvoiceAggregateArgs>
    ): Prisma.PrismaPromise<GetLineItemInvoiceAggregateType<T>>;

    /**
     * Group by LineItemInvoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LineItemInvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends LineItemInvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LineItemInvoiceGroupByArgs["orderBy"] }
        : { orderBy?: LineItemInvoiceGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
        ? {
            [P in HavingFields]: P extends ByFields
              ? never
              : P extends string
              ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
              : [
                  Error,
                  "Field ",
                  P,
                  ` in "having" needs to be provided in "by"`
                ];
          }[HavingFields]
        : "take" extends Keys<T>
        ? "orderBy" extends Keys<T>
          ? ByValid extends True
            ? {}
            : {
                [P in OrderFields]: P extends ByFields
                  ? never
                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
              }[OrderFields]
          : 'Error: If you provide "take", you also need to provide "orderBy"'
        : "skip" extends Keys<T>
        ? "orderBy" extends Keys<T>
          ? ByValid extends True
            ? {}
            : {
                [P in OrderFields]: P extends ByFields
                  ? never
                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
              }[OrderFields]
          : 'Error: If you provide "skip", you also need to provide "orderBy"'
        : ByValid extends True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
          }[OrderFields]
    >(
      args: SubsetIntersection<T, LineItemInvoiceGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetLineItemInvoiceGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the LineItemInvoice model
     */
    readonly fields: LineItemInvoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LineItemInvoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LineItemInvoiceClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";

    invoice<T extends InvoicesDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, InvoicesDefaultArgs<ExtArgs>>
    ): Prisma__InvoicesClient<
      | $Result.GetResult<
          Prisma.$InvoicesPayload<ExtArgs>,
          T,
          "findUniqueOrThrow"
        >
      | Null,
      Null,
      ExtArgs
    >;

    line_item<T extends LineItemsDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, LineItemsDefaultArgs<ExtArgs>>
    ): Prisma__LineItemsClient<
      | $Result.GetResult<
          Prisma.$LineItemsPayload<ExtArgs>,
          T,
          "findUniqueOrThrow"
        >
      | Null,
      Null,
      ExtArgs
    >;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the LineItemInvoice model
   */
  interface LineItemInvoiceFieldRefs {
    readonly id: FieldRef<"LineItemInvoice", "Int">;
    readonly invoice_id: FieldRef<"LineItemInvoice", "Int">;
    readonly line_item_id: FieldRef<"LineItemInvoice", "Int">;
  }

  // Custom InputTypes

  /**
   * LineItemInvoice findUnique
   */
  export type LineItemInvoiceFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the LineItemInvoice
     */
    select?: LineItemInvoiceSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LineItemInvoiceInclude<ExtArgs> | null;
    /**
     * Filter, which LineItemInvoice to fetch.
     */
    where: LineItemInvoiceWhereUniqueInput;
  };

  /**
   * LineItemInvoice findUniqueOrThrow
   */
  export type LineItemInvoiceFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the LineItemInvoice
     */
    select?: LineItemInvoiceSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LineItemInvoiceInclude<ExtArgs> | null;
    /**
     * Filter, which LineItemInvoice to fetch.
     */
    where: LineItemInvoiceWhereUniqueInput;
  };

  /**
   * LineItemInvoice findFirst
   */
  export type LineItemInvoiceFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the LineItemInvoice
     */
    select?: LineItemInvoiceSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LineItemInvoiceInclude<ExtArgs> | null;
    /**
     * Filter, which LineItemInvoice to fetch.
     */
    where?: LineItemInvoiceWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of LineItemInvoices to fetch.
     */
    orderBy?:
      | LineItemInvoiceOrderByWithRelationInput
      | LineItemInvoiceOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for LineItemInvoices.
     */
    cursor?: LineItemInvoiceWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` LineItemInvoices from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` LineItemInvoices.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of LineItemInvoices.
     */
    distinct?:
      | LineItemInvoiceScalarFieldEnum
      | LineItemInvoiceScalarFieldEnum[];
  };

  /**
   * LineItemInvoice findFirstOrThrow
   */
  export type LineItemInvoiceFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the LineItemInvoice
     */
    select?: LineItemInvoiceSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LineItemInvoiceInclude<ExtArgs> | null;
    /**
     * Filter, which LineItemInvoice to fetch.
     */
    where?: LineItemInvoiceWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of LineItemInvoices to fetch.
     */
    orderBy?:
      | LineItemInvoiceOrderByWithRelationInput
      | LineItemInvoiceOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for LineItemInvoices.
     */
    cursor?: LineItemInvoiceWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` LineItemInvoices from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` LineItemInvoices.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of LineItemInvoices.
     */
    distinct?:
      | LineItemInvoiceScalarFieldEnum
      | LineItemInvoiceScalarFieldEnum[];
  };

  /**
   * LineItemInvoice findMany
   */
  export type LineItemInvoiceFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the LineItemInvoice
     */
    select?: LineItemInvoiceSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LineItemInvoiceInclude<ExtArgs> | null;
    /**
     * Filter, which LineItemInvoices to fetch.
     */
    where?: LineItemInvoiceWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of LineItemInvoices to fetch.
     */
    orderBy?:
      | LineItemInvoiceOrderByWithRelationInput
      | LineItemInvoiceOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing LineItemInvoices.
     */
    cursor?: LineItemInvoiceWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` LineItemInvoices from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` LineItemInvoices.
     */
    skip?: number;
    distinct?:
      | LineItemInvoiceScalarFieldEnum
      | LineItemInvoiceScalarFieldEnum[];
  };

  /**
   * LineItemInvoice create
   */
  export type LineItemInvoiceCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the LineItemInvoice
     */
    select?: LineItemInvoiceSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LineItemInvoiceInclude<ExtArgs> | null;
    /**
     * The data needed to create a LineItemInvoice.
     */
    data: XOR<LineItemInvoiceCreateInput, LineItemInvoiceUncheckedCreateInput>;
  };

  /**
   * LineItemInvoice createMany
   */
  export type LineItemInvoiceCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to create many LineItemInvoices.
     */
    data: LineItemInvoiceCreateManyInput | LineItemInvoiceCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * LineItemInvoice update
   */
  export type LineItemInvoiceUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the LineItemInvoice
     */
    select?: LineItemInvoiceSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LineItemInvoiceInclude<ExtArgs> | null;
    /**
     * The data needed to update a LineItemInvoice.
     */
    data: XOR<LineItemInvoiceUpdateInput, LineItemInvoiceUncheckedUpdateInput>;
    /**
     * Choose, which LineItemInvoice to update.
     */
    where: LineItemInvoiceWhereUniqueInput;
  };

  /**
   * LineItemInvoice updateMany
   */
  export type LineItemInvoiceUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * The data used to update LineItemInvoices.
     */
    data: XOR<
      LineItemInvoiceUpdateManyMutationInput,
      LineItemInvoiceUncheckedUpdateManyInput
    >;
    /**
     * Filter which LineItemInvoices to update
     */
    where?: LineItemInvoiceWhereInput;
  };

  /**
   * LineItemInvoice upsert
   */
  export type LineItemInvoiceUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the LineItemInvoice
     */
    select?: LineItemInvoiceSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LineItemInvoiceInclude<ExtArgs> | null;
    /**
     * The filter to search for the LineItemInvoice to update in case it exists.
     */
    where: LineItemInvoiceWhereUniqueInput;
    /**
     * In case the LineItemInvoice found by the `where` argument doesn't exist, create a new LineItemInvoice with this data.
     */
    create: XOR<
      LineItemInvoiceCreateInput,
      LineItemInvoiceUncheckedCreateInput
    >;
    /**
     * In case the LineItemInvoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<
      LineItemInvoiceUpdateInput,
      LineItemInvoiceUncheckedUpdateInput
    >;
  };

  /**
   * LineItemInvoice delete
   */
  export type LineItemInvoiceDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the LineItemInvoice
     */
    select?: LineItemInvoiceSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LineItemInvoiceInclude<ExtArgs> | null;
    /**
     * Filter which LineItemInvoice to delete.
     */
    where: LineItemInvoiceWhereUniqueInput;
  };

  /**
   * LineItemInvoice deleteMany
   */
  export type LineItemInvoiceDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Filter which LineItemInvoices to delete
     */
    where?: LineItemInvoiceWhereInput;
  };

  /**
   * LineItemInvoice without action
   */
  export type LineItemInvoiceDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = {
    /**
     * Select specific fields to fetch from the LineItemInvoice
     */
    select?: LineItemInvoiceSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LineItemInvoiceInclude<ExtArgs> | null;
  };

  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: "ReadUncommitted";
    ReadCommitted: "ReadCommitted";
    RepeatableRead: "RepeatableRead";
    Serializable: "Serializable";
  };

  export type TransactionIsolationLevel =
    (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel];

  export const TaxesScalarFieldEnum: {
    id: "id";
    name: "name";
    rate: "rate";
    description: "description";
  };

  export type TaxesScalarFieldEnum =
    (typeof TaxesScalarFieldEnum)[keyof typeof TaxesScalarFieldEnum];

  export const AddressesScalarFieldEnum: {
    id: "id";
    street1: "street1";
    street2: "street2";
    city: "city";
    state: "state";
    zip_code: "zip_code";
    country: "country";
  };

  export type AddressesScalarFieldEnum =
    (typeof AddressesScalarFieldEnum)[keyof typeof AddressesScalarFieldEnum];

  export const UsersScalarFieldEnum: {
    id: "id";
    email: "email";
    password: "password";
    first_name: "first_name";
    last_name: "last_name";
    phone_number: "phone_number";
    company_name: "company_name";
    subscription_id: "subscription_id";
    free_trial_expiration_date: "free_trial_expiration_date";
    default_tax_id: "default_tax_id";
    address_id: "address_id";
    settings: "settings";
  };

  export type UsersScalarFieldEnum =
    (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum];

  export const ClientsScalarFieldEnum: {
    id: "id";
    title: "title";
    tags: "tags";
    first_name: "first_name";
    last_name: "last_name";
    company_name: "company_name";
    use_company_name_as_primary: "use_company_name_as_primary";
    mobile_phone_number: "mobile_phone_number";
    work_phone_number: "work_phone_number";
    email: "email";
    quote_follow_up: "quote_follow_up";
    job_follow_up: "job_follow_up";
    invoice_follow_up: "invoice_follow_up";
    upcoming_visit_reminder: "upcoming_visit_reminder";
    referred_by: "referred_by";
    billing_address_same_as_property: "billing_address_same_as_property";
    property_address_id: "property_address_id";
    billing_address_id: "billing_address_id";
    created_date: "created_date";
    status: "status";
    belongs_to_id: "belongs_to_id";
  };

  export type ClientsScalarFieldEnum =
    (typeof ClientsScalarFieldEnum)[keyof typeof ClientsScalarFieldEnum];

  export const AssessmentsScalarFieldEnum: {
    id: "id";
    instructions: "instructions";
    start_date: "start_date";
    end_date: "end_date";
    schedule_later: "schedule_later";
    start_time: "start_time";
    end_time: "end_time";
    any_time: "any_time";
    team: "team";
  };

  export type AssessmentsScalarFieldEnum =
    (typeof AssessmentsScalarFieldEnum)[keyof typeof AssessmentsScalarFieldEnum];

  export const RequestsScalarFieldEnum: {
    id: "id";
    status: "status";
    tags: "tags";
    emailed_to_client: "emailed_to_client";
    texted_to_client: "texted_to_client";
    title: "title";
    service_details: "service_details";
    assessment_date: "assessment_date";
    backup_assessment__date: "backup_assessment__date";
    preferred_arrival_times: "preferred_arrival_times";
    on_site_assesment_required: "on_site_assesment_required";
    client_id: "client_id";
    assessment_id: "assessment_id";
    internal_notes: "internal_notes";
    internalAttachmentUrl: "internalAttachmentUrl";
    link_to_releated_quotes: "link_to_releated_quotes";
    link_to_releated_jobs: "link_to_releated_jobs";
    link_to_releated_invoices: "link_to_releated_invoices";
    belongs_to_id: "belongs_to_id";
  };

  export type RequestsScalarFieldEnum =
    (typeof RequestsScalarFieldEnum)[keyof typeof RequestsScalarFieldEnum];

  export const LineItemsScalarFieldEnum: {
    id: "id";
    type: "type";
    name: "name";
    description: "description";
    quantity: "quantity";
    unit_price: "unit_price";
    markup: "markup";
    img_url: "img_url";
    recommend_item: "recommend_item";
  };

  export type LineItemsScalarFieldEnum =
    (typeof LineItemsScalarFieldEnum)[keyof typeof LineItemsScalarFieldEnum];

  export const QuotesScalarFieldEnum: {
    id: "id";
    tags: "tags";
    emailed_to_client: "emailed_to_client";
    texted_to_client: "texted_to_client";
    status: "status";
    title: "title";
    quote_number: "quote_number";
    opportunity_rating: "opportunity_rating";
    client_id: "client_id";
    client_message: "client_message";
    discount: "discount";
    discount_unit: "discount_unit";
    tax_id: "tax_id";
    required_deposit: "required_deposit";
    link_to_releated_jobs: "link_to_releated_jobs";
    link_to_releated_invoices: "link_to_releated_invoices";
    belongs_to_id: "belongs_to_id";
  };

  export type QuotesScalarFieldEnum =
    (typeof QuotesScalarFieldEnum)[keyof typeof QuotesScalarFieldEnum];

  export const LineItemQuoteScalarFieldEnum: {
    id: "id";
    quote_id: "quote_id";
    line_item_id: "line_item_id";
  };

  export type LineItemQuoteScalarFieldEnum =
    (typeof LineItemQuoteScalarFieldEnum)[keyof typeof LineItemQuoteScalarFieldEnum];

  export const QuoteRequestScalarFieldEnum: {
    id: "id";
    quoteId: "quoteId";
    requestId: "requestId";
  };

  export type QuoteRequestScalarFieldEnum =
    (typeof QuoteRequestScalarFieldEnum)[keyof typeof QuoteRequestScalarFieldEnum];

  export const JobsScalarFieldEnum: {
    id: "id";
    tags: "tags";
    emailed_to_client: "emailed_to_client";
    texted_to_client: "texted_to_client";
    status: "status";
    client_id: "client_id";
    title: "title";
    instructions: "instructions";
    number: "number";
    schedule_type: "schedule_type";
    recurring_frequency: "recurring_frequency";
    recurring_interval: "recurring_interval";
    day_of_week: "day_of_week";
    day_of_year: "day_of_year";
    duration: "duration";
    start_date: "start_date";
    end_date: "end_date";
    start_time: "start_time";
    end_time: "end_time";
    schedule_later: "schedule_later";
    team: "team";
    email_team: "email_team";
    invoice_reminder: "invoice_reminder";
    internal_notes: "internal_notes";
    internal_attachment_url: "internal_attachment_url";
    link_to_related_invoices: "link_to_related_invoices";
    belongs_to_id: "belongs_to_id";
  };

  export type JobsScalarFieldEnum =
    (typeof JobsScalarFieldEnum)[keyof typeof JobsScalarFieldEnum];

  export const LineItemJobScalarFieldEnum: {
    id: "id";
    job_id: "job_id";
    line_item_id: "line_item_id";
  };

  export type LineItemJobScalarFieldEnum =
    (typeof LineItemJobScalarFieldEnum)[keyof typeof LineItemJobScalarFieldEnum];

  export const JobRequestScalarFieldEnum: {
    id: "id";
    job_id: "job_id";
    request_id: "request_id";
  };

  export type JobRequestScalarFieldEnum =
    (typeof JobRequestScalarFieldEnum)[keyof typeof JobRequestScalarFieldEnum];

  export const JobQuoteScalarFieldEnum: {
    id: "id";
    job_id: "job_id";
    quote_id: "quote_id";
  };

  export type JobQuoteScalarFieldEnum =
    (typeof JobQuoteScalarFieldEnum)[keyof typeof JobQuoteScalarFieldEnum];

  export const InvoicesScalarFieldEnum: {
    id: "id";
    tags: "tags";
    emailed_to_client: "emailed_to_client";
    texted_to_client: "texted_to_client";
    issued_date: "issued_date";
    due_date: "due_date";
    status: "status";
    type: "type";
    subject: "subject";
    client_id: "client_id";
    job_id: "job_id";
    tax_id: "tax_id";
    client_message: "client_message";
    internal_notes: "internal_notes";
    internalAttachmentUrl: "internalAttachmentUrl";
    belongs_to_id: "belongs_to_id";
  };

  export type InvoicesScalarFieldEnum =
    (typeof InvoicesScalarFieldEnum)[keyof typeof InvoicesScalarFieldEnum];

  export const LineItemInvoiceScalarFieldEnum: {
    id: "id";
    invoice_id: "invoice_id";
    line_item_id: "line_item_id";
  };

  export type LineItemInvoiceScalarFieldEnum =
    (typeof LineItemInvoiceScalarFieldEnum)[keyof typeof LineItemInvoiceScalarFieldEnum];

  export const SortOrder: {
    asc: "asc";
    desc: "desc";
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder];

  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull;
    JsonNull: typeof JsonNull;
  };

  export type NullableJsonNullValueInput =
    (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput];

  export const QueryMode: {
    default: "default";
    insensitive: "insensitive";
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode];

  export const NullsOrder: {
    first: "first";
    last: "last";
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder];

  export const JsonNullValueFilter: {
    DbNull: typeof DbNull;
    JsonNull: typeof JsonNull;
    AnyNull: typeof AnyNull;
  };

  export type JsonNullValueFilter =
    (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter];

  /**
   * Field references
   */

  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "Int"
  >;

  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "Int[]"
  >;

  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "String"
  >;

  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "String[]"
  >;

  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "Float"
  >;

  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "Float[]"
  >;

  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "DateTime"
  >;

  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "DateTime[]"
  >;

  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "Json"
  >;

  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "Boolean"
  >;

  /**
   * Deep Input Types
   */

  export type TaxesWhereInput = {
    AND?: TaxesWhereInput | TaxesWhereInput[];
    OR?: TaxesWhereInput[];
    NOT?: TaxesWhereInput | TaxesWhereInput[];
    id?: IntFilter<"Taxes"> | number;
    name?: StringFilter<"Taxes"> | string;
    rate?: FloatFilter<"Taxes"> | number;
    description?: StringNullableFilter<"Taxes"> | string | null;
    users?: UsersListRelationFilter;
    quotes?: QuotesListRelationFilter;
    invoices?: InvoicesListRelationFilter;
  };

  export type TaxesOrderByWithRelationInput = {
    id?: SortOrder;
    name?: SortOrder;
    rate?: SortOrder;
    description?: SortOrderInput | SortOrder;
    users?: UsersOrderByRelationAggregateInput;
    quotes?: QuotesOrderByRelationAggregateInput;
    invoices?: InvoicesOrderByRelationAggregateInput;
  };

  export type TaxesWhereUniqueInput = Prisma.AtLeast<
    {
      id?: number;
      AND?: TaxesWhereInput | TaxesWhereInput[];
      OR?: TaxesWhereInput[];
      NOT?: TaxesWhereInput | TaxesWhereInput[];
      name?: StringFilter<"Taxes"> | string;
      rate?: FloatFilter<"Taxes"> | number;
      description?: StringNullableFilter<"Taxes"> | string | null;
      users?: UsersListRelationFilter;
      quotes?: QuotesListRelationFilter;
      invoices?: InvoicesListRelationFilter;
    },
    "id"
  >;

  export type TaxesOrderByWithAggregationInput = {
    id?: SortOrder;
    name?: SortOrder;
    rate?: SortOrder;
    description?: SortOrderInput | SortOrder;
    _count?: TaxesCountOrderByAggregateInput;
    _avg?: TaxesAvgOrderByAggregateInput;
    _max?: TaxesMaxOrderByAggregateInput;
    _min?: TaxesMinOrderByAggregateInput;
    _sum?: TaxesSumOrderByAggregateInput;
  };

  export type TaxesScalarWhereWithAggregatesInput = {
    AND?:
      | TaxesScalarWhereWithAggregatesInput
      | TaxesScalarWhereWithAggregatesInput[];
    OR?: TaxesScalarWhereWithAggregatesInput[];
    NOT?:
      | TaxesScalarWhereWithAggregatesInput
      | TaxesScalarWhereWithAggregatesInput[];
    id?: IntWithAggregatesFilter<"Taxes"> | number;
    name?: StringWithAggregatesFilter<"Taxes"> | string;
    rate?: FloatWithAggregatesFilter<"Taxes"> | number;
    description?: StringNullableWithAggregatesFilter<"Taxes"> | string | null;
  };

  export type AddressesWhereInput = {
    AND?: AddressesWhereInput | AddressesWhereInput[];
    OR?: AddressesWhereInput[];
    NOT?: AddressesWhereInput | AddressesWhereInput[];
    id?: IntFilter<"Addresses"> | number;
    street1?: StringFilter<"Addresses"> | string;
    street2?: StringNullableFilter<"Addresses"> | string | null;
    city?: StringFilter<"Addresses"> | string;
    state?: StringFilter<"Addresses"> | string;
    zip_code?: StringFilter<"Addresses"> | string;
    country?: StringFilter<"Addresses"> | string;
    users?: UsersListRelationFilter;
    property_clients?: ClientsListRelationFilter;
    billing_clients?: ClientsListRelationFilter;
  };

  export type AddressesOrderByWithRelationInput = {
    id?: SortOrder;
    street1?: SortOrder;
    street2?: SortOrderInput | SortOrder;
    city?: SortOrder;
    state?: SortOrder;
    zip_code?: SortOrder;
    country?: SortOrder;
    users?: UsersOrderByRelationAggregateInput;
    property_clients?: ClientsOrderByRelationAggregateInput;
    billing_clients?: ClientsOrderByRelationAggregateInput;
  };

  export type AddressesWhereUniqueInput = Prisma.AtLeast<
    {
      id?: number;
      AND?: AddressesWhereInput | AddressesWhereInput[];
      OR?: AddressesWhereInput[];
      NOT?: AddressesWhereInput | AddressesWhereInput[];
      street1?: StringFilter<"Addresses"> | string;
      street2?: StringNullableFilter<"Addresses"> | string | null;
      city?: StringFilter<"Addresses"> | string;
      state?: StringFilter<"Addresses"> | string;
      zip_code?: StringFilter<"Addresses"> | string;
      country?: StringFilter<"Addresses"> | string;
      users?: UsersListRelationFilter;
      property_clients?: ClientsListRelationFilter;
      billing_clients?: ClientsListRelationFilter;
    },
    "id"
  >;

  export type AddressesOrderByWithAggregationInput = {
    id?: SortOrder;
    street1?: SortOrder;
    street2?: SortOrderInput | SortOrder;
    city?: SortOrder;
    state?: SortOrder;
    zip_code?: SortOrder;
    country?: SortOrder;
    _count?: AddressesCountOrderByAggregateInput;
    _avg?: AddressesAvgOrderByAggregateInput;
    _max?: AddressesMaxOrderByAggregateInput;
    _min?: AddressesMinOrderByAggregateInput;
    _sum?: AddressesSumOrderByAggregateInput;
  };

  export type AddressesScalarWhereWithAggregatesInput = {
    AND?:
      | AddressesScalarWhereWithAggregatesInput
      | AddressesScalarWhereWithAggregatesInput[];
    OR?: AddressesScalarWhereWithAggregatesInput[];
    NOT?:
      | AddressesScalarWhereWithAggregatesInput
      | AddressesScalarWhereWithAggregatesInput[];
    id?: IntWithAggregatesFilter<"Addresses"> | number;
    street1?: StringWithAggregatesFilter<"Addresses"> | string;
    street2?: StringNullableWithAggregatesFilter<"Addresses"> | string | null;
    city?: StringWithAggregatesFilter<"Addresses"> | string;
    state?: StringWithAggregatesFilter<"Addresses"> | string;
    zip_code?: StringWithAggregatesFilter<"Addresses"> | string;
    country?: StringWithAggregatesFilter<"Addresses"> | string;
  };

  export type UsersWhereInput = {
    AND?: UsersWhereInput | UsersWhereInput[];
    OR?: UsersWhereInput[];
    NOT?: UsersWhereInput | UsersWhereInput[];
    id?: IntFilter<"Users"> | number;
    email?: StringNullableFilter<"Users"> | string | null;
    password?: StringFilter<"Users"> | string;
    first_name?: StringFilter<"Users"> | string;
    last_name?: StringFilter<"Users"> | string;
    phone_number?: StringNullableFilter<"Users"> | string | null;
    company_name?: StringNullableFilter<"Users"> | string | null;
    subscription_id?: StringNullableFilter<"Users"> | string | null;
    free_trial_expiration_date?:
      | DateTimeNullableFilter<"Users">
      | Date
      | string
      | null;
    default_tax_id?: IntNullableFilter<"Users"> | number | null;
    address_id?: IntNullableFilter<"Users"> | number | null;
    settings?: JsonNullableFilter<"Users">;
    default_tax?: XOR<TaxesNullableRelationFilter, TaxesWhereInput> | null;
    address?: XOR<AddressesNullableRelationFilter, AddressesWhereInput> | null;
    clients?: ClientsListRelationFilter;
    requests?: RequestsListRelationFilter;
    jobs?: JobsListRelationFilter;
    quotes?: QuotesListRelationFilter;
    invoices?: InvoicesListRelationFilter;
  };

  export type UsersOrderByWithRelationInput = {
    id?: SortOrder;
    email?: SortOrderInput | SortOrder;
    password?: SortOrder;
    first_name?: SortOrder;
    last_name?: SortOrder;
    phone_number?: SortOrderInput | SortOrder;
    company_name?: SortOrderInput | SortOrder;
    subscription_id?: SortOrderInput | SortOrder;
    free_trial_expiration_date?: SortOrderInput | SortOrder;
    default_tax_id?: SortOrderInput | SortOrder;
    address_id?: SortOrderInput | SortOrder;
    settings?: SortOrderInput | SortOrder;
    default_tax?: TaxesOrderByWithRelationInput;
    address?: AddressesOrderByWithRelationInput;
    clients?: ClientsOrderByRelationAggregateInput;
    requests?: RequestsOrderByRelationAggregateInput;
    jobs?: JobsOrderByRelationAggregateInput;
    quotes?: QuotesOrderByRelationAggregateInput;
    invoices?: InvoicesOrderByRelationAggregateInput;
  };

  export type UsersWhereUniqueInput = Prisma.AtLeast<
    {
      id?: number;
      email?: string;
      phone_number?: string;
      AND?: UsersWhereInput | UsersWhereInput[];
      OR?: UsersWhereInput[];
      NOT?: UsersWhereInput | UsersWhereInput[];
      password?: StringFilter<"Users"> | string;
      first_name?: StringFilter<"Users"> | string;
      last_name?: StringFilter<"Users"> | string;
      company_name?: StringNullableFilter<"Users"> | string | null;
      subscription_id?: StringNullableFilter<"Users"> | string | null;
      free_trial_expiration_date?:
        | DateTimeNullableFilter<"Users">
        | Date
        | string
        | null;
      default_tax_id?: IntNullableFilter<"Users"> | number | null;
      address_id?: IntNullableFilter<"Users"> | number | null;
      settings?: JsonNullableFilter<"Users">;
      default_tax?: XOR<TaxesNullableRelationFilter, TaxesWhereInput> | null;
      address?: XOR<
        AddressesNullableRelationFilter,
        AddressesWhereInput
      > | null;
      clients?: ClientsListRelationFilter;
      requests?: RequestsListRelationFilter;
      jobs?: JobsListRelationFilter;
      quotes?: QuotesListRelationFilter;
      invoices?: InvoicesListRelationFilter;
    },
    "id" | "email" | "phone_number"
  >;

  export type UsersOrderByWithAggregationInput = {
    id?: SortOrder;
    email?: SortOrderInput | SortOrder;
    password?: SortOrder;
    first_name?: SortOrder;
    last_name?: SortOrder;
    phone_number?: SortOrderInput | SortOrder;
    company_name?: SortOrderInput | SortOrder;
    subscription_id?: SortOrderInput | SortOrder;
    free_trial_expiration_date?: SortOrderInput | SortOrder;
    default_tax_id?: SortOrderInput | SortOrder;
    address_id?: SortOrderInput | SortOrder;
    settings?: SortOrderInput | SortOrder;
    _count?: UsersCountOrderByAggregateInput;
    _avg?: UsersAvgOrderByAggregateInput;
    _max?: UsersMaxOrderByAggregateInput;
    _min?: UsersMinOrderByAggregateInput;
    _sum?: UsersSumOrderByAggregateInput;
  };

  export type UsersScalarWhereWithAggregatesInput = {
    AND?:
      | UsersScalarWhereWithAggregatesInput
      | UsersScalarWhereWithAggregatesInput[];
    OR?: UsersScalarWhereWithAggregatesInput[];
    NOT?:
      | UsersScalarWhereWithAggregatesInput
      | UsersScalarWhereWithAggregatesInput[];
    id?: IntWithAggregatesFilter<"Users"> | number;
    email?: StringNullableWithAggregatesFilter<"Users"> | string | null;
    password?: StringWithAggregatesFilter<"Users"> | string;
    first_name?: StringWithAggregatesFilter<"Users"> | string;
    last_name?: StringWithAggregatesFilter<"Users"> | string;
    phone_number?: StringNullableWithAggregatesFilter<"Users"> | string | null;
    company_name?: StringNullableWithAggregatesFilter<"Users"> | string | null;
    subscription_id?:
      | StringNullableWithAggregatesFilter<"Users">
      | string
      | null;
    free_trial_expiration_date?:
      | DateTimeNullableWithAggregatesFilter<"Users">
      | Date
      | string
      | null;
    default_tax_id?: IntNullableWithAggregatesFilter<"Users"> | number | null;
    address_id?: IntNullableWithAggregatesFilter<"Users"> | number | null;
    settings?: JsonNullableWithAggregatesFilter<"Users">;
  };

  export type ClientsWhereInput = {
    AND?: ClientsWhereInput | ClientsWhereInput[];
    OR?: ClientsWhereInput[];
    NOT?: ClientsWhereInput | ClientsWhereInput[];
    id?: IntFilter<"Clients"> | number;
    title?: StringFilter<"Clients"> | string;
    tags?: JsonNullableFilter<"Clients">;
    first_name?: StringFilter<"Clients"> | string;
    last_name?: StringFilter<"Clients"> | string;
    company_name?: StringNullableFilter<"Clients"> | string | null;
    use_company_name_as_primary?: BoolFilter<"Clients"> | boolean;
    mobile_phone_number?: StringNullableFilter<"Clients"> | string | null;
    work_phone_number?: StringNullableFilter<"Clients"> | string | null;
    email?: StringNullableFilter<"Clients"> | string | null;
    quote_follow_up?: BoolFilter<"Clients"> | boolean;
    job_follow_up?: BoolFilter<"Clients"> | boolean;
    invoice_follow_up?: BoolFilter<"Clients"> | boolean;
    upcoming_visit_reminder?: BoolFilter<"Clients"> | boolean;
    referred_by?: StringNullableFilter<"Clients"> | string | null;
    billing_address_same_as_property?: BoolFilter<"Clients"> | boolean;
    property_address_id?: IntNullableFilter<"Clients"> | number | null;
    billing_address_id?: IntNullableFilter<"Clients"> | number | null;
    created_date?: DateTimeFilter<"Clients"> | Date | string;
    status?: StringNullableFilter<"Clients"> | string | null;
    belongs_to_id?: IntFilter<"Clients"> | number;
    property_address?: XOR<
      AddressesNullableRelationFilter,
      AddressesWhereInput
    > | null;
    billing_address?: XOR<
      AddressesNullableRelationFilter,
      AddressesWhereInput
    > | null;
    requests?: RequestsListRelationFilter;
    quotes?: QuotesListRelationFilter;
    jobs?: JobsListRelationFilter;
    invoices?: InvoicesListRelationFilter;
    belongs_to?: XOR<UsersRelationFilter, UsersWhereInput>;
  };

  export type ClientsOrderByWithRelationInput = {
    id?: SortOrder;
    title?: SortOrder;
    tags?: SortOrderInput | SortOrder;
    first_name?: SortOrder;
    last_name?: SortOrder;
    company_name?: SortOrderInput | SortOrder;
    use_company_name_as_primary?: SortOrder;
    mobile_phone_number?: SortOrderInput | SortOrder;
    work_phone_number?: SortOrderInput | SortOrder;
    email?: SortOrderInput | SortOrder;
    quote_follow_up?: SortOrder;
    job_follow_up?: SortOrder;
    invoice_follow_up?: SortOrder;
    upcoming_visit_reminder?: SortOrder;
    referred_by?: SortOrderInput | SortOrder;
    billing_address_same_as_property?: SortOrder;
    property_address_id?: SortOrderInput | SortOrder;
    billing_address_id?: SortOrderInput | SortOrder;
    created_date?: SortOrder;
    status?: SortOrderInput | SortOrder;
    belongs_to_id?: SortOrder;
    property_address?: AddressesOrderByWithRelationInput;
    billing_address?: AddressesOrderByWithRelationInput;
    requests?: RequestsOrderByRelationAggregateInput;
    quotes?: QuotesOrderByRelationAggregateInput;
    jobs?: JobsOrderByRelationAggregateInput;
    invoices?: InvoicesOrderByRelationAggregateInput;
    belongs_to?: UsersOrderByWithRelationInput;
  };

  export type ClientsWhereUniqueInput = Prisma.AtLeast<
    {
      id?: number;
      AND?: ClientsWhereInput | ClientsWhereInput[];
      OR?: ClientsWhereInput[];
      NOT?: ClientsWhereInput | ClientsWhereInput[];
      title?: StringFilter<"Clients"> | string;
      tags?: JsonNullableFilter<"Clients">;
      first_name?: StringFilter<"Clients"> | string;
      last_name?: StringFilter<"Clients"> | string;
      company_name?: StringNullableFilter<"Clients"> | string | null;
      use_company_name_as_primary?: BoolFilter<"Clients"> | boolean;
      mobile_phone_number?: StringNullableFilter<"Clients"> | string | null;
      work_phone_number?: StringNullableFilter<"Clients"> | string | null;
      email?: StringNullableFilter<"Clients"> | string | null;
      quote_follow_up?: BoolFilter<"Clients"> | boolean;
      job_follow_up?: BoolFilter<"Clients"> | boolean;
      invoice_follow_up?: BoolFilter<"Clients"> | boolean;
      upcoming_visit_reminder?: BoolFilter<"Clients"> | boolean;
      referred_by?: StringNullableFilter<"Clients"> | string | null;
      billing_address_same_as_property?: BoolFilter<"Clients"> | boolean;
      property_address_id?: IntNullableFilter<"Clients"> | number | null;
      billing_address_id?: IntNullableFilter<"Clients"> | number | null;
      created_date?: DateTimeFilter<"Clients"> | Date | string;
      status?: StringNullableFilter<"Clients"> | string | null;
      belongs_to_id?: IntFilter<"Clients"> | number;
      property_address?: XOR<
        AddressesNullableRelationFilter,
        AddressesWhereInput
      > | null;
      billing_address?: XOR<
        AddressesNullableRelationFilter,
        AddressesWhereInput
      > | null;
      requests?: RequestsListRelationFilter;
      quotes?: QuotesListRelationFilter;
      jobs?: JobsListRelationFilter;
      invoices?: InvoicesListRelationFilter;
      belongs_to?: XOR<UsersRelationFilter, UsersWhereInput>;
    },
    "id"
  >;

  export type ClientsOrderByWithAggregationInput = {
    id?: SortOrder;
    title?: SortOrder;
    tags?: SortOrderInput | SortOrder;
    first_name?: SortOrder;
    last_name?: SortOrder;
    company_name?: SortOrderInput | SortOrder;
    use_company_name_as_primary?: SortOrder;
    mobile_phone_number?: SortOrderInput | SortOrder;
    work_phone_number?: SortOrderInput | SortOrder;
    email?: SortOrderInput | SortOrder;
    quote_follow_up?: SortOrder;
    job_follow_up?: SortOrder;
    invoice_follow_up?: SortOrder;
    upcoming_visit_reminder?: SortOrder;
    referred_by?: SortOrderInput | SortOrder;
    billing_address_same_as_property?: SortOrder;
    property_address_id?: SortOrderInput | SortOrder;
    billing_address_id?: SortOrderInput | SortOrder;
    created_date?: SortOrder;
    status?: SortOrderInput | SortOrder;
    belongs_to_id?: SortOrder;
    _count?: ClientsCountOrderByAggregateInput;
    _avg?: ClientsAvgOrderByAggregateInput;
    _max?: ClientsMaxOrderByAggregateInput;
    _min?: ClientsMinOrderByAggregateInput;
    _sum?: ClientsSumOrderByAggregateInput;
  };

  export type ClientsScalarWhereWithAggregatesInput = {
    AND?:
      | ClientsScalarWhereWithAggregatesInput
      | ClientsScalarWhereWithAggregatesInput[];
    OR?: ClientsScalarWhereWithAggregatesInput[];
    NOT?:
      | ClientsScalarWhereWithAggregatesInput
      | ClientsScalarWhereWithAggregatesInput[];
    id?: IntWithAggregatesFilter<"Clients"> | number;
    title?: StringWithAggregatesFilter<"Clients"> | string;
    tags?: JsonNullableWithAggregatesFilter<"Clients">;
    first_name?: StringWithAggregatesFilter<"Clients"> | string;
    last_name?: StringWithAggregatesFilter<"Clients"> | string;
    company_name?:
      | StringNullableWithAggregatesFilter<"Clients">
      | string
      | null;
    use_company_name_as_primary?: BoolWithAggregatesFilter<"Clients"> | boolean;
    mobile_phone_number?:
      | StringNullableWithAggregatesFilter<"Clients">
      | string
      | null;
    work_phone_number?:
      | StringNullableWithAggregatesFilter<"Clients">
      | string
      | null;
    email?: StringNullableWithAggregatesFilter<"Clients"> | string | null;
    quote_follow_up?: BoolWithAggregatesFilter<"Clients"> | boolean;
    job_follow_up?: BoolWithAggregatesFilter<"Clients"> | boolean;
    invoice_follow_up?: BoolWithAggregatesFilter<"Clients"> | boolean;
    upcoming_visit_reminder?: BoolWithAggregatesFilter<"Clients"> | boolean;
    referred_by?: StringNullableWithAggregatesFilter<"Clients"> | string | null;
    billing_address_same_as_property?:
      | BoolWithAggregatesFilter<"Clients">
      | boolean;
    property_address_id?:
      | IntNullableWithAggregatesFilter<"Clients">
      | number
      | null;
    billing_address_id?:
      | IntNullableWithAggregatesFilter<"Clients">
      | number
      | null;
    created_date?: DateTimeWithAggregatesFilter<"Clients"> | Date | string;
    status?: StringNullableWithAggregatesFilter<"Clients"> | string | null;
    belongs_to_id?: IntWithAggregatesFilter<"Clients"> | number;
  };

  export type AssessmentsWhereInput = {
    AND?: AssessmentsWhereInput | AssessmentsWhereInput[];
    OR?: AssessmentsWhereInput[];
    NOT?: AssessmentsWhereInput | AssessmentsWhereInput[];
    id?: IntFilter<"Assessments"> | number;
    instructions?: StringNullableFilter<"Assessments"> | string | null;
    start_date?: DateTimeNullableFilter<"Assessments"> | Date | string | null;
    end_date?: DateTimeNullableFilter<"Assessments"> | Date | string | null;
    schedule_later?: BoolFilter<"Assessments"> | boolean;
    start_time?: DateTimeNullableFilter<"Assessments"> | Date | string | null;
    end_time?: DateTimeNullableFilter<"Assessments"> | Date | string | null;
    any_time?: BoolFilter<"Assessments"> | boolean;
    team?: StringNullableFilter<"Assessments"> | string | null;
    requests?: RequestsListRelationFilter;
  };

  export type AssessmentsOrderByWithRelationInput = {
    id?: SortOrder;
    instructions?: SortOrderInput | SortOrder;
    start_date?: SortOrderInput | SortOrder;
    end_date?: SortOrderInput | SortOrder;
    schedule_later?: SortOrder;
    start_time?: SortOrderInput | SortOrder;
    end_time?: SortOrderInput | SortOrder;
    any_time?: SortOrder;
    team?: SortOrderInput | SortOrder;
    requests?: RequestsOrderByRelationAggregateInput;
  };

  export type AssessmentsWhereUniqueInput = Prisma.AtLeast<
    {
      id?: number;
      AND?: AssessmentsWhereInput | AssessmentsWhereInput[];
      OR?: AssessmentsWhereInput[];
      NOT?: AssessmentsWhereInput | AssessmentsWhereInput[];
      instructions?: StringNullableFilter<"Assessments"> | string | null;
      start_date?: DateTimeNullableFilter<"Assessments"> | Date | string | null;
      end_date?: DateTimeNullableFilter<"Assessments"> | Date | string | null;
      schedule_later?: BoolFilter<"Assessments"> | boolean;
      start_time?: DateTimeNullableFilter<"Assessments"> | Date | string | null;
      end_time?: DateTimeNullableFilter<"Assessments"> | Date | string | null;
      any_time?: BoolFilter<"Assessments"> | boolean;
      team?: StringNullableFilter<"Assessments"> | string | null;
      requests?: RequestsListRelationFilter;
    },
    "id"
  >;

  export type AssessmentsOrderByWithAggregationInput = {
    id?: SortOrder;
    instructions?: SortOrderInput | SortOrder;
    start_date?: SortOrderInput | SortOrder;
    end_date?: SortOrderInput | SortOrder;
    schedule_later?: SortOrder;
    start_time?: SortOrderInput | SortOrder;
    end_time?: SortOrderInput | SortOrder;
    any_time?: SortOrder;
    team?: SortOrderInput | SortOrder;
    _count?: AssessmentsCountOrderByAggregateInput;
    _avg?: AssessmentsAvgOrderByAggregateInput;
    _max?: AssessmentsMaxOrderByAggregateInput;
    _min?: AssessmentsMinOrderByAggregateInput;
    _sum?: AssessmentsSumOrderByAggregateInput;
  };

  export type AssessmentsScalarWhereWithAggregatesInput = {
    AND?:
      | AssessmentsScalarWhereWithAggregatesInput
      | AssessmentsScalarWhereWithAggregatesInput[];
    OR?: AssessmentsScalarWhereWithAggregatesInput[];
    NOT?:
      | AssessmentsScalarWhereWithAggregatesInput
      | AssessmentsScalarWhereWithAggregatesInput[];
    id?: IntWithAggregatesFilter<"Assessments"> | number;
    instructions?:
      | StringNullableWithAggregatesFilter<"Assessments">
      | string
      | null;
    start_date?:
      | DateTimeNullableWithAggregatesFilter<"Assessments">
      | Date
      | string
      | null;
    end_date?:
      | DateTimeNullableWithAggregatesFilter<"Assessments">
      | Date
      | string
      | null;
    schedule_later?: BoolWithAggregatesFilter<"Assessments"> | boolean;
    start_time?:
      | DateTimeNullableWithAggregatesFilter<"Assessments">
      | Date
      | string
      | null;
    end_time?:
      | DateTimeNullableWithAggregatesFilter<"Assessments">
      | Date
      | string
      | null;
    any_time?: BoolWithAggregatesFilter<"Assessments"> | boolean;
    team?: StringNullableWithAggregatesFilter<"Assessments"> | string | null;
  };

  export type RequestsWhereInput = {
    AND?: RequestsWhereInput | RequestsWhereInput[];
    OR?: RequestsWhereInput[];
    NOT?: RequestsWhereInput | RequestsWhereInput[];
    id?: IntFilter<"Requests"> | number;
    status?: StringFilter<"Requests"> | string;
    tags?: JsonNullableFilter<"Requests">;
    emailed_to_client?: BoolFilter<"Requests"> | boolean;
    texted_to_client?: BoolFilter<"Requests"> | boolean;
    title?: StringFilter<"Requests"> | string;
    service_details?: StringFilter<"Requests"> | string;
    assessment_date?: DateTimeFilter<"Requests"> | Date | string;
    backup_assessment__date?:
      | DateTimeNullableFilter<"Requests">
      | Date
      | string
      | null;
    preferred_arrival_times?: StringNullableFilter<"Requests"> | string | null;
    on_site_assesment_required?: BoolFilter<"Requests"> | boolean;
    client_id?: IntFilter<"Requests"> | number;
    assessment_id?: IntFilter<"Requests"> | number;
    internal_notes?: StringFilter<"Requests"> | string;
    internalAttachmentUrl?: StringFilter<"Requests"> | string;
    link_to_releated_quotes?: BoolFilter<"Requests"> | boolean;
    link_to_releated_jobs?: BoolFilter<"Requests"> | boolean;
    link_to_releated_invoices?: BoolFilter<"Requests"> | boolean;
    belongs_to_id?: IntFilter<"Requests"> | number;
    assessment?: XOR<AssessmentsRelationFilter, AssessmentsWhereInput>;
    client?: XOR<ClientsRelationFilter, ClientsWhereInput>;
    quotes?: QuoteRequestListRelationFilter;
    job_requests?: JobRequestListRelationFilter;
    belongs_to?: XOR<UsersRelationFilter, UsersWhereInput>;
  };

  export type RequestsOrderByWithRelationInput = {
    id?: SortOrder;
    status?: SortOrder;
    tags?: SortOrderInput | SortOrder;
    emailed_to_client?: SortOrder;
    texted_to_client?: SortOrder;
    title?: SortOrder;
    service_details?: SortOrder;
    assessment_date?: SortOrder;
    backup_assessment__date?: SortOrderInput | SortOrder;
    preferred_arrival_times?: SortOrderInput | SortOrder;
    on_site_assesment_required?: SortOrder;
    client_id?: SortOrder;
    assessment_id?: SortOrder;
    internal_notes?: SortOrder;
    internalAttachmentUrl?: SortOrder;
    link_to_releated_quotes?: SortOrder;
    link_to_releated_jobs?: SortOrder;
    link_to_releated_invoices?: SortOrder;
    belongs_to_id?: SortOrder;
    assessment?: AssessmentsOrderByWithRelationInput;
    client?: ClientsOrderByWithRelationInput;
    quotes?: QuoteRequestOrderByRelationAggregateInput;
    job_requests?: JobRequestOrderByRelationAggregateInput;
    belongs_to?: UsersOrderByWithRelationInput;
  };

  export type RequestsWhereUniqueInput = Prisma.AtLeast<
    {
      id?: number;
      AND?: RequestsWhereInput | RequestsWhereInput[];
      OR?: RequestsWhereInput[];
      NOT?: RequestsWhereInput | RequestsWhereInput[];
      status?: StringFilter<"Requests"> | string;
      tags?: JsonNullableFilter<"Requests">;
      emailed_to_client?: BoolFilter<"Requests"> | boolean;
      texted_to_client?: BoolFilter<"Requests"> | boolean;
      title?: StringFilter<"Requests"> | string;
      service_details?: StringFilter<"Requests"> | string;
      assessment_date?: DateTimeFilter<"Requests"> | Date | string;
      backup_assessment__date?:
        | DateTimeNullableFilter<"Requests">
        | Date
        | string
        | null;
      preferred_arrival_times?:
        | StringNullableFilter<"Requests">
        | string
        | null;
      on_site_assesment_required?: BoolFilter<"Requests"> | boolean;
      client_id?: IntFilter<"Requests"> | number;
      assessment_id?: IntFilter<"Requests"> | number;
      internal_notes?: StringFilter<"Requests"> | string;
      internalAttachmentUrl?: StringFilter<"Requests"> | string;
      link_to_releated_quotes?: BoolFilter<"Requests"> | boolean;
      link_to_releated_jobs?: BoolFilter<"Requests"> | boolean;
      link_to_releated_invoices?: BoolFilter<"Requests"> | boolean;
      belongs_to_id?: IntFilter<"Requests"> | number;
      assessment?: XOR<AssessmentsRelationFilter, AssessmentsWhereInput>;
      client?: XOR<ClientsRelationFilter, ClientsWhereInput>;
      quotes?: QuoteRequestListRelationFilter;
      job_requests?: JobRequestListRelationFilter;
      belongs_to?: XOR<UsersRelationFilter, UsersWhereInput>;
    },
    "id"
  >;

  export type RequestsOrderByWithAggregationInput = {
    id?: SortOrder;
    status?: SortOrder;
    tags?: SortOrderInput | SortOrder;
    emailed_to_client?: SortOrder;
    texted_to_client?: SortOrder;
    title?: SortOrder;
    service_details?: SortOrder;
    assessment_date?: SortOrder;
    backup_assessment__date?: SortOrderInput | SortOrder;
    preferred_arrival_times?: SortOrderInput | SortOrder;
    on_site_assesment_required?: SortOrder;
    client_id?: SortOrder;
    assessment_id?: SortOrder;
    internal_notes?: SortOrder;
    internalAttachmentUrl?: SortOrder;
    link_to_releated_quotes?: SortOrder;
    link_to_releated_jobs?: SortOrder;
    link_to_releated_invoices?: SortOrder;
    belongs_to_id?: SortOrder;
    _count?: RequestsCountOrderByAggregateInput;
    _avg?: RequestsAvgOrderByAggregateInput;
    _max?: RequestsMaxOrderByAggregateInput;
    _min?: RequestsMinOrderByAggregateInput;
    _sum?: RequestsSumOrderByAggregateInput;
  };

  export type RequestsScalarWhereWithAggregatesInput = {
    AND?:
      | RequestsScalarWhereWithAggregatesInput
      | RequestsScalarWhereWithAggregatesInput[];
    OR?: RequestsScalarWhereWithAggregatesInput[];
    NOT?:
      | RequestsScalarWhereWithAggregatesInput
      | RequestsScalarWhereWithAggregatesInput[];
    id?: IntWithAggregatesFilter<"Requests"> | number;
    status?: StringWithAggregatesFilter<"Requests"> | string;
    tags?: JsonNullableWithAggregatesFilter<"Requests">;
    emailed_to_client?: BoolWithAggregatesFilter<"Requests"> | boolean;
    texted_to_client?: BoolWithAggregatesFilter<"Requests"> | boolean;
    title?: StringWithAggregatesFilter<"Requests"> | string;
    service_details?: StringWithAggregatesFilter<"Requests"> | string;
    assessment_date?: DateTimeWithAggregatesFilter<"Requests"> | Date | string;
    backup_assessment__date?:
      | DateTimeNullableWithAggregatesFilter<"Requests">
      | Date
      | string
      | null;
    preferred_arrival_times?:
      | StringNullableWithAggregatesFilter<"Requests">
      | string
      | null;
    on_site_assesment_required?: BoolWithAggregatesFilter<"Requests"> | boolean;
    client_id?: IntWithAggregatesFilter<"Requests"> | number;
    assessment_id?: IntWithAggregatesFilter<"Requests"> | number;
    internal_notes?: StringWithAggregatesFilter<"Requests"> | string;
    internalAttachmentUrl?: StringWithAggregatesFilter<"Requests"> | string;
    link_to_releated_quotes?: BoolWithAggregatesFilter<"Requests"> | boolean;
    link_to_releated_jobs?: BoolWithAggregatesFilter<"Requests"> | boolean;
    link_to_releated_invoices?: BoolWithAggregatesFilter<"Requests"> | boolean;
    belongs_to_id?: IntWithAggregatesFilter<"Requests"> | number;
  };

  export type LineItemsWhereInput = {
    AND?: LineItemsWhereInput | LineItemsWhereInput[];
    OR?: LineItemsWhereInput[];
    NOT?: LineItemsWhereInput | LineItemsWhereInput[];
    id?: IntFilter<"LineItems"> | number;
    type?: StringFilter<"LineItems"> | string;
    name?: StringFilter<"LineItems"> | string;
    description?: StringNullableFilter<"LineItems"> | string | null;
    quantity?: IntFilter<"LineItems"> | number;
    unit_price?: FloatFilter<"LineItems"> | number;
    markup?: FloatNullableFilter<"LineItems"> | number | null;
    img_url?: StringNullableFilter<"LineItems"> | string | null;
    recommend_item?: BoolFilter<"LineItems"> | boolean;
    quotes?: LineItemQuoteListRelationFilter;
    invoices?: LineItemInvoiceListRelationFilter;
    jobs?: LineItemJobListRelationFilter;
  };

  export type LineItemsOrderByWithRelationInput = {
    id?: SortOrder;
    type?: SortOrder;
    name?: SortOrder;
    description?: SortOrderInput | SortOrder;
    quantity?: SortOrder;
    unit_price?: SortOrder;
    markup?: SortOrderInput | SortOrder;
    img_url?: SortOrderInput | SortOrder;
    recommend_item?: SortOrder;
    quotes?: LineItemQuoteOrderByRelationAggregateInput;
    invoices?: LineItemInvoiceOrderByRelationAggregateInput;
    jobs?: LineItemJobOrderByRelationAggregateInput;
  };

  export type LineItemsWhereUniqueInput = Prisma.AtLeast<
    {
      id?: number;
      AND?: LineItemsWhereInput | LineItemsWhereInput[];
      OR?: LineItemsWhereInput[];
      NOT?: LineItemsWhereInput | LineItemsWhereInput[];
      type?: StringFilter<"LineItems"> | string;
      name?: StringFilter<"LineItems"> | string;
      description?: StringNullableFilter<"LineItems"> | string | null;
      quantity?: IntFilter<"LineItems"> | number;
      unit_price?: FloatFilter<"LineItems"> | number;
      markup?: FloatNullableFilter<"LineItems"> | number | null;
      img_url?: StringNullableFilter<"LineItems"> | string | null;
      recommend_item?: BoolFilter<"LineItems"> | boolean;
      quotes?: LineItemQuoteListRelationFilter;
      invoices?: LineItemInvoiceListRelationFilter;
      jobs?: LineItemJobListRelationFilter;
    },
    "id"
  >;

  export type LineItemsOrderByWithAggregationInput = {
    id?: SortOrder;
    type?: SortOrder;
    name?: SortOrder;
    description?: SortOrderInput | SortOrder;
    quantity?: SortOrder;
    unit_price?: SortOrder;
    markup?: SortOrderInput | SortOrder;
    img_url?: SortOrderInput | SortOrder;
    recommend_item?: SortOrder;
    _count?: LineItemsCountOrderByAggregateInput;
    _avg?: LineItemsAvgOrderByAggregateInput;
    _max?: LineItemsMaxOrderByAggregateInput;
    _min?: LineItemsMinOrderByAggregateInput;
    _sum?: LineItemsSumOrderByAggregateInput;
  };

  export type LineItemsScalarWhereWithAggregatesInput = {
    AND?:
      | LineItemsScalarWhereWithAggregatesInput
      | LineItemsScalarWhereWithAggregatesInput[];
    OR?: LineItemsScalarWhereWithAggregatesInput[];
    NOT?:
      | LineItemsScalarWhereWithAggregatesInput
      | LineItemsScalarWhereWithAggregatesInput[];
    id?: IntWithAggregatesFilter<"LineItems"> | number;
    type?: StringWithAggregatesFilter<"LineItems"> | string;
    name?: StringWithAggregatesFilter<"LineItems"> | string;
    description?:
      | StringNullableWithAggregatesFilter<"LineItems">
      | string
      | null;
    quantity?: IntWithAggregatesFilter<"LineItems"> | number;
    unit_price?: FloatWithAggregatesFilter<"LineItems"> | number;
    markup?: FloatNullableWithAggregatesFilter<"LineItems"> | number | null;
    img_url?: StringNullableWithAggregatesFilter<"LineItems"> | string | null;
    recommend_item?: BoolWithAggregatesFilter<"LineItems"> | boolean;
  };

  export type QuotesWhereInput = {
    AND?: QuotesWhereInput | QuotesWhereInput[];
    OR?: QuotesWhereInput[];
    NOT?: QuotesWhereInput | QuotesWhereInput[];
    id?: IntFilter<"Quotes"> | number;
    tags?: JsonNullableFilter<"Quotes">;
    emailed_to_client?: BoolFilter<"Quotes"> | boolean;
    texted_to_client?: BoolFilter<"Quotes"> | boolean;
    status?: StringFilter<"Quotes"> | string;
    title?: StringFilter<"Quotes"> | string;
    quote_number?: StringFilter<"Quotes"> | string;
    opportunity_rating?: StringNullableFilter<"Quotes"> | string | null;
    client_id?: IntFilter<"Quotes"> | number;
    client_message?: StringNullableFilter<"Quotes"> | string | null;
    discount?: FloatNullableFilter<"Quotes"> | number | null;
    discount_unit?: StringNullableFilter<"Quotes"> | string | null;
    tax_id?: IntFilter<"Quotes"> | number;
    required_deposit?: FloatNullableFilter<"Quotes"> | number | null;
    link_to_releated_jobs?: BoolFilter<"Quotes"> | boolean;
    link_to_releated_invoices?: BoolFilter<"Quotes"> | boolean;
    belongs_to_id?: IntFilter<"Quotes"> | number;
    client?: XOR<ClientsRelationFilter, ClientsWhereInput>;
    line_items?: LineItemQuoteListRelationFilter;
    tax?: XOR<TaxesNullableRelationFilter, TaxesWhereInput> | null;
    requests?: QuoteRequestListRelationFilter;
    job_quotes?: JobQuoteListRelationFilter;
    belongs_to?: XOR<UsersRelationFilter, UsersWhereInput>;
  };

  export type QuotesOrderByWithRelationInput = {
    id?: SortOrder;
    tags?: SortOrderInput | SortOrder;
    emailed_to_client?: SortOrder;
    texted_to_client?: SortOrder;
    status?: SortOrder;
    title?: SortOrder;
    quote_number?: SortOrder;
    opportunity_rating?: SortOrderInput | SortOrder;
    client_id?: SortOrder;
    client_message?: SortOrderInput | SortOrder;
    discount?: SortOrderInput | SortOrder;
    discount_unit?: SortOrderInput | SortOrder;
    tax_id?: SortOrder;
    required_deposit?: SortOrderInput | SortOrder;
    link_to_releated_jobs?: SortOrder;
    link_to_releated_invoices?: SortOrder;
    belongs_to_id?: SortOrder;
    client?: ClientsOrderByWithRelationInput;
    line_items?: LineItemQuoteOrderByRelationAggregateInput;
    tax?: TaxesOrderByWithRelationInput;
    requests?: QuoteRequestOrderByRelationAggregateInput;
    job_quotes?: JobQuoteOrderByRelationAggregateInput;
    belongs_to?: UsersOrderByWithRelationInput;
  };

  export type QuotesWhereUniqueInput = Prisma.AtLeast<
    {
      id?: number;
      AND?: QuotesWhereInput | QuotesWhereInput[];
      OR?: QuotesWhereInput[];
      NOT?: QuotesWhereInput | QuotesWhereInput[];
      tags?: JsonNullableFilter<"Quotes">;
      emailed_to_client?: BoolFilter<"Quotes"> | boolean;
      texted_to_client?: BoolFilter<"Quotes"> | boolean;
      status?: StringFilter<"Quotes"> | string;
      title?: StringFilter<"Quotes"> | string;
      quote_number?: StringFilter<"Quotes"> | string;
      opportunity_rating?: StringNullableFilter<"Quotes"> | string | null;
      client_id?: IntFilter<"Quotes"> | number;
      client_message?: StringNullableFilter<"Quotes"> | string | null;
      discount?: FloatNullableFilter<"Quotes"> | number | null;
      discount_unit?: StringNullableFilter<"Quotes"> | string | null;
      tax_id?: IntFilter<"Quotes"> | number;
      required_deposit?: FloatNullableFilter<"Quotes"> | number | null;
      link_to_releated_jobs?: BoolFilter<"Quotes"> | boolean;
      link_to_releated_invoices?: BoolFilter<"Quotes"> | boolean;
      belongs_to_id?: IntFilter<"Quotes"> | number;
      client?: XOR<ClientsRelationFilter, ClientsWhereInput>;
      line_items?: LineItemQuoteListRelationFilter;
      tax?: XOR<TaxesNullableRelationFilter, TaxesWhereInput> | null;
      requests?: QuoteRequestListRelationFilter;
      job_quotes?: JobQuoteListRelationFilter;
      belongs_to?: XOR<UsersRelationFilter, UsersWhereInput>;
    },
    "id"
  >;

  export type QuotesOrderByWithAggregationInput = {
    id?: SortOrder;
    tags?: SortOrderInput | SortOrder;
    emailed_to_client?: SortOrder;
    texted_to_client?: SortOrder;
    status?: SortOrder;
    title?: SortOrder;
    quote_number?: SortOrder;
    opportunity_rating?: SortOrderInput | SortOrder;
    client_id?: SortOrder;
    client_message?: SortOrderInput | SortOrder;
    discount?: SortOrderInput | SortOrder;
    discount_unit?: SortOrderInput | SortOrder;
    tax_id?: SortOrder;
    required_deposit?: SortOrderInput | SortOrder;
    link_to_releated_jobs?: SortOrder;
    link_to_releated_invoices?: SortOrder;
    belongs_to_id?: SortOrder;
    _count?: QuotesCountOrderByAggregateInput;
    _avg?: QuotesAvgOrderByAggregateInput;
    _max?: QuotesMaxOrderByAggregateInput;
    _min?: QuotesMinOrderByAggregateInput;
    _sum?: QuotesSumOrderByAggregateInput;
  };

  export type QuotesScalarWhereWithAggregatesInput = {
    AND?:
      | QuotesScalarWhereWithAggregatesInput
      | QuotesScalarWhereWithAggregatesInput[];
    OR?: QuotesScalarWhereWithAggregatesInput[];
    NOT?:
      | QuotesScalarWhereWithAggregatesInput
      | QuotesScalarWhereWithAggregatesInput[];
    id?: IntWithAggregatesFilter<"Quotes"> | number;
    tags?: JsonNullableWithAggregatesFilter<"Quotes">;
    emailed_to_client?: BoolWithAggregatesFilter<"Quotes"> | boolean;
    texted_to_client?: BoolWithAggregatesFilter<"Quotes"> | boolean;
    status?: StringWithAggregatesFilter<"Quotes"> | string;
    title?: StringWithAggregatesFilter<"Quotes"> | string;
    quote_number?: StringWithAggregatesFilter<"Quotes"> | string;
    opportunity_rating?:
      | StringNullableWithAggregatesFilter<"Quotes">
      | string
      | null;
    client_id?: IntWithAggregatesFilter<"Quotes"> | number;
    client_message?:
      | StringNullableWithAggregatesFilter<"Quotes">
      | string
      | null;
    discount?: FloatNullableWithAggregatesFilter<"Quotes"> | number | null;
    discount_unit?:
      | StringNullableWithAggregatesFilter<"Quotes">
      | string
      | null;
    tax_id?: IntWithAggregatesFilter<"Quotes"> | number;
    required_deposit?:
      | FloatNullableWithAggregatesFilter<"Quotes">
      | number
      | null;
    link_to_releated_jobs?: BoolWithAggregatesFilter<"Quotes"> | boolean;
    link_to_releated_invoices?: BoolWithAggregatesFilter<"Quotes"> | boolean;
    belongs_to_id?: IntWithAggregatesFilter<"Quotes"> | number;
  };

  export type LineItemQuoteWhereInput = {
    AND?: LineItemQuoteWhereInput | LineItemQuoteWhereInput[];
    OR?: LineItemQuoteWhereInput[];
    NOT?: LineItemQuoteWhereInput | LineItemQuoteWhereInput[];
    id?: IntFilter<"LineItemQuote"> | number;
    quote_id?: IntFilter<"LineItemQuote"> | number;
    line_item_id?: IntFilter<"LineItemQuote"> | number;
    quote?: XOR<QuotesRelationFilter, QuotesWhereInput>;
    line_item?: XOR<LineItemsRelationFilter, LineItemsWhereInput>;
  };

  export type LineItemQuoteOrderByWithRelationInput = {
    id?: SortOrder;
    quote_id?: SortOrder;
    line_item_id?: SortOrder;
    quote?: QuotesOrderByWithRelationInput;
    line_item?: LineItemsOrderByWithRelationInput;
  };

  export type LineItemQuoteWhereUniqueInput = Prisma.AtLeast<
    {
      id?: number;
      quote_id_line_item_id?: LineItemQuoteQuote_idLine_item_idCompoundUniqueInput;
      AND?: LineItemQuoteWhereInput | LineItemQuoteWhereInput[];
      OR?: LineItemQuoteWhereInput[];
      NOT?: LineItemQuoteWhereInput | LineItemQuoteWhereInput[];
      quote_id?: IntFilter<"LineItemQuote"> | number;
      line_item_id?: IntFilter<"LineItemQuote"> | number;
      quote?: XOR<QuotesRelationFilter, QuotesWhereInput>;
      line_item?: XOR<LineItemsRelationFilter, LineItemsWhereInput>;
    },
    "id" | "quote_id_line_item_id"
  >;

  export type LineItemQuoteOrderByWithAggregationInput = {
    id?: SortOrder;
    quote_id?: SortOrder;
    line_item_id?: SortOrder;
    _count?: LineItemQuoteCountOrderByAggregateInput;
    _avg?: LineItemQuoteAvgOrderByAggregateInput;
    _max?: LineItemQuoteMaxOrderByAggregateInput;
    _min?: LineItemQuoteMinOrderByAggregateInput;
    _sum?: LineItemQuoteSumOrderByAggregateInput;
  };

  export type LineItemQuoteScalarWhereWithAggregatesInput = {
    AND?:
      | LineItemQuoteScalarWhereWithAggregatesInput
      | LineItemQuoteScalarWhereWithAggregatesInput[];
    OR?: LineItemQuoteScalarWhereWithAggregatesInput[];
    NOT?:
      | LineItemQuoteScalarWhereWithAggregatesInput
      | LineItemQuoteScalarWhereWithAggregatesInput[];
    id?: IntWithAggregatesFilter<"LineItemQuote"> | number;
    quote_id?: IntWithAggregatesFilter<"LineItemQuote"> | number;
    line_item_id?: IntWithAggregatesFilter<"LineItemQuote"> | number;
  };

  export type QuoteRequestWhereInput = {
    AND?: QuoteRequestWhereInput | QuoteRequestWhereInput[];
    OR?: QuoteRequestWhereInput[];
    NOT?: QuoteRequestWhereInput | QuoteRequestWhereInput[];
    id?: IntFilter<"QuoteRequest"> | number;
    quoteId?: IntFilter<"QuoteRequest"> | number;
    requestId?: IntFilter<"QuoteRequest"> | number;
    quote?: XOR<QuotesRelationFilter, QuotesWhereInput>;
    request?: XOR<RequestsRelationFilter, RequestsWhereInput>;
  };

  export type QuoteRequestOrderByWithRelationInput = {
    id?: SortOrder;
    quoteId?: SortOrder;
    requestId?: SortOrder;
    quote?: QuotesOrderByWithRelationInput;
    request?: RequestsOrderByWithRelationInput;
  };

  export type QuoteRequestWhereUniqueInput = Prisma.AtLeast<
    {
      id?: number;
      quoteId_requestId?: QuoteRequestQuoteIdRequestIdCompoundUniqueInput;
      AND?: QuoteRequestWhereInput | QuoteRequestWhereInput[];
      OR?: QuoteRequestWhereInput[];
      NOT?: QuoteRequestWhereInput | QuoteRequestWhereInput[];
      quoteId?: IntFilter<"QuoteRequest"> | number;
      requestId?: IntFilter<"QuoteRequest"> | number;
      quote?: XOR<QuotesRelationFilter, QuotesWhereInput>;
      request?: XOR<RequestsRelationFilter, RequestsWhereInput>;
    },
    "id" | "quoteId_requestId"
  >;

  export type QuoteRequestOrderByWithAggregationInput = {
    id?: SortOrder;
    quoteId?: SortOrder;
    requestId?: SortOrder;
    _count?: QuoteRequestCountOrderByAggregateInput;
    _avg?: QuoteRequestAvgOrderByAggregateInput;
    _max?: QuoteRequestMaxOrderByAggregateInput;
    _min?: QuoteRequestMinOrderByAggregateInput;
    _sum?: QuoteRequestSumOrderByAggregateInput;
  };

  export type QuoteRequestScalarWhereWithAggregatesInput = {
    AND?:
      | QuoteRequestScalarWhereWithAggregatesInput
      | QuoteRequestScalarWhereWithAggregatesInput[];
    OR?: QuoteRequestScalarWhereWithAggregatesInput[];
    NOT?:
      | QuoteRequestScalarWhereWithAggregatesInput
      | QuoteRequestScalarWhereWithAggregatesInput[];
    id?: IntWithAggregatesFilter<"QuoteRequest"> | number;
    quoteId?: IntWithAggregatesFilter<"QuoteRequest"> | number;
    requestId?: IntWithAggregatesFilter<"QuoteRequest"> | number;
  };

  export type JobsWhereInput = {
    AND?: JobsWhereInput | JobsWhereInput[];
    OR?: JobsWhereInput[];
    NOT?: JobsWhereInput | JobsWhereInput[];
    id?: IntFilter<"Jobs"> | number;
    tags?: JsonNullableFilter<"Jobs">;
    emailed_to_client?: BoolFilter<"Jobs"> | boolean;
    texted_to_client?: BoolFilter<"Jobs"> | boolean;
    status?: StringFilter<"Jobs"> | string;
    client_id?: IntFilter<"Jobs"> | number;
    title?: StringFilter<"Jobs"> | string;
    instructions?: StringNullableFilter<"Jobs"> | string | null;
    number?: StringFilter<"Jobs"> | string;
    schedule_type?: StringFilter<"Jobs"> | string;
    recurring_frequency?: StringNullableFilter<"Jobs"> | string | null;
    recurring_interval?: StringNullableFilter<"Jobs"> | string | null;
    day_of_week?: StringNullableFilter<"Jobs"> | string | null;
    day_of_year?: StringNullableFilter<"Jobs"> | string | null;
    duration?: StringNullableFilter<"Jobs"> | string | null;
    start_date?: DateTimeNullableFilter<"Jobs"> | Date | string | null;
    end_date?: DateTimeNullableFilter<"Jobs"> | Date | string | null;
    start_time?: DateTimeNullableFilter<"Jobs"> | Date | string | null;
    end_time?: DateTimeNullableFilter<"Jobs"> | Date | string | null;
    schedule_later?: BoolFilter<"Jobs"> | boolean;
    team?: StringNullableFilter<"Jobs"> | string | null;
    email_team?: BoolFilter<"Jobs"> | boolean;
    invoice_reminder?: BoolFilter<"Jobs"> | boolean;
    internal_notes?: StringNullableFilter<"Jobs"> | string | null;
    internal_attachment_url?: StringNullableFilter<"Jobs"> | string | null;
    link_to_related_invoices?: BoolFilter<"Jobs"> | boolean;
    belongs_to_id?: IntFilter<"Jobs"> | number;
    client?: XOR<ClientsRelationFilter, ClientsWhereInput>;
    line_items?: LineItemJobListRelationFilter;
    job_requests?: JobRequestListRelationFilter;
    job_quotes?: JobQuoteListRelationFilter;
    invoices?: InvoicesListRelationFilter;
    belongs_to?: XOR<UsersRelationFilter, UsersWhereInput>;
  };

  export type JobsOrderByWithRelationInput = {
    id?: SortOrder;
    tags?: SortOrderInput | SortOrder;
    emailed_to_client?: SortOrder;
    texted_to_client?: SortOrder;
    status?: SortOrder;
    client_id?: SortOrder;
    title?: SortOrder;
    instructions?: SortOrderInput | SortOrder;
    number?: SortOrder;
    schedule_type?: SortOrder;
    recurring_frequency?: SortOrderInput | SortOrder;
    recurring_interval?: SortOrderInput | SortOrder;
    day_of_week?: SortOrderInput | SortOrder;
    day_of_year?: SortOrderInput | SortOrder;
    duration?: SortOrderInput | SortOrder;
    start_date?: SortOrderInput | SortOrder;
    end_date?: SortOrderInput | SortOrder;
    start_time?: SortOrderInput | SortOrder;
    end_time?: SortOrderInput | SortOrder;
    schedule_later?: SortOrder;
    team?: SortOrderInput | SortOrder;
    email_team?: SortOrder;
    invoice_reminder?: SortOrder;
    internal_notes?: SortOrderInput | SortOrder;
    internal_attachment_url?: SortOrderInput | SortOrder;
    link_to_related_invoices?: SortOrder;
    belongs_to_id?: SortOrder;
    client?: ClientsOrderByWithRelationInput;
    line_items?: LineItemJobOrderByRelationAggregateInput;
    job_requests?: JobRequestOrderByRelationAggregateInput;
    job_quotes?: JobQuoteOrderByRelationAggregateInput;
    invoices?: InvoicesOrderByRelationAggregateInput;
    belongs_to?: UsersOrderByWithRelationInput;
  };

  export type JobsWhereUniqueInput = Prisma.AtLeast<
    {
      id?: number;
      AND?: JobsWhereInput | JobsWhereInput[];
      OR?: JobsWhereInput[];
      NOT?: JobsWhereInput | JobsWhereInput[];
      tags?: JsonNullableFilter<"Jobs">;
      emailed_to_client?: BoolFilter<"Jobs"> | boolean;
      texted_to_client?: BoolFilter<"Jobs"> | boolean;
      status?: StringFilter<"Jobs"> | string;
      client_id?: IntFilter<"Jobs"> | number;
      title?: StringFilter<"Jobs"> | string;
      instructions?: StringNullableFilter<"Jobs"> | string | null;
      number?: StringFilter<"Jobs"> | string;
      schedule_type?: StringFilter<"Jobs"> | string;
      recurring_frequency?: StringNullableFilter<"Jobs"> | string | null;
      recurring_interval?: StringNullableFilter<"Jobs"> | string | null;
      day_of_week?: StringNullableFilter<"Jobs"> | string | null;
      day_of_year?: StringNullableFilter<"Jobs"> | string | null;
      duration?: StringNullableFilter<"Jobs"> | string | null;
      start_date?: DateTimeNullableFilter<"Jobs"> | Date | string | null;
      end_date?: DateTimeNullableFilter<"Jobs"> | Date | string | null;
      start_time?: DateTimeNullableFilter<"Jobs"> | Date | string | null;
      end_time?: DateTimeNullableFilter<"Jobs"> | Date | string | null;
      schedule_later?: BoolFilter<"Jobs"> | boolean;
      team?: StringNullableFilter<"Jobs"> | string | null;
      email_team?: BoolFilter<"Jobs"> | boolean;
      invoice_reminder?: BoolFilter<"Jobs"> | boolean;
      internal_notes?: StringNullableFilter<"Jobs"> | string | null;
      internal_attachment_url?: StringNullableFilter<"Jobs"> | string | null;
      link_to_related_invoices?: BoolFilter<"Jobs"> | boolean;
      belongs_to_id?: IntFilter<"Jobs"> | number;
      client?: XOR<ClientsRelationFilter, ClientsWhereInput>;
      line_items?: LineItemJobListRelationFilter;
      job_requests?: JobRequestListRelationFilter;
      job_quotes?: JobQuoteListRelationFilter;
      invoices?: InvoicesListRelationFilter;
      belongs_to?: XOR<UsersRelationFilter, UsersWhereInput>;
    },
    "id"
  >;

  export type JobsOrderByWithAggregationInput = {
    id?: SortOrder;
    tags?: SortOrderInput | SortOrder;
    emailed_to_client?: SortOrder;
    texted_to_client?: SortOrder;
    status?: SortOrder;
    client_id?: SortOrder;
    title?: SortOrder;
    instructions?: SortOrderInput | SortOrder;
    number?: SortOrder;
    schedule_type?: SortOrder;
    recurring_frequency?: SortOrderInput | SortOrder;
    recurring_interval?: SortOrderInput | SortOrder;
    day_of_week?: SortOrderInput | SortOrder;
    day_of_year?: SortOrderInput | SortOrder;
    duration?: SortOrderInput | SortOrder;
    start_date?: SortOrderInput | SortOrder;
    end_date?: SortOrderInput | SortOrder;
    start_time?: SortOrderInput | SortOrder;
    end_time?: SortOrderInput | SortOrder;
    schedule_later?: SortOrder;
    team?: SortOrderInput | SortOrder;
    email_team?: SortOrder;
    invoice_reminder?: SortOrder;
    internal_notes?: SortOrderInput | SortOrder;
    internal_attachment_url?: SortOrderInput | SortOrder;
    link_to_related_invoices?: SortOrder;
    belongs_to_id?: SortOrder;
    _count?: JobsCountOrderByAggregateInput;
    _avg?: JobsAvgOrderByAggregateInput;
    _max?: JobsMaxOrderByAggregateInput;
    _min?: JobsMinOrderByAggregateInput;
    _sum?: JobsSumOrderByAggregateInput;
  };

  export type JobsScalarWhereWithAggregatesInput = {
    AND?:
      | JobsScalarWhereWithAggregatesInput
      | JobsScalarWhereWithAggregatesInput[];
    OR?: JobsScalarWhereWithAggregatesInput[];
    NOT?:
      | JobsScalarWhereWithAggregatesInput
      | JobsScalarWhereWithAggregatesInput[];
    id?: IntWithAggregatesFilter<"Jobs"> | number;
    tags?: JsonNullableWithAggregatesFilter<"Jobs">;
    emailed_to_client?: BoolWithAggregatesFilter<"Jobs"> | boolean;
    texted_to_client?: BoolWithAggregatesFilter<"Jobs"> | boolean;
    status?: StringWithAggregatesFilter<"Jobs"> | string;
    client_id?: IntWithAggregatesFilter<"Jobs"> | number;
    title?: StringWithAggregatesFilter<"Jobs"> | string;
    instructions?: StringNullableWithAggregatesFilter<"Jobs"> | string | null;
    number?: StringWithAggregatesFilter<"Jobs"> | string;
    schedule_type?: StringWithAggregatesFilter<"Jobs"> | string;
    recurring_frequency?:
      | StringNullableWithAggregatesFilter<"Jobs">
      | string
      | null;
    recurring_interval?:
      | StringNullableWithAggregatesFilter<"Jobs">
      | string
      | null;
    day_of_week?: StringNullableWithAggregatesFilter<"Jobs"> | string | null;
    day_of_year?: StringNullableWithAggregatesFilter<"Jobs"> | string | null;
    duration?: StringNullableWithAggregatesFilter<"Jobs"> | string | null;
    start_date?:
      | DateTimeNullableWithAggregatesFilter<"Jobs">
      | Date
      | string
      | null;
    end_date?:
      | DateTimeNullableWithAggregatesFilter<"Jobs">
      | Date
      | string
      | null;
    start_time?:
      | DateTimeNullableWithAggregatesFilter<"Jobs">
      | Date
      | string
      | null;
    end_time?:
      | DateTimeNullableWithAggregatesFilter<"Jobs">
      | Date
      | string
      | null;
    schedule_later?: BoolWithAggregatesFilter<"Jobs"> | boolean;
    team?: StringNullableWithAggregatesFilter<"Jobs"> | string | null;
    email_team?: BoolWithAggregatesFilter<"Jobs"> | boolean;
    invoice_reminder?: BoolWithAggregatesFilter<"Jobs"> | boolean;
    internal_notes?: StringNullableWithAggregatesFilter<"Jobs"> | string | null;
    internal_attachment_url?:
      | StringNullableWithAggregatesFilter<"Jobs">
      | string
      | null;
    link_to_related_invoices?: BoolWithAggregatesFilter<"Jobs"> | boolean;
    belongs_to_id?: IntWithAggregatesFilter<"Jobs"> | number;
  };

  export type LineItemJobWhereInput = {
    AND?: LineItemJobWhereInput | LineItemJobWhereInput[];
    OR?: LineItemJobWhereInput[];
    NOT?: LineItemJobWhereInput | LineItemJobWhereInput[];
    id?: IntFilter<"LineItemJob"> | number;
    job_id?: IntFilter<"LineItemJob"> | number;
    line_item_id?: IntFilter<"LineItemJob"> | number;
    job?: XOR<JobsRelationFilter, JobsWhereInput>;
    line_item?: XOR<LineItemsRelationFilter, LineItemsWhereInput>;
  };

  export type LineItemJobOrderByWithRelationInput = {
    id?: SortOrder;
    job_id?: SortOrder;
    line_item_id?: SortOrder;
    job?: JobsOrderByWithRelationInput;
    line_item?: LineItemsOrderByWithRelationInput;
  };

  export type LineItemJobWhereUniqueInput = Prisma.AtLeast<
    {
      id?: number;
      job_id_line_item_id?: LineItemJobJob_idLine_item_idCompoundUniqueInput;
      AND?: LineItemJobWhereInput | LineItemJobWhereInput[];
      OR?: LineItemJobWhereInput[];
      NOT?: LineItemJobWhereInput | LineItemJobWhereInput[];
      job_id?: IntFilter<"LineItemJob"> | number;
      line_item_id?: IntFilter<"LineItemJob"> | number;
      job?: XOR<JobsRelationFilter, JobsWhereInput>;
      line_item?: XOR<LineItemsRelationFilter, LineItemsWhereInput>;
    },
    "id" | "job_id_line_item_id"
  >;

  export type LineItemJobOrderByWithAggregationInput = {
    id?: SortOrder;
    job_id?: SortOrder;
    line_item_id?: SortOrder;
    _count?: LineItemJobCountOrderByAggregateInput;
    _avg?: LineItemJobAvgOrderByAggregateInput;
    _max?: LineItemJobMaxOrderByAggregateInput;
    _min?: LineItemJobMinOrderByAggregateInput;
    _sum?: LineItemJobSumOrderByAggregateInput;
  };

  export type LineItemJobScalarWhereWithAggregatesInput = {
    AND?:
      | LineItemJobScalarWhereWithAggregatesInput
      | LineItemJobScalarWhereWithAggregatesInput[];
    OR?: LineItemJobScalarWhereWithAggregatesInput[];
    NOT?:
      | LineItemJobScalarWhereWithAggregatesInput
      | LineItemJobScalarWhereWithAggregatesInput[];
    id?: IntWithAggregatesFilter<"LineItemJob"> | number;
    job_id?: IntWithAggregatesFilter<"LineItemJob"> | number;
    line_item_id?: IntWithAggregatesFilter<"LineItemJob"> | number;
  };

  export type JobRequestWhereInput = {
    AND?: JobRequestWhereInput | JobRequestWhereInput[];
    OR?: JobRequestWhereInput[];
    NOT?: JobRequestWhereInput | JobRequestWhereInput[];
    id?: IntFilter<"JobRequest"> | number;
    job_id?: IntFilter<"JobRequest"> | number;
    request_id?: IntFilter<"JobRequest"> | number;
    job?: XOR<JobsRelationFilter, JobsWhereInput>;
    request?: XOR<RequestsRelationFilter, RequestsWhereInput>;
  };

  export type JobRequestOrderByWithRelationInput = {
    id?: SortOrder;
    job_id?: SortOrder;
    request_id?: SortOrder;
    job?: JobsOrderByWithRelationInput;
    request?: RequestsOrderByWithRelationInput;
  };

  export type JobRequestWhereUniqueInput = Prisma.AtLeast<
    {
      id?: number;
      job_id_request_id?: JobRequestJob_idRequest_idCompoundUniqueInput;
      AND?: JobRequestWhereInput | JobRequestWhereInput[];
      OR?: JobRequestWhereInput[];
      NOT?: JobRequestWhereInput | JobRequestWhereInput[];
      job_id?: IntFilter<"JobRequest"> | number;
      request_id?: IntFilter<"JobRequest"> | number;
      job?: XOR<JobsRelationFilter, JobsWhereInput>;
      request?: XOR<RequestsRelationFilter, RequestsWhereInput>;
    },
    "id" | "job_id_request_id"
  >;

  export type JobRequestOrderByWithAggregationInput = {
    id?: SortOrder;
    job_id?: SortOrder;
    request_id?: SortOrder;
    _count?: JobRequestCountOrderByAggregateInput;
    _avg?: JobRequestAvgOrderByAggregateInput;
    _max?: JobRequestMaxOrderByAggregateInput;
    _min?: JobRequestMinOrderByAggregateInput;
    _sum?: JobRequestSumOrderByAggregateInput;
  };

  export type JobRequestScalarWhereWithAggregatesInput = {
    AND?:
      | JobRequestScalarWhereWithAggregatesInput
      | JobRequestScalarWhereWithAggregatesInput[];
    OR?: JobRequestScalarWhereWithAggregatesInput[];
    NOT?:
      | JobRequestScalarWhereWithAggregatesInput
      | JobRequestScalarWhereWithAggregatesInput[];
    id?: IntWithAggregatesFilter<"JobRequest"> | number;
    job_id?: IntWithAggregatesFilter<"JobRequest"> | number;
    request_id?: IntWithAggregatesFilter<"JobRequest"> | number;
  };

  export type JobQuoteWhereInput = {
    AND?: JobQuoteWhereInput | JobQuoteWhereInput[];
    OR?: JobQuoteWhereInput[];
    NOT?: JobQuoteWhereInput | JobQuoteWhereInput[];
    id?: IntFilter<"JobQuote"> | number;
    job_id?: IntFilter<"JobQuote"> | number;
    quote_id?: IntFilter<"JobQuote"> | number;
    job?: XOR<JobsRelationFilter, JobsWhereInput>;
    quote?: XOR<QuotesRelationFilter, QuotesWhereInput>;
  };

  export type JobQuoteOrderByWithRelationInput = {
    id?: SortOrder;
    job_id?: SortOrder;
    quote_id?: SortOrder;
    job?: JobsOrderByWithRelationInput;
    quote?: QuotesOrderByWithRelationInput;
  };

  export type JobQuoteWhereUniqueInput = Prisma.AtLeast<
    {
      id?: number;
      job_id_quote_id?: JobQuoteJob_idQuote_idCompoundUniqueInput;
      AND?: JobQuoteWhereInput | JobQuoteWhereInput[];
      OR?: JobQuoteWhereInput[];
      NOT?: JobQuoteWhereInput | JobQuoteWhereInput[];
      job_id?: IntFilter<"JobQuote"> | number;
      quote_id?: IntFilter<"JobQuote"> | number;
      job?: XOR<JobsRelationFilter, JobsWhereInput>;
      quote?: XOR<QuotesRelationFilter, QuotesWhereInput>;
    },
    "id" | "job_id_quote_id"
  >;

  export type JobQuoteOrderByWithAggregationInput = {
    id?: SortOrder;
    job_id?: SortOrder;
    quote_id?: SortOrder;
    _count?: JobQuoteCountOrderByAggregateInput;
    _avg?: JobQuoteAvgOrderByAggregateInput;
    _max?: JobQuoteMaxOrderByAggregateInput;
    _min?: JobQuoteMinOrderByAggregateInput;
    _sum?: JobQuoteSumOrderByAggregateInput;
  };

  export type JobQuoteScalarWhereWithAggregatesInput = {
    AND?:
      | JobQuoteScalarWhereWithAggregatesInput
      | JobQuoteScalarWhereWithAggregatesInput[];
    OR?: JobQuoteScalarWhereWithAggregatesInput[];
    NOT?:
      | JobQuoteScalarWhereWithAggregatesInput
      | JobQuoteScalarWhereWithAggregatesInput[];
    id?: IntWithAggregatesFilter<"JobQuote"> | number;
    job_id?: IntWithAggregatesFilter<"JobQuote"> | number;
    quote_id?: IntWithAggregatesFilter<"JobQuote"> | number;
  };

  export type InvoicesWhereInput = {
    AND?: InvoicesWhereInput | InvoicesWhereInput[];
    OR?: InvoicesWhereInput[];
    NOT?: InvoicesWhereInput | InvoicesWhereInput[];
    id?: IntFilter<"Invoices"> | number;
    tags?: JsonNullableFilter<"Invoices">;
    emailed_to_client?: BoolFilter<"Invoices"> | boolean;
    texted_to_client?: BoolFilter<"Invoices"> | boolean;
    issued_date?: DateTimeFilter<"Invoices"> | Date | string;
    due_date?: DateTimeNullableFilter<"Invoices"> | Date | string | null;
    status?: StringFilter<"Invoices"> | string;
    type?: StringFilter<"Invoices"> | string;
    subject?: StringFilter<"Invoices"> | string;
    client_id?: IntFilter<"Invoices"> | number;
    job_id?: IntNullableFilter<"Invoices"> | number | null;
    tax_id?: IntNullableFilter<"Invoices"> | number | null;
    client_message?: StringFilter<"Invoices"> | string;
    internal_notes?: StringFilter<"Invoices"> | string;
    internalAttachmentUrl?: StringFilter<"Invoices"> | string;
    belongs_to_id?: IntFilter<"Invoices"> | number;
    client?: XOR<ClientsRelationFilter, ClientsWhereInput>;
    job?: XOR<JobsNullableRelationFilter, JobsWhereInput> | null;
    tax?: XOR<TaxesNullableRelationFilter, TaxesWhereInput> | null;
    additional_line_items?: LineItemInvoiceListRelationFilter;
    belongs_to?: XOR<UsersRelationFilter, UsersWhereInput>;
  };

  export type InvoicesOrderByWithRelationInput = {
    id?: SortOrder;
    tags?: SortOrderInput | SortOrder;
    emailed_to_client?: SortOrder;
    texted_to_client?: SortOrder;
    issued_date?: SortOrder;
    due_date?: SortOrderInput | SortOrder;
    status?: SortOrder;
    type?: SortOrder;
    subject?: SortOrder;
    client_id?: SortOrder;
    job_id?: SortOrderInput | SortOrder;
    tax_id?: SortOrderInput | SortOrder;
    client_message?: SortOrder;
    internal_notes?: SortOrder;
    internalAttachmentUrl?: SortOrder;
    belongs_to_id?: SortOrder;
    client?: ClientsOrderByWithRelationInput;
    job?: JobsOrderByWithRelationInput;
    tax?: TaxesOrderByWithRelationInput;
    additional_line_items?: LineItemInvoiceOrderByRelationAggregateInput;
    belongs_to?: UsersOrderByWithRelationInput;
  };

  export type InvoicesWhereUniqueInput = Prisma.AtLeast<
    {
      id?: number;
      AND?: InvoicesWhereInput | InvoicesWhereInput[];
      OR?: InvoicesWhereInput[];
      NOT?: InvoicesWhereInput | InvoicesWhereInput[];
      tags?: JsonNullableFilter<"Invoices">;
      emailed_to_client?: BoolFilter<"Invoices"> | boolean;
      texted_to_client?: BoolFilter<"Invoices"> | boolean;
      issued_date?: DateTimeFilter<"Invoices"> | Date | string;
      due_date?: DateTimeNullableFilter<"Invoices"> | Date | string | null;
      status?: StringFilter<"Invoices"> | string;
      type?: StringFilter<"Invoices"> | string;
      subject?: StringFilter<"Invoices"> | string;
      client_id?: IntFilter<"Invoices"> | number;
      job_id?: IntNullableFilter<"Invoices"> | number | null;
      tax_id?: IntNullableFilter<"Invoices"> | number | null;
      client_message?: StringFilter<"Invoices"> | string;
      internal_notes?: StringFilter<"Invoices"> | string;
      internalAttachmentUrl?: StringFilter<"Invoices"> | string;
      belongs_to_id?: IntFilter<"Invoices"> | number;
      client?: XOR<ClientsRelationFilter, ClientsWhereInput>;
      job?: XOR<JobsNullableRelationFilter, JobsWhereInput> | null;
      tax?: XOR<TaxesNullableRelationFilter, TaxesWhereInput> | null;
      additional_line_items?: LineItemInvoiceListRelationFilter;
      belongs_to?: XOR<UsersRelationFilter, UsersWhereInput>;
    },
    "id"
  >;

  export type InvoicesOrderByWithAggregationInput = {
    id?: SortOrder;
    tags?: SortOrderInput | SortOrder;
    emailed_to_client?: SortOrder;
    texted_to_client?: SortOrder;
    issued_date?: SortOrder;
    due_date?: SortOrderInput | SortOrder;
    status?: SortOrder;
    type?: SortOrder;
    subject?: SortOrder;
    client_id?: SortOrder;
    job_id?: SortOrderInput | SortOrder;
    tax_id?: SortOrderInput | SortOrder;
    client_message?: SortOrder;
    internal_notes?: SortOrder;
    internalAttachmentUrl?: SortOrder;
    belongs_to_id?: SortOrder;
    _count?: InvoicesCountOrderByAggregateInput;
    _avg?: InvoicesAvgOrderByAggregateInput;
    _max?: InvoicesMaxOrderByAggregateInput;
    _min?: InvoicesMinOrderByAggregateInput;
    _sum?: InvoicesSumOrderByAggregateInput;
  };

  export type InvoicesScalarWhereWithAggregatesInput = {
    AND?:
      | InvoicesScalarWhereWithAggregatesInput
      | InvoicesScalarWhereWithAggregatesInput[];
    OR?: InvoicesScalarWhereWithAggregatesInput[];
    NOT?:
      | InvoicesScalarWhereWithAggregatesInput
      | InvoicesScalarWhereWithAggregatesInput[];
    id?: IntWithAggregatesFilter<"Invoices"> | number;
    tags?: JsonNullableWithAggregatesFilter<"Invoices">;
    emailed_to_client?: BoolWithAggregatesFilter<"Invoices"> | boolean;
    texted_to_client?: BoolWithAggregatesFilter<"Invoices"> | boolean;
    issued_date?: DateTimeWithAggregatesFilter<"Invoices"> | Date | string;
    due_date?:
      | DateTimeNullableWithAggregatesFilter<"Invoices">
      | Date
      | string
      | null;
    status?: StringWithAggregatesFilter<"Invoices"> | string;
    type?: StringWithAggregatesFilter<"Invoices"> | string;
    subject?: StringWithAggregatesFilter<"Invoices"> | string;
    client_id?: IntWithAggregatesFilter<"Invoices"> | number;
    job_id?: IntNullableWithAggregatesFilter<"Invoices"> | number | null;
    tax_id?: IntNullableWithAggregatesFilter<"Invoices"> | number | null;
    client_message?: StringWithAggregatesFilter<"Invoices"> | string;
    internal_notes?: StringWithAggregatesFilter<"Invoices"> | string;
    internalAttachmentUrl?: StringWithAggregatesFilter<"Invoices"> | string;
    belongs_to_id?: IntWithAggregatesFilter<"Invoices"> | number;
  };

  export type LineItemInvoiceWhereInput = {
    AND?: LineItemInvoiceWhereInput | LineItemInvoiceWhereInput[];
    OR?: LineItemInvoiceWhereInput[];
    NOT?: LineItemInvoiceWhereInput | LineItemInvoiceWhereInput[];
    id?: IntFilter<"LineItemInvoice"> | number;
    invoice_id?: IntFilter<"LineItemInvoice"> | number;
    line_item_id?: IntFilter<"LineItemInvoice"> | number;
    invoice?: XOR<InvoicesRelationFilter, InvoicesWhereInput>;
    line_item?: XOR<LineItemsRelationFilter, LineItemsWhereInput>;
  };

  export type LineItemInvoiceOrderByWithRelationInput = {
    id?: SortOrder;
    invoice_id?: SortOrder;
    line_item_id?: SortOrder;
    invoice?: InvoicesOrderByWithRelationInput;
    line_item?: LineItemsOrderByWithRelationInput;
  };

  export type LineItemInvoiceWhereUniqueInput = Prisma.AtLeast<
    {
      id?: number;
      invoice_id_line_item_id?: LineItemInvoiceInvoice_idLine_item_idCompoundUniqueInput;
      AND?: LineItemInvoiceWhereInput | LineItemInvoiceWhereInput[];
      OR?: LineItemInvoiceWhereInput[];
      NOT?: LineItemInvoiceWhereInput | LineItemInvoiceWhereInput[];
      invoice_id?: IntFilter<"LineItemInvoice"> | number;
      line_item_id?: IntFilter<"LineItemInvoice"> | number;
      invoice?: XOR<InvoicesRelationFilter, InvoicesWhereInput>;
      line_item?: XOR<LineItemsRelationFilter, LineItemsWhereInput>;
    },
    "id" | "invoice_id_line_item_id"
  >;

  export type LineItemInvoiceOrderByWithAggregationInput = {
    id?: SortOrder;
    invoice_id?: SortOrder;
    line_item_id?: SortOrder;
    _count?: LineItemInvoiceCountOrderByAggregateInput;
    _avg?: LineItemInvoiceAvgOrderByAggregateInput;
    _max?: LineItemInvoiceMaxOrderByAggregateInput;
    _min?: LineItemInvoiceMinOrderByAggregateInput;
    _sum?: LineItemInvoiceSumOrderByAggregateInput;
  };

  export type LineItemInvoiceScalarWhereWithAggregatesInput = {
    AND?:
      | LineItemInvoiceScalarWhereWithAggregatesInput
      | LineItemInvoiceScalarWhereWithAggregatesInput[];
    OR?: LineItemInvoiceScalarWhereWithAggregatesInput[];
    NOT?:
      | LineItemInvoiceScalarWhereWithAggregatesInput
      | LineItemInvoiceScalarWhereWithAggregatesInput[];
    id?: IntWithAggregatesFilter<"LineItemInvoice"> | number;
    invoice_id?: IntWithAggregatesFilter<"LineItemInvoice"> | number;
    line_item_id?: IntWithAggregatesFilter<"LineItemInvoice"> | number;
  };

  export type TaxesCreateInput = {
    name: string;
    rate: number;
    description?: string | null;
    users?: UsersCreateNestedManyWithoutDefault_taxInput;
    quotes?: QuotesCreateNestedManyWithoutTaxInput;
    invoices?: InvoicesCreateNestedManyWithoutTaxInput;
  };

  export type TaxesUncheckedCreateInput = {
    id?: number;
    name: string;
    rate: number;
    description?: string | null;
    users?: UsersUncheckedCreateNestedManyWithoutDefault_taxInput;
    quotes?: QuotesUncheckedCreateNestedManyWithoutTaxInput;
    invoices?: InvoicesUncheckedCreateNestedManyWithoutTaxInput;
  };

  export type TaxesUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string;
    rate?: FloatFieldUpdateOperationsInput | number;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    users?: UsersUpdateManyWithoutDefault_taxNestedInput;
    quotes?: QuotesUpdateManyWithoutTaxNestedInput;
    invoices?: InvoicesUpdateManyWithoutTaxNestedInput;
  };

  export type TaxesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number;
    name?: StringFieldUpdateOperationsInput | string;
    rate?: FloatFieldUpdateOperationsInput | number;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    users?: UsersUncheckedUpdateManyWithoutDefault_taxNestedInput;
    quotes?: QuotesUncheckedUpdateManyWithoutTaxNestedInput;
    invoices?: InvoicesUncheckedUpdateManyWithoutTaxNestedInput;
  };

  export type TaxesCreateManyInput = {
    id?: number;
    name: string;
    rate: number;
    description?: string | null;
  };

  export type TaxesUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string;
    rate?: FloatFieldUpdateOperationsInput | number;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type TaxesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number;
    name?: StringFieldUpdateOperationsInput | string;
    rate?: FloatFieldUpdateOperationsInput | number;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type AddressesCreateInput = {
    street1: string;
    street2?: string | null;
    city: string;
    state: string;
    zip_code: string;
    country: string;
    users?: UsersCreateNestedManyWithoutAddressInput;
    property_clients?: ClientsCreateNestedManyWithoutProperty_addressInput;
    billing_clients?: ClientsCreateNestedManyWithoutBilling_addressInput;
  };

  export type AddressesUncheckedCreateInput = {
    id?: number;
    street1: string;
    street2?: string | null;
    city: string;
    state: string;
    zip_code: string;
    country: string;
    users?: UsersUncheckedCreateNestedManyWithoutAddressInput;
    property_clients?: ClientsUncheckedCreateNestedManyWithoutProperty_addressInput;
    billing_clients?: ClientsUncheckedCreateNestedManyWithoutBilling_addressInput;
  };

  export type AddressesUpdateInput = {
    street1?: StringFieldUpdateOperationsInput | string;
    street2?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: StringFieldUpdateOperationsInput | string;
    state?: StringFieldUpdateOperationsInput | string;
    zip_code?: StringFieldUpdateOperationsInput | string;
    country?: StringFieldUpdateOperationsInput | string;
    users?: UsersUpdateManyWithoutAddressNestedInput;
    property_clients?: ClientsUpdateManyWithoutProperty_addressNestedInput;
    billing_clients?: ClientsUpdateManyWithoutBilling_addressNestedInput;
  };

  export type AddressesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number;
    street1?: StringFieldUpdateOperationsInput | string;
    street2?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: StringFieldUpdateOperationsInput | string;
    state?: StringFieldUpdateOperationsInput | string;
    zip_code?: StringFieldUpdateOperationsInput | string;
    country?: StringFieldUpdateOperationsInput | string;
    users?: UsersUncheckedUpdateManyWithoutAddressNestedInput;
    property_clients?: ClientsUncheckedUpdateManyWithoutProperty_addressNestedInput;
    billing_clients?: ClientsUncheckedUpdateManyWithoutBilling_addressNestedInput;
  };

  export type AddressesCreateManyInput = {
    id?: number;
    street1: string;
    street2?: string | null;
    city: string;
    state: string;
    zip_code: string;
    country: string;
  };

  export type AddressesUpdateManyMutationInput = {
    street1?: StringFieldUpdateOperationsInput | string;
    street2?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: StringFieldUpdateOperationsInput | string;
    state?: StringFieldUpdateOperationsInput | string;
    zip_code?: StringFieldUpdateOperationsInput | string;
    country?: StringFieldUpdateOperationsInput | string;
  };

  export type AddressesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number;
    street1?: StringFieldUpdateOperationsInput | string;
    street2?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: StringFieldUpdateOperationsInput | string;
    state?: StringFieldUpdateOperationsInput | string;
    zip_code?: StringFieldUpdateOperationsInput | string;
    country?: StringFieldUpdateOperationsInput | string;
  };

  export type UsersCreateInput = {
    email?: string | null;
    password: string;
    first_name: string;
    last_name: string;
    phone_number?: string | null;
    company_name?: string | null;
    subscription_id?: string | null;
    free_trial_expiration_date?: Date | string | null;
    settings?: NullableJsonNullValueInput | InputJsonValue;
    default_tax?: TaxesCreateNestedOneWithoutUsersInput;
    address?: AddressesCreateNestedOneWithoutUsersInput;
    clients?: ClientsCreateNestedManyWithoutBelongs_toInput;
    requests?: RequestsCreateNestedManyWithoutBelongs_toInput;
    jobs?: JobsCreateNestedManyWithoutBelongs_toInput;
    quotes?: QuotesCreateNestedManyWithoutBelongs_toInput;
    invoices?: InvoicesCreateNestedManyWithoutBelongs_toInput;
  };

  export type UsersUncheckedCreateInput = {
    id?: number;
    email?: string | null;
    password: string;
    first_name: string;
    last_name: string;
    phone_number?: string | null;
    company_name?: string | null;
    subscription_id?: string | null;
    free_trial_expiration_date?: Date | string | null;
    default_tax_id?: number | null;
    address_id?: number | null;
    settings?: NullableJsonNullValueInput | InputJsonValue;
    clients?: ClientsUncheckedCreateNestedManyWithoutBelongs_toInput;
    requests?: RequestsUncheckedCreateNestedManyWithoutBelongs_toInput;
    jobs?: JobsUncheckedCreateNestedManyWithoutBelongs_toInput;
    quotes?: QuotesUncheckedCreateNestedManyWithoutBelongs_toInput;
    invoices?: InvoicesUncheckedCreateNestedManyWithoutBelongs_toInput;
  };

  export type UsersUpdateInput = {
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: StringFieldUpdateOperationsInput | string;
    first_name?: StringFieldUpdateOperationsInput | string;
    last_name?: StringFieldUpdateOperationsInput | string;
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null;
    company_name?: NullableStringFieldUpdateOperationsInput | string | null;
    subscription_id?: NullableStringFieldUpdateOperationsInput | string | null;
    free_trial_expiration_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    settings?: NullableJsonNullValueInput | InputJsonValue;
    default_tax?: TaxesUpdateOneWithoutUsersNestedInput;
    address?: AddressesUpdateOneWithoutUsersNestedInput;
    clients?: ClientsUpdateManyWithoutBelongs_toNestedInput;
    requests?: RequestsUpdateManyWithoutBelongs_toNestedInput;
    jobs?: JobsUpdateManyWithoutBelongs_toNestedInput;
    quotes?: QuotesUpdateManyWithoutBelongs_toNestedInput;
    invoices?: InvoicesUpdateManyWithoutBelongs_toNestedInput;
  };

  export type UsersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: StringFieldUpdateOperationsInput | string;
    first_name?: StringFieldUpdateOperationsInput | string;
    last_name?: StringFieldUpdateOperationsInput | string;
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null;
    company_name?: NullableStringFieldUpdateOperationsInput | string | null;
    subscription_id?: NullableStringFieldUpdateOperationsInput | string | null;
    free_trial_expiration_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    default_tax_id?: NullableIntFieldUpdateOperationsInput | number | null;
    address_id?: NullableIntFieldUpdateOperationsInput | number | null;
    settings?: NullableJsonNullValueInput | InputJsonValue;
    clients?: ClientsUncheckedUpdateManyWithoutBelongs_toNestedInput;
    requests?: RequestsUncheckedUpdateManyWithoutBelongs_toNestedInput;
    jobs?: JobsUncheckedUpdateManyWithoutBelongs_toNestedInput;
    quotes?: QuotesUncheckedUpdateManyWithoutBelongs_toNestedInput;
    invoices?: InvoicesUncheckedUpdateManyWithoutBelongs_toNestedInput;
  };

  export type UsersCreateManyInput = {
    id?: number;
    email?: string | null;
    password: string;
    first_name: string;
    last_name: string;
    phone_number?: string | null;
    company_name?: string | null;
    subscription_id?: string | null;
    free_trial_expiration_date?: Date | string | null;
    default_tax_id?: number | null;
    address_id?: number | null;
    settings?: NullableJsonNullValueInput | InputJsonValue;
  };

  export type UsersUpdateManyMutationInput = {
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: StringFieldUpdateOperationsInput | string;
    first_name?: StringFieldUpdateOperationsInput | string;
    last_name?: StringFieldUpdateOperationsInput | string;
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null;
    company_name?: NullableStringFieldUpdateOperationsInput | string | null;
    subscription_id?: NullableStringFieldUpdateOperationsInput | string | null;
    free_trial_expiration_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    settings?: NullableJsonNullValueInput | InputJsonValue;
  };

  export type UsersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: StringFieldUpdateOperationsInput | string;
    first_name?: StringFieldUpdateOperationsInput | string;
    last_name?: StringFieldUpdateOperationsInput | string;
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null;
    company_name?: NullableStringFieldUpdateOperationsInput | string | null;
    subscription_id?: NullableStringFieldUpdateOperationsInput | string | null;
    free_trial_expiration_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    default_tax_id?: NullableIntFieldUpdateOperationsInput | number | null;
    address_id?: NullableIntFieldUpdateOperationsInput | number | null;
    settings?: NullableJsonNullValueInput | InputJsonValue;
  };

  export type ClientsCreateInput = {
    title: string;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    first_name: string;
    last_name: string;
    company_name?: string | null;
    use_company_name_as_primary?: boolean;
    mobile_phone_number?: string | null;
    work_phone_number?: string | null;
    email?: string | null;
    quote_follow_up?: boolean;
    job_follow_up?: boolean;
    invoice_follow_up?: boolean;
    upcoming_visit_reminder?: boolean;
    referred_by?: string | null;
    billing_address_same_as_property?: boolean;
    created_date?: Date | string;
    status?: string | null;
    property_address?: AddressesCreateNestedOneWithoutProperty_clientsInput;
    billing_address?: AddressesCreateNestedOneWithoutBilling_clientsInput;
    requests?: RequestsCreateNestedManyWithoutClientInput;
    quotes?: QuotesCreateNestedManyWithoutClientInput;
    jobs?: JobsCreateNestedManyWithoutClientInput;
    invoices?: InvoicesCreateNestedManyWithoutClientInput;
    belongs_to: UsersCreateNestedOneWithoutClientsInput;
  };

  export type ClientsUncheckedCreateInput = {
    id?: number;
    title: string;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    first_name: string;
    last_name: string;
    company_name?: string | null;
    use_company_name_as_primary?: boolean;
    mobile_phone_number?: string | null;
    work_phone_number?: string | null;
    email?: string | null;
    quote_follow_up?: boolean;
    job_follow_up?: boolean;
    invoice_follow_up?: boolean;
    upcoming_visit_reminder?: boolean;
    referred_by?: string | null;
    billing_address_same_as_property?: boolean;
    property_address_id?: number | null;
    billing_address_id?: number | null;
    created_date?: Date | string;
    status?: string | null;
    belongs_to_id: number;
    requests?: RequestsUncheckedCreateNestedManyWithoutClientInput;
    quotes?: QuotesUncheckedCreateNestedManyWithoutClientInput;
    jobs?: JobsUncheckedCreateNestedManyWithoutClientInput;
    invoices?: InvoicesUncheckedCreateNestedManyWithoutClientInput;
  };

  export type ClientsUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    first_name?: StringFieldUpdateOperationsInput | string;
    last_name?: StringFieldUpdateOperationsInput | string;
    company_name?: NullableStringFieldUpdateOperationsInput | string | null;
    use_company_name_as_primary?: BoolFieldUpdateOperationsInput | boolean;
    mobile_phone_number?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    work_phone_number?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    quote_follow_up?: BoolFieldUpdateOperationsInput | boolean;
    job_follow_up?: BoolFieldUpdateOperationsInput | boolean;
    invoice_follow_up?: BoolFieldUpdateOperationsInput | boolean;
    upcoming_visit_reminder?: BoolFieldUpdateOperationsInput | boolean;
    referred_by?: NullableStringFieldUpdateOperationsInput | string | null;
    billing_address_same_as_property?: BoolFieldUpdateOperationsInput | boolean;
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string;
    status?: NullableStringFieldUpdateOperationsInput | string | null;
    property_address?: AddressesUpdateOneWithoutProperty_clientsNestedInput;
    billing_address?: AddressesUpdateOneWithoutBilling_clientsNestedInput;
    requests?: RequestsUpdateManyWithoutClientNestedInput;
    quotes?: QuotesUpdateManyWithoutClientNestedInput;
    jobs?: JobsUpdateManyWithoutClientNestedInput;
    invoices?: InvoicesUpdateManyWithoutClientNestedInput;
    belongs_to?: UsersUpdateOneRequiredWithoutClientsNestedInput;
  };

  export type ClientsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number;
    title?: StringFieldUpdateOperationsInput | string;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    first_name?: StringFieldUpdateOperationsInput | string;
    last_name?: StringFieldUpdateOperationsInput | string;
    company_name?: NullableStringFieldUpdateOperationsInput | string | null;
    use_company_name_as_primary?: BoolFieldUpdateOperationsInput | boolean;
    mobile_phone_number?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    work_phone_number?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    quote_follow_up?: BoolFieldUpdateOperationsInput | boolean;
    job_follow_up?: BoolFieldUpdateOperationsInput | boolean;
    invoice_follow_up?: BoolFieldUpdateOperationsInput | boolean;
    upcoming_visit_reminder?: BoolFieldUpdateOperationsInput | boolean;
    referred_by?: NullableStringFieldUpdateOperationsInput | string | null;
    billing_address_same_as_property?: BoolFieldUpdateOperationsInput | boolean;
    property_address_id?: NullableIntFieldUpdateOperationsInput | number | null;
    billing_address_id?: NullableIntFieldUpdateOperationsInput | number | null;
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string;
    status?: NullableStringFieldUpdateOperationsInput | string | null;
    belongs_to_id?: IntFieldUpdateOperationsInput | number;
    requests?: RequestsUncheckedUpdateManyWithoutClientNestedInput;
    quotes?: QuotesUncheckedUpdateManyWithoutClientNestedInput;
    jobs?: JobsUncheckedUpdateManyWithoutClientNestedInput;
    invoices?: InvoicesUncheckedUpdateManyWithoutClientNestedInput;
  };

  export type ClientsCreateManyInput = {
    id?: number;
    title: string;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    first_name: string;
    last_name: string;
    company_name?: string | null;
    use_company_name_as_primary?: boolean;
    mobile_phone_number?: string | null;
    work_phone_number?: string | null;
    email?: string | null;
    quote_follow_up?: boolean;
    job_follow_up?: boolean;
    invoice_follow_up?: boolean;
    upcoming_visit_reminder?: boolean;
    referred_by?: string | null;
    billing_address_same_as_property?: boolean;
    property_address_id?: number | null;
    billing_address_id?: number | null;
    created_date?: Date | string;
    status?: string | null;
    belongs_to_id: number;
  };

  export type ClientsUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    first_name?: StringFieldUpdateOperationsInput | string;
    last_name?: StringFieldUpdateOperationsInput | string;
    company_name?: NullableStringFieldUpdateOperationsInput | string | null;
    use_company_name_as_primary?: BoolFieldUpdateOperationsInput | boolean;
    mobile_phone_number?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    work_phone_number?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    quote_follow_up?: BoolFieldUpdateOperationsInput | boolean;
    job_follow_up?: BoolFieldUpdateOperationsInput | boolean;
    invoice_follow_up?: BoolFieldUpdateOperationsInput | boolean;
    upcoming_visit_reminder?: BoolFieldUpdateOperationsInput | boolean;
    referred_by?: NullableStringFieldUpdateOperationsInput | string | null;
    billing_address_same_as_property?: BoolFieldUpdateOperationsInput | boolean;
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string;
    status?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type ClientsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number;
    title?: StringFieldUpdateOperationsInput | string;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    first_name?: StringFieldUpdateOperationsInput | string;
    last_name?: StringFieldUpdateOperationsInput | string;
    company_name?: NullableStringFieldUpdateOperationsInput | string | null;
    use_company_name_as_primary?: BoolFieldUpdateOperationsInput | boolean;
    mobile_phone_number?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    work_phone_number?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    quote_follow_up?: BoolFieldUpdateOperationsInput | boolean;
    job_follow_up?: BoolFieldUpdateOperationsInput | boolean;
    invoice_follow_up?: BoolFieldUpdateOperationsInput | boolean;
    upcoming_visit_reminder?: BoolFieldUpdateOperationsInput | boolean;
    referred_by?: NullableStringFieldUpdateOperationsInput | string | null;
    billing_address_same_as_property?: BoolFieldUpdateOperationsInput | boolean;
    property_address_id?: NullableIntFieldUpdateOperationsInput | number | null;
    billing_address_id?: NullableIntFieldUpdateOperationsInput | number | null;
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string;
    status?: NullableStringFieldUpdateOperationsInput | string | null;
    belongs_to_id?: IntFieldUpdateOperationsInput | number;
  };

  export type AssessmentsCreateInput = {
    instructions?: string | null;
    start_date?: Date | string | null;
    end_date?: Date | string | null;
    schedule_later?: boolean;
    start_time?: Date | string | null;
    end_time?: Date | string | null;
    any_time?: boolean;
    team?: string | null;
    requests?: RequestsCreateNestedManyWithoutAssessmentInput;
  };

  export type AssessmentsUncheckedCreateInput = {
    id?: number;
    instructions?: string | null;
    start_date?: Date | string | null;
    end_date?: Date | string | null;
    schedule_later?: boolean;
    start_time?: Date | string | null;
    end_time?: Date | string | null;
    any_time?: boolean;
    team?: string | null;
    requests?: RequestsUncheckedCreateNestedManyWithoutAssessmentInput;
  };

  export type AssessmentsUpdateInput = {
    instructions?: NullableStringFieldUpdateOperationsInput | string | null;
    start_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    end_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    schedule_later?: BoolFieldUpdateOperationsInput | boolean;
    start_time?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    end_time?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    any_time?: BoolFieldUpdateOperationsInput | boolean;
    team?: NullableStringFieldUpdateOperationsInput | string | null;
    requests?: RequestsUpdateManyWithoutAssessmentNestedInput;
  };

  export type AssessmentsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number;
    instructions?: NullableStringFieldUpdateOperationsInput | string | null;
    start_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    end_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    schedule_later?: BoolFieldUpdateOperationsInput | boolean;
    start_time?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    end_time?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    any_time?: BoolFieldUpdateOperationsInput | boolean;
    team?: NullableStringFieldUpdateOperationsInput | string | null;
    requests?: RequestsUncheckedUpdateManyWithoutAssessmentNestedInput;
  };

  export type AssessmentsCreateManyInput = {
    id?: number;
    instructions?: string | null;
    start_date?: Date | string | null;
    end_date?: Date | string | null;
    schedule_later?: boolean;
    start_time?: Date | string | null;
    end_time?: Date | string | null;
    any_time?: boolean;
    team?: string | null;
  };

  export type AssessmentsUpdateManyMutationInput = {
    instructions?: NullableStringFieldUpdateOperationsInput | string | null;
    start_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    end_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    schedule_later?: BoolFieldUpdateOperationsInput | boolean;
    start_time?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    end_time?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    any_time?: BoolFieldUpdateOperationsInput | boolean;
    team?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type AssessmentsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number;
    instructions?: NullableStringFieldUpdateOperationsInput | string | null;
    start_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    end_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    schedule_later?: BoolFieldUpdateOperationsInput | boolean;
    start_time?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    end_time?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    any_time?: BoolFieldUpdateOperationsInput | boolean;
    team?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type RequestsCreateInput = {
    status: string;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: boolean;
    texted_to_client?: boolean;
    title: string;
    service_details: string;
    assessment_date: Date | string;
    backup_assessment__date?: Date | string | null;
    preferred_arrival_times?: string | null;
    on_site_assesment_required?: boolean;
    internal_notes: string;
    internalAttachmentUrl: string;
    link_to_releated_quotes?: boolean;
    link_to_releated_jobs?: boolean;
    link_to_releated_invoices?: boolean;
    assessment: AssessmentsCreateNestedOneWithoutRequestsInput;
    client: ClientsCreateNestedOneWithoutRequestsInput;
    quotes?: QuoteRequestCreateNestedManyWithoutRequestInput;
    job_requests?: JobRequestCreateNestedManyWithoutRequestInput;
    belongs_to: UsersCreateNestedOneWithoutRequestsInput;
  };

  export type RequestsUncheckedCreateInput = {
    id?: number;
    status: string;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: boolean;
    texted_to_client?: boolean;
    title: string;
    service_details: string;
    assessment_date: Date | string;
    backup_assessment__date?: Date | string | null;
    preferred_arrival_times?: string | null;
    on_site_assesment_required?: boolean;
    client_id: number;
    assessment_id: number;
    internal_notes: string;
    internalAttachmentUrl: string;
    link_to_releated_quotes?: boolean;
    link_to_releated_jobs?: boolean;
    link_to_releated_invoices?: boolean;
    belongs_to_id: number;
    quotes?: QuoteRequestUncheckedCreateNestedManyWithoutRequestInput;
    job_requests?: JobRequestUncheckedCreateNestedManyWithoutRequestInput;
  };

  export type RequestsUpdateInput = {
    status?: StringFieldUpdateOperationsInput | string;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: BoolFieldUpdateOperationsInput | boolean;
    texted_to_client?: BoolFieldUpdateOperationsInput | boolean;
    title?: StringFieldUpdateOperationsInput | string;
    service_details?: StringFieldUpdateOperationsInput | string;
    assessment_date?: DateTimeFieldUpdateOperationsInput | Date | string;
    backup_assessment__date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    preferred_arrival_times?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    on_site_assesment_required?: BoolFieldUpdateOperationsInput | boolean;
    internal_notes?: StringFieldUpdateOperationsInput | string;
    internalAttachmentUrl?: StringFieldUpdateOperationsInput | string;
    link_to_releated_quotes?: BoolFieldUpdateOperationsInput | boolean;
    link_to_releated_jobs?: BoolFieldUpdateOperationsInput | boolean;
    link_to_releated_invoices?: BoolFieldUpdateOperationsInput | boolean;
    assessment?: AssessmentsUpdateOneRequiredWithoutRequestsNestedInput;
    client?: ClientsUpdateOneRequiredWithoutRequestsNestedInput;
    quotes?: QuoteRequestUpdateManyWithoutRequestNestedInput;
    job_requests?: JobRequestUpdateManyWithoutRequestNestedInput;
    belongs_to?: UsersUpdateOneRequiredWithoutRequestsNestedInput;
  };

  export type RequestsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number;
    status?: StringFieldUpdateOperationsInput | string;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: BoolFieldUpdateOperationsInput | boolean;
    texted_to_client?: BoolFieldUpdateOperationsInput | boolean;
    title?: StringFieldUpdateOperationsInput | string;
    service_details?: StringFieldUpdateOperationsInput | string;
    assessment_date?: DateTimeFieldUpdateOperationsInput | Date | string;
    backup_assessment__date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    preferred_arrival_times?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    on_site_assesment_required?: BoolFieldUpdateOperationsInput | boolean;
    client_id?: IntFieldUpdateOperationsInput | number;
    assessment_id?: IntFieldUpdateOperationsInput | number;
    internal_notes?: StringFieldUpdateOperationsInput | string;
    internalAttachmentUrl?: StringFieldUpdateOperationsInput | string;
    link_to_releated_quotes?: BoolFieldUpdateOperationsInput | boolean;
    link_to_releated_jobs?: BoolFieldUpdateOperationsInput | boolean;
    link_to_releated_invoices?: BoolFieldUpdateOperationsInput | boolean;
    belongs_to_id?: IntFieldUpdateOperationsInput | number;
    quotes?: QuoteRequestUncheckedUpdateManyWithoutRequestNestedInput;
    job_requests?: JobRequestUncheckedUpdateManyWithoutRequestNestedInput;
  };

  export type RequestsCreateManyInput = {
    id?: number;
    status: string;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: boolean;
    texted_to_client?: boolean;
    title: string;
    service_details: string;
    assessment_date: Date | string;
    backup_assessment__date?: Date | string | null;
    preferred_arrival_times?: string | null;
    on_site_assesment_required?: boolean;
    client_id: number;
    assessment_id: number;
    internal_notes: string;
    internalAttachmentUrl: string;
    link_to_releated_quotes?: boolean;
    link_to_releated_jobs?: boolean;
    link_to_releated_invoices?: boolean;
    belongs_to_id: number;
  };

  export type RequestsUpdateManyMutationInput = {
    status?: StringFieldUpdateOperationsInput | string;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: BoolFieldUpdateOperationsInput | boolean;
    texted_to_client?: BoolFieldUpdateOperationsInput | boolean;
    title?: StringFieldUpdateOperationsInput | string;
    service_details?: StringFieldUpdateOperationsInput | string;
    assessment_date?: DateTimeFieldUpdateOperationsInput | Date | string;
    backup_assessment__date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    preferred_arrival_times?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    on_site_assesment_required?: BoolFieldUpdateOperationsInput | boolean;
    internal_notes?: StringFieldUpdateOperationsInput | string;
    internalAttachmentUrl?: StringFieldUpdateOperationsInput | string;
    link_to_releated_quotes?: BoolFieldUpdateOperationsInput | boolean;
    link_to_releated_jobs?: BoolFieldUpdateOperationsInput | boolean;
    link_to_releated_invoices?: BoolFieldUpdateOperationsInput | boolean;
  };

  export type RequestsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number;
    status?: StringFieldUpdateOperationsInput | string;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: BoolFieldUpdateOperationsInput | boolean;
    texted_to_client?: BoolFieldUpdateOperationsInput | boolean;
    title?: StringFieldUpdateOperationsInput | string;
    service_details?: StringFieldUpdateOperationsInput | string;
    assessment_date?: DateTimeFieldUpdateOperationsInput | Date | string;
    backup_assessment__date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    preferred_arrival_times?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    on_site_assesment_required?: BoolFieldUpdateOperationsInput | boolean;
    client_id?: IntFieldUpdateOperationsInput | number;
    assessment_id?: IntFieldUpdateOperationsInput | number;
    internal_notes?: StringFieldUpdateOperationsInput | string;
    internalAttachmentUrl?: StringFieldUpdateOperationsInput | string;
    link_to_releated_quotes?: BoolFieldUpdateOperationsInput | boolean;
    link_to_releated_jobs?: BoolFieldUpdateOperationsInput | boolean;
    link_to_releated_invoices?: BoolFieldUpdateOperationsInput | boolean;
    belongs_to_id?: IntFieldUpdateOperationsInput | number;
  };

  export type LineItemsCreateInput = {
    type: string;
    name: string;
    description?: string | null;
    quantity?: number;
    unit_price: number;
    markup?: number | null;
    img_url?: string | null;
    recommend_item?: boolean;
    quotes?: LineItemQuoteCreateNestedManyWithoutLine_itemInput;
    invoices?: LineItemInvoiceCreateNestedManyWithoutLine_itemInput;
    jobs?: LineItemJobCreateNestedManyWithoutLine_itemInput;
  };

  export type LineItemsUncheckedCreateInput = {
    id?: number;
    type: string;
    name: string;
    description?: string | null;
    quantity?: number;
    unit_price: number;
    markup?: number | null;
    img_url?: string | null;
    recommend_item?: boolean;
    quotes?: LineItemQuoteUncheckedCreateNestedManyWithoutLine_itemInput;
    invoices?: LineItemInvoiceUncheckedCreateNestedManyWithoutLine_itemInput;
    jobs?: LineItemJobUncheckedCreateNestedManyWithoutLine_itemInput;
  };

  export type LineItemsUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    quantity?: IntFieldUpdateOperationsInput | number;
    unit_price?: FloatFieldUpdateOperationsInput | number;
    markup?: NullableFloatFieldUpdateOperationsInput | number | null;
    img_url?: NullableStringFieldUpdateOperationsInput | string | null;
    recommend_item?: BoolFieldUpdateOperationsInput | boolean;
    quotes?: LineItemQuoteUpdateManyWithoutLine_itemNestedInput;
    invoices?: LineItemInvoiceUpdateManyWithoutLine_itemNestedInput;
    jobs?: LineItemJobUpdateManyWithoutLine_itemNestedInput;
  };

  export type LineItemsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number;
    type?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    quantity?: IntFieldUpdateOperationsInput | number;
    unit_price?: FloatFieldUpdateOperationsInput | number;
    markup?: NullableFloatFieldUpdateOperationsInput | number | null;
    img_url?: NullableStringFieldUpdateOperationsInput | string | null;
    recommend_item?: BoolFieldUpdateOperationsInput | boolean;
    quotes?: LineItemQuoteUncheckedUpdateManyWithoutLine_itemNestedInput;
    invoices?: LineItemInvoiceUncheckedUpdateManyWithoutLine_itemNestedInput;
    jobs?: LineItemJobUncheckedUpdateManyWithoutLine_itemNestedInput;
  };

  export type LineItemsCreateManyInput = {
    id?: number;
    type: string;
    name: string;
    description?: string | null;
    quantity?: number;
    unit_price: number;
    markup?: number | null;
    img_url?: string | null;
    recommend_item?: boolean;
  };

  export type LineItemsUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    quantity?: IntFieldUpdateOperationsInput | number;
    unit_price?: FloatFieldUpdateOperationsInput | number;
    markup?: NullableFloatFieldUpdateOperationsInput | number | null;
    img_url?: NullableStringFieldUpdateOperationsInput | string | null;
    recommend_item?: BoolFieldUpdateOperationsInput | boolean;
  };

  export type LineItemsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number;
    type?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    quantity?: IntFieldUpdateOperationsInput | number;
    unit_price?: FloatFieldUpdateOperationsInput | number;
    markup?: NullableFloatFieldUpdateOperationsInput | number | null;
    img_url?: NullableStringFieldUpdateOperationsInput | string | null;
    recommend_item?: BoolFieldUpdateOperationsInput | boolean;
  };

  export type QuotesCreateInput = {
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: boolean;
    texted_to_client?: boolean;
    status: string;
    title: string;
    quote_number: string;
    opportunity_rating?: string | null;
    client_message?: string | null;
    discount?: number | null;
    discount_unit?: string | null;
    required_deposit?: number | null;
    link_to_releated_jobs?: boolean;
    link_to_releated_invoices?: boolean;
    client: ClientsCreateNestedOneWithoutQuotesInput;
    line_items?: LineItemQuoteCreateNestedManyWithoutQuoteInput;
    tax?: TaxesCreateNestedOneWithoutQuotesInput;
    requests?: QuoteRequestCreateNestedManyWithoutQuoteInput;
    job_quotes?: JobQuoteCreateNestedManyWithoutQuoteInput;
    belongs_to: UsersCreateNestedOneWithoutQuotesInput;
  };

  export type QuotesUncheckedCreateInput = {
    id?: number;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: boolean;
    texted_to_client?: boolean;
    status: string;
    title: string;
    quote_number: string;
    opportunity_rating?: string | null;
    client_id: number;
    client_message?: string | null;
    discount?: number | null;
    discount_unit?: string | null;
    tax_id: number;
    required_deposit?: number | null;
    link_to_releated_jobs?: boolean;
    link_to_releated_invoices?: boolean;
    belongs_to_id: number;
    line_items?: LineItemQuoteUncheckedCreateNestedManyWithoutQuoteInput;
    requests?: QuoteRequestUncheckedCreateNestedManyWithoutQuoteInput;
    job_quotes?: JobQuoteUncheckedCreateNestedManyWithoutQuoteInput;
  };

  export type QuotesUpdateInput = {
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: BoolFieldUpdateOperationsInput | boolean;
    texted_to_client?: BoolFieldUpdateOperationsInput | boolean;
    status?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    quote_number?: StringFieldUpdateOperationsInput | string;
    opportunity_rating?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    client_message?: NullableStringFieldUpdateOperationsInput | string | null;
    discount?: NullableFloatFieldUpdateOperationsInput | number | null;
    discount_unit?: NullableStringFieldUpdateOperationsInput | string | null;
    required_deposit?: NullableFloatFieldUpdateOperationsInput | number | null;
    link_to_releated_jobs?: BoolFieldUpdateOperationsInput | boolean;
    link_to_releated_invoices?: BoolFieldUpdateOperationsInput | boolean;
    client?: ClientsUpdateOneRequiredWithoutQuotesNestedInput;
    line_items?: LineItemQuoteUpdateManyWithoutQuoteNestedInput;
    tax?: TaxesUpdateOneWithoutQuotesNestedInput;
    requests?: QuoteRequestUpdateManyWithoutQuoteNestedInput;
    job_quotes?: JobQuoteUpdateManyWithoutQuoteNestedInput;
    belongs_to?: UsersUpdateOneRequiredWithoutQuotesNestedInput;
  };

  export type QuotesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: BoolFieldUpdateOperationsInput | boolean;
    texted_to_client?: BoolFieldUpdateOperationsInput | boolean;
    status?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    quote_number?: StringFieldUpdateOperationsInput | string;
    opportunity_rating?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    client_id?: IntFieldUpdateOperationsInput | number;
    client_message?: NullableStringFieldUpdateOperationsInput | string | null;
    discount?: NullableFloatFieldUpdateOperationsInput | number | null;
    discount_unit?: NullableStringFieldUpdateOperationsInput | string | null;
    tax_id?: IntFieldUpdateOperationsInput | number;
    required_deposit?: NullableFloatFieldUpdateOperationsInput | number | null;
    link_to_releated_jobs?: BoolFieldUpdateOperationsInput | boolean;
    link_to_releated_invoices?: BoolFieldUpdateOperationsInput | boolean;
    belongs_to_id?: IntFieldUpdateOperationsInput | number;
    line_items?: LineItemQuoteUncheckedUpdateManyWithoutQuoteNestedInput;
    requests?: QuoteRequestUncheckedUpdateManyWithoutQuoteNestedInput;
    job_quotes?: JobQuoteUncheckedUpdateManyWithoutQuoteNestedInput;
  };

  export type QuotesCreateManyInput = {
    id?: number;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: boolean;
    texted_to_client?: boolean;
    status: string;
    title: string;
    quote_number: string;
    opportunity_rating?: string | null;
    client_id: number;
    client_message?: string | null;
    discount?: number | null;
    discount_unit?: string | null;
    tax_id: number;
    required_deposit?: number | null;
    link_to_releated_jobs?: boolean;
    link_to_releated_invoices?: boolean;
    belongs_to_id: number;
  };

  export type QuotesUpdateManyMutationInput = {
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: BoolFieldUpdateOperationsInput | boolean;
    texted_to_client?: BoolFieldUpdateOperationsInput | boolean;
    status?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    quote_number?: StringFieldUpdateOperationsInput | string;
    opportunity_rating?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    client_message?: NullableStringFieldUpdateOperationsInput | string | null;
    discount?: NullableFloatFieldUpdateOperationsInput | number | null;
    discount_unit?: NullableStringFieldUpdateOperationsInput | string | null;
    required_deposit?: NullableFloatFieldUpdateOperationsInput | number | null;
    link_to_releated_jobs?: BoolFieldUpdateOperationsInput | boolean;
    link_to_releated_invoices?: BoolFieldUpdateOperationsInput | boolean;
  };

  export type QuotesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: BoolFieldUpdateOperationsInput | boolean;
    texted_to_client?: BoolFieldUpdateOperationsInput | boolean;
    status?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    quote_number?: StringFieldUpdateOperationsInput | string;
    opportunity_rating?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    client_id?: IntFieldUpdateOperationsInput | number;
    client_message?: NullableStringFieldUpdateOperationsInput | string | null;
    discount?: NullableFloatFieldUpdateOperationsInput | number | null;
    discount_unit?: NullableStringFieldUpdateOperationsInput | string | null;
    tax_id?: IntFieldUpdateOperationsInput | number;
    required_deposit?: NullableFloatFieldUpdateOperationsInput | number | null;
    link_to_releated_jobs?: BoolFieldUpdateOperationsInput | boolean;
    link_to_releated_invoices?: BoolFieldUpdateOperationsInput | boolean;
    belongs_to_id?: IntFieldUpdateOperationsInput | number;
  };

  export type LineItemQuoteCreateInput = {
    quote: QuotesCreateNestedOneWithoutLine_itemsInput;
    line_item: LineItemsCreateNestedOneWithoutQuotesInput;
  };

  export type LineItemQuoteUncheckedCreateInput = {
    id?: number;
    quote_id: number;
    line_item_id: number;
  };

  export type LineItemQuoteUpdateInput = {
    quote?: QuotesUpdateOneRequiredWithoutLine_itemsNestedInput;
    line_item?: LineItemsUpdateOneRequiredWithoutQuotesNestedInput;
  };

  export type LineItemQuoteUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number;
    quote_id?: IntFieldUpdateOperationsInput | number;
    line_item_id?: IntFieldUpdateOperationsInput | number;
  };

  export type LineItemQuoteCreateManyInput = {
    id?: number;
    quote_id: number;
    line_item_id: number;
  };

  export type LineItemQuoteUpdateManyMutationInput = {};

  export type LineItemQuoteUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number;
    quote_id?: IntFieldUpdateOperationsInput | number;
    line_item_id?: IntFieldUpdateOperationsInput | number;
  };

  export type QuoteRequestCreateInput = {
    quote: QuotesCreateNestedOneWithoutRequestsInput;
    request: RequestsCreateNestedOneWithoutQuotesInput;
  };

  export type QuoteRequestUncheckedCreateInput = {
    id?: number;
    quoteId: number;
    requestId: number;
  };

  export type QuoteRequestUpdateInput = {
    quote?: QuotesUpdateOneRequiredWithoutRequestsNestedInput;
    request?: RequestsUpdateOneRequiredWithoutQuotesNestedInput;
  };

  export type QuoteRequestUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number;
    quoteId?: IntFieldUpdateOperationsInput | number;
    requestId?: IntFieldUpdateOperationsInput | number;
  };

  export type QuoteRequestCreateManyInput = {
    id?: number;
    quoteId: number;
    requestId: number;
  };

  export type QuoteRequestUpdateManyMutationInput = {};

  export type QuoteRequestUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number;
    quoteId?: IntFieldUpdateOperationsInput | number;
    requestId?: IntFieldUpdateOperationsInput | number;
  };

  export type JobsCreateInput = {
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: boolean;
    texted_to_client?: boolean;
    status: string;
    title: string;
    instructions?: string | null;
    number: string;
    schedule_type: string;
    recurring_frequency?: string | null;
    recurring_interval?: string | null;
    day_of_week?: string | null;
    day_of_year?: string | null;
    duration?: string | null;
    start_date?: Date | string | null;
    end_date?: Date | string | null;
    start_time?: Date | string | null;
    end_time?: Date | string | null;
    schedule_later?: boolean;
    team?: string | null;
    email_team?: boolean;
    invoice_reminder?: boolean;
    internal_notes?: string | null;
    internal_attachment_url?: string | null;
    link_to_related_invoices?: boolean;
    client: ClientsCreateNestedOneWithoutJobsInput;
    line_items?: LineItemJobCreateNestedManyWithoutJobInput;
    job_requests?: JobRequestCreateNestedManyWithoutJobInput;
    job_quotes?: JobQuoteCreateNestedManyWithoutJobInput;
    invoices?: InvoicesCreateNestedManyWithoutJobInput;
    belongs_to: UsersCreateNestedOneWithoutJobsInput;
  };

  export type JobsUncheckedCreateInput = {
    id?: number;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: boolean;
    texted_to_client?: boolean;
    status: string;
    client_id: number;
    title: string;
    instructions?: string | null;
    number: string;
    schedule_type: string;
    recurring_frequency?: string | null;
    recurring_interval?: string | null;
    day_of_week?: string | null;
    day_of_year?: string | null;
    duration?: string | null;
    start_date?: Date | string | null;
    end_date?: Date | string | null;
    start_time?: Date | string | null;
    end_time?: Date | string | null;
    schedule_later?: boolean;
    team?: string | null;
    email_team?: boolean;
    invoice_reminder?: boolean;
    internal_notes?: string | null;
    internal_attachment_url?: string | null;
    link_to_related_invoices?: boolean;
    belongs_to_id: number;
    line_items?: LineItemJobUncheckedCreateNestedManyWithoutJobInput;
    job_requests?: JobRequestUncheckedCreateNestedManyWithoutJobInput;
    job_quotes?: JobQuoteUncheckedCreateNestedManyWithoutJobInput;
    invoices?: InvoicesUncheckedCreateNestedManyWithoutJobInput;
  };

  export type JobsUpdateInput = {
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: BoolFieldUpdateOperationsInput | boolean;
    texted_to_client?: BoolFieldUpdateOperationsInput | boolean;
    status?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    instructions?: NullableStringFieldUpdateOperationsInput | string | null;
    number?: StringFieldUpdateOperationsInput | string;
    schedule_type?: StringFieldUpdateOperationsInput | string;
    recurring_frequency?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    recurring_interval?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    day_of_week?: NullableStringFieldUpdateOperationsInput | string | null;
    day_of_year?: NullableStringFieldUpdateOperationsInput | string | null;
    duration?: NullableStringFieldUpdateOperationsInput | string | null;
    start_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    end_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    start_time?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    end_time?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    schedule_later?: BoolFieldUpdateOperationsInput | boolean;
    team?: NullableStringFieldUpdateOperationsInput | string | null;
    email_team?: BoolFieldUpdateOperationsInput | boolean;
    invoice_reminder?: BoolFieldUpdateOperationsInput | boolean;
    internal_notes?: NullableStringFieldUpdateOperationsInput | string | null;
    internal_attachment_url?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    link_to_related_invoices?: BoolFieldUpdateOperationsInput | boolean;
    client?: ClientsUpdateOneRequiredWithoutJobsNestedInput;
    line_items?: LineItemJobUpdateManyWithoutJobNestedInput;
    job_requests?: JobRequestUpdateManyWithoutJobNestedInput;
    job_quotes?: JobQuoteUpdateManyWithoutJobNestedInput;
    invoices?: InvoicesUpdateManyWithoutJobNestedInput;
    belongs_to?: UsersUpdateOneRequiredWithoutJobsNestedInput;
  };

  export type JobsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: BoolFieldUpdateOperationsInput | boolean;
    texted_to_client?: BoolFieldUpdateOperationsInput | boolean;
    status?: StringFieldUpdateOperationsInput | string;
    client_id?: IntFieldUpdateOperationsInput | number;
    title?: StringFieldUpdateOperationsInput | string;
    instructions?: NullableStringFieldUpdateOperationsInput | string | null;
    number?: StringFieldUpdateOperationsInput | string;
    schedule_type?: StringFieldUpdateOperationsInput | string;
    recurring_frequency?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    recurring_interval?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    day_of_week?: NullableStringFieldUpdateOperationsInput | string | null;
    day_of_year?: NullableStringFieldUpdateOperationsInput | string | null;
    duration?: NullableStringFieldUpdateOperationsInput | string | null;
    start_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    end_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    start_time?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    end_time?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    schedule_later?: BoolFieldUpdateOperationsInput | boolean;
    team?: NullableStringFieldUpdateOperationsInput | string | null;
    email_team?: BoolFieldUpdateOperationsInput | boolean;
    invoice_reminder?: BoolFieldUpdateOperationsInput | boolean;
    internal_notes?: NullableStringFieldUpdateOperationsInput | string | null;
    internal_attachment_url?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    link_to_related_invoices?: BoolFieldUpdateOperationsInput | boolean;
    belongs_to_id?: IntFieldUpdateOperationsInput | number;
    line_items?: LineItemJobUncheckedUpdateManyWithoutJobNestedInput;
    job_requests?: JobRequestUncheckedUpdateManyWithoutJobNestedInput;
    job_quotes?: JobQuoteUncheckedUpdateManyWithoutJobNestedInput;
    invoices?: InvoicesUncheckedUpdateManyWithoutJobNestedInput;
  };

  export type JobsCreateManyInput = {
    id?: number;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: boolean;
    texted_to_client?: boolean;
    status: string;
    client_id: number;
    title: string;
    instructions?: string | null;
    number: string;
    schedule_type: string;
    recurring_frequency?: string | null;
    recurring_interval?: string | null;
    day_of_week?: string | null;
    day_of_year?: string | null;
    duration?: string | null;
    start_date?: Date | string | null;
    end_date?: Date | string | null;
    start_time?: Date | string | null;
    end_time?: Date | string | null;
    schedule_later?: boolean;
    team?: string | null;
    email_team?: boolean;
    invoice_reminder?: boolean;
    internal_notes?: string | null;
    internal_attachment_url?: string | null;
    link_to_related_invoices?: boolean;
    belongs_to_id: number;
  };

  export type JobsUpdateManyMutationInput = {
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: BoolFieldUpdateOperationsInput | boolean;
    texted_to_client?: BoolFieldUpdateOperationsInput | boolean;
    status?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    instructions?: NullableStringFieldUpdateOperationsInput | string | null;
    number?: StringFieldUpdateOperationsInput | string;
    schedule_type?: StringFieldUpdateOperationsInput | string;
    recurring_frequency?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    recurring_interval?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    day_of_week?: NullableStringFieldUpdateOperationsInput | string | null;
    day_of_year?: NullableStringFieldUpdateOperationsInput | string | null;
    duration?: NullableStringFieldUpdateOperationsInput | string | null;
    start_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    end_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    start_time?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    end_time?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    schedule_later?: BoolFieldUpdateOperationsInput | boolean;
    team?: NullableStringFieldUpdateOperationsInput | string | null;
    email_team?: BoolFieldUpdateOperationsInput | boolean;
    invoice_reminder?: BoolFieldUpdateOperationsInput | boolean;
    internal_notes?: NullableStringFieldUpdateOperationsInput | string | null;
    internal_attachment_url?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    link_to_related_invoices?: BoolFieldUpdateOperationsInput | boolean;
  };

  export type JobsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: BoolFieldUpdateOperationsInput | boolean;
    texted_to_client?: BoolFieldUpdateOperationsInput | boolean;
    status?: StringFieldUpdateOperationsInput | string;
    client_id?: IntFieldUpdateOperationsInput | number;
    title?: StringFieldUpdateOperationsInput | string;
    instructions?: NullableStringFieldUpdateOperationsInput | string | null;
    number?: StringFieldUpdateOperationsInput | string;
    schedule_type?: StringFieldUpdateOperationsInput | string;
    recurring_frequency?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    recurring_interval?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    day_of_week?: NullableStringFieldUpdateOperationsInput | string | null;
    day_of_year?: NullableStringFieldUpdateOperationsInput | string | null;
    duration?: NullableStringFieldUpdateOperationsInput | string | null;
    start_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    end_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    start_time?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    end_time?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    schedule_later?: BoolFieldUpdateOperationsInput | boolean;
    team?: NullableStringFieldUpdateOperationsInput | string | null;
    email_team?: BoolFieldUpdateOperationsInput | boolean;
    invoice_reminder?: BoolFieldUpdateOperationsInput | boolean;
    internal_notes?: NullableStringFieldUpdateOperationsInput | string | null;
    internal_attachment_url?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    link_to_related_invoices?: BoolFieldUpdateOperationsInput | boolean;
    belongs_to_id?: IntFieldUpdateOperationsInput | number;
  };

  export type LineItemJobCreateInput = {
    job: JobsCreateNestedOneWithoutLine_itemsInput;
    line_item: LineItemsCreateNestedOneWithoutJobsInput;
  };

  export type LineItemJobUncheckedCreateInput = {
    id?: number;
    job_id: number;
    line_item_id: number;
  };

  export type LineItemJobUpdateInput = {
    job?: JobsUpdateOneRequiredWithoutLine_itemsNestedInput;
    line_item?: LineItemsUpdateOneRequiredWithoutJobsNestedInput;
  };

  export type LineItemJobUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number;
    job_id?: IntFieldUpdateOperationsInput | number;
    line_item_id?: IntFieldUpdateOperationsInput | number;
  };

  export type LineItemJobCreateManyInput = {
    id?: number;
    job_id: number;
    line_item_id: number;
  };

  export type LineItemJobUpdateManyMutationInput = {};

  export type LineItemJobUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number;
    job_id?: IntFieldUpdateOperationsInput | number;
    line_item_id?: IntFieldUpdateOperationsInput | number;
  };

  export type JobRequestCreateInput = {
    job: JobsCreateNestedOneWithoutJob_requestsInput;
    request: RequestsCreateNestedOneWithoutJob_requestsInput;
  };

  export type JobRequestUncheckedCreateInput = {
    id?: number;
    job_id: number;
    request_id: number;
  };

  export type JobRequestUpdateInput = {
    job?: JobsUpdateOneRequiredWithoutJob_requestsNestedInput;
    request?: RequestsUpdateOneRequiredWithoutJob_requestsNestedInput;
  };

  export type JobRequestUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number;
    job_id?: IntFieldUpdateOperationsInput | number;
    request_id?: IntFieldUpdateOperationsInput | number;
  };

  export type JobRequestCreateManyInput = {
    id?: number;
    job_id: number;
    request_id: number;
  };

  export type JobRequestUpdateManyMutationInput = {};

  export type JobRequestUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number;
    job_id?: IntFieldUpdateOperationsInput | number;
    request_id?: IntFieldUpdateOperationsInput | number;
  };

  export type JobQuoteCreateInput = {
    job: JobsCreateNestedOneWithoutJob_quotesInput;
    quote: QuotesCreateNestedOneWithoutJob_quotesInput;
  };

  export type JobQuoteUncheckedCreateInput = {
    id?: number;
    job_id: number;
    quote_id: number;
  };

  export type JobQuoteUpdateInput = {
    job?: JobsUpdateOneRequiredWithoutJob_quotesNestedInput;
    quote?: QuotesUpdateOneRequiredWithoutJob_quotesNestedInput;
  };

  export type JobQuoteUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number;
    job_id?: IntFieldUpdateOperationsInput | number;
    quote_id?: IntFieldUpdateOperationsInput | number;
  };

  export type JobQuoteCreateManyInput = {
    id?: number;
    job_id: number;
    quote_id: number;
  };

  export type JobQuoteUpdateManyMutationInput = {};

  export type JobQuoteUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number;
    job_id?: IntFieldUpdateOperationsInput | number;
    quote_id?: IntFieldUpdateOperationsInput | number;
  };

  export type InvoicesCreateInput = {
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: boolean;
    texted_to_client?: boolean;
    issued_date: Date | string;
    due_date?: Date | string | null;
    status: string;
    type: string;
    subject: string;
    client_message: string;
    internal_notes: string;
    internalAttachmentUrl: string;
    client: ClientsCreateNestedOneWithoutInvoicesInput;
    job?: JobsCreateNestedOneWithoutInvoicesInput;
    tax?: TaxesCreateNestedOneWithoutInvoicesInput;
    additional_line_items?: LineItemInvoiceCreateNestedManyWithoutInvoiceInput;
    belongs_to: UsersCreateNestedOneWithoutInvoicesInput;
  };

  export type InvoicesUncheckedCreateInput = {
    id?: number;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: boolean;
    texted_to_client?: boolean;
    issued_date: Date | string;
    due_date?: Date | string | null;
    status: string;
    type: string;
    subject: string;
    client_id: number;
    job_id?: number | null;
    tax_id?: number | null;
    client_message: string;
    internal_notes: string;
    internalAttachmentUrl: string;
    belongs_to_id: number;
    additional_line_items?: LineItemInvoiceUncheckedCreateNestedManyWithoutInvoiceInput;
  };

  export type InvoicesUpdateInput = {
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: BoolFieldUpdateOperationsInput | boolean;
    texted_to_client?: BoolFieldUpdateOperationsInput | boolean;
    issued_date?: DateTimeFieldUpdateOperationsInput | Date | string;
    due_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    status?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    subject?: StringFieldUpdateOperationsInput | string;
    client_message?: StringFieldUpdateOperationsInput | string;
    internal_notes?: StringFieldUpdateOperationsInput | string;
    internalAttachmentUrl?: StringFieldUpdateOperationsInput | string;
    client?: ClientsUpdateOneRequiredWithoutInvoicesNestedInput;
    job?: JobsUpdateOneWithoutInvoicesNestedInput;
    tax?: TaxesUpdateOneWithoutInvoicesNestedInput;
    additional_line_items?: LineItemInvoiceUpdateManyWithoutInvoiceNestedInput;
    belongs_to?: UsersUpdateOneRequiredWithoutInvoicesNestedInput;
  };

  export type InvoicesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: BoolFieldUpdateOperationsInput | boolean;
    texted_to_client?: BoolFieldUpdateOperationsInput | boolean;
    issued_date?: DateTimeFieldUpdateOperationsInput | Date | string;
    due_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    status?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    subject?: StringFieldUpdateOperationsInput | string;
    client_id?: IntFieldUpdateOperationsInput | number;
    job_id?: NullableIntFieldUpdateOperationsInput | number | null;
    tax_id?: NullableIntFieldUpdateOperationsInput | number | null;
    client_message?: StringFieldUpdateOperationsInput | string;
    internal_notes?: StringFieldUpdateOperationsInput | string;
    internalAttachmentUrl?: StringFieldUpdateOperationsInput | string;
    belongs_to_id?: IntFieldUpdateOperationsInput | number;
    additional_line_items?: LineItemInvoiceUncheckedUpdateManyWithoutInvoiceNestedInput;
  };

  export type InvoicesCreateManyInput = {
    id?: number;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: boolean;
    texted_to_client?: boolean;
    issued_date: Date | string;
    due_date?: Date | string | null;
    status: string;
    type: string;
    subject: string;
    client_id: number;
    job_id?: number | null;
    tax_id?: number | null;
    client_message: string;
    internal_notes: string;
    internalAttachmentUrl: string;
    belongs_to_id: number;
  };

  export type InvoicesUpdateManyMutationInput = {
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: BoolFieldUpdateOperationsInput | boolean;
    texted_to_client?: BoolFieldUpdateOperationsInput | boolean;
    issued_date?: DateTimeFieldUpdateOperationsInput | Date | string;
    due_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    status?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    subject?: StringFieldUpdateOperationsInput | string;
    client_message?: StringFieldUpdateOperationsInput | string;
    internal_notes?: StringFieldUpdateOperationsInput | string;
    internalAttachmentUrl?: StringFieldUpdateOperationsInput | string;
  };

  export type InvoicesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: BoolFieldUpdateOperationsInput | boolean;
    texted_to_client?: BoolFieldUpdateOperationsInput | boolean;
    issued_date?: DateTimeFieldUpdateOperationsInput | Date | string;
    due_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    status?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    subject?: StringFieldUpdateOperationsInput | string;
    client_id?: IntFieldUpdateOperationsInput | number;
    job_id?: NullableIntFieldUpdateOperationsInput | number | null;
    tax_id?: NullableIntFieldUpdateOperationsInput | number | null;
    client_message?: StringFieldUpdateOperationsInput | string;
    internal_notes?: StringFieldUpdateOperationsInput | string;
    internalAttachmentUrl?: StringFieldUpdateOperationsInput | string;
    belongs_to_id?: IntFieldUpdateOperationsInput | number;
  };

  export type LineItemInvoiceCreateInput = {
    invoice: InvoicesCreateNestedOneWithoutAdditional_line_itemsInput;
    line_item: LineItemsCreateNestedOneWithoutInvoicesInput;
  };

  export type LineItemInvoiceUncheckedCreateInput = {
    id?: number;
    invoice_id: number;
    line_item_id: number;
  };

  export type LineItemInvoiceUpdateInput = {
    invoice?: InvoicesUpdateOneRequiredWithoutAdditional_line_itemsNestedInput;
    line_item?: LineItemsUpdateOneRequiredWithoutInvoicesNestedInput;
  };

  export type LineItemInvoiceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number;
    invoice_id?: IntFieldUpdateOperationsInput | number;
    line_item_id?: IntFieldUpdateOperationsInput | number;
  };

  export type LineItemInvoiceCreateManyInput = {
    id?: number;
    invoice_id: number;
    line_item_id: number;
  };

  export type LineItemInvoiceUpdateManyMutationInput = {};

  export type LineItemInvoiceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number;
    invoice_id?: IntFieldUpdateOperationsInput | number;
    line_item_id?: IntFieldUpdateOperationsInput | number;
  };

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntFilter<$PrismaModel> | number;
  };

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?: NestedStringFilter<$PrismaModel> | string;
  };

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatFilter<$PrismaModel> | number;
  };

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?: NestedStringNullableFilter<$PrismaModel> | string | null;
  };

  export type UsersListRelationFilter = {
    every?: UsersWhereInput;
    some?: UsersWhereInput;
    none?: UsersWhereInput;
  };

  export type QuotesListRelationFilter = {
    every?: QuotesWhereInput;
    some?: QuotesWhereInput;
    none?: QuotesWhereInput;
  };

  export type InvoicesListRelationFilter = {
    every?: InvoicesWhereInput;
    some?: InvoicesWhereInput;
    none?: InvoicesWhereInput;
  };

  export type SortOrderInput = {
    sort: SortOrder;
    nulls?: NullsOrder;
  };

  export type UsersOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type QuotesOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type InvoicesOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type TaxesCountOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    rate?: SortOrder;
    description?: SortOrder;
  };

  export type TaxesAvgOrderByAggregateInput = {
    id?: SortOrder;
    rate?: SortOrder;
  };

  export type TaxesMaxOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    rate?: SortOrder;
    description?: SortOrder;
  };

  export type TaxesMinOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    rate?: SortOrder;
    description?: SortOrder;
  };

  export type TaxesSumOrderByAggregateInput = {
    id?: SortOrder;
    rate?: SortOrder;
  };

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedFloatFilter<$PrismaModel>;
    _sum?: NestedIntFilter<$PrismaModel>;
    _min?: NestedIntFilter<$PrismaModel>;
    _max?: NestedIntFilter<$PrismaModel>;
  };

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedStringFilter<$PrismaModel>;
    _max?: NestedStringFilter<$PrismaModel>;
  };

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedFloatFilter<$PrismaModel>;
    _sum?: NestedFloatFilter<$PrismaModel>;
    _min?: NestedFloatFilter<$PrismaModel>;
    _max?: NestedFloatFilter<$PrismaModel>;
  };

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?:
      | NestedStringNullableWithAggregatesFilter<$PrismaModel>
      | string
      | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedStringNullableFilter<$PrismaModel>;
    _max?: NestedStringNullableFilter<$PrismaModel>;
  };

  export type ClientsListRelationFilter = {
    every?: ClientsWhereInput;
    some?: ClientsWhereInput;
    none?: ClientsWhereInput;
  };

  export type ClientsOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type AddressesCountOrderByAggregateInput = {
    id?: SortOrder;
    street1?: SortOrder;
    street2?: SortOrder;
    city?: SortOrder;
    state?: SortOrder;
    zip_code?: SortOrder;
    country?: SortOrder;
  };

  export type AddressesAvgOrderByAggregateInput = {
    id?: SortOrder;
  };

  export type AddressesMaxOrderByAggregateInput = {
    id?: SortOrder;
    street1?: SortOrder;
    street2?: SortOrder;
    city?: SortOrder;
    state?: SortOrder;
    zip_code?: SortOrder;
    country?: SortOrder;
  };

  export type AddressesMinOrderByAggregateInput = {
    id?: SortOrder;
    street1?: SortOrder;
    street2?: SortOrder;
    city?: SortOrder;
    state?: SortOrder;
    zip_code?: SortOrder;
    country?: SortOrder;
  };

  export type AddressesSumOrderByAggregateInput = {
    id?: SortOrder;
  };

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null;
  };

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableFilter<$PrismaModel> | number | null;
  };
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<JsonNullableFilterBase<$PrismaModel>>,
          Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, "path">
        >,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<
        Omit<Required<JsonNullableFilterBase<$PrismaModel>>, "path">
      >;

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter;
    path?: string[];
    string_contains?: string | StringFieldRefInput<$PrismaModel>;
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>;
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>;
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    not?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter;
  };

  export type TaxesNullableRelationFilter = {
    is?: TaxesWhereInput | null;
    isNot?: TaxesWhereInput | null;
  };

  export type AddressesNullableRelationFilter = {
    is?: AddressesWhereInput | null;
    isNot?: AddressesWhereInput | null;
  };

  export type RequestsListRelationFilter = {
    every?: RequestsWhereInput;
    some?: RequestsWhereInput;
    none?: RequestsWhereInput;
  };

  export type JobsListRelationFilter = {
    every?: JobsWhereInput;
    some?: JobsWhereInput;
    none?: JobsWhereInput;
  };

  export type RequestsOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type JobsOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type UsersCountOrderByAggregateInput = {
    id?: SortOrder;
    email?: SortOrder;
    password?: SortOrder;
    first_name?: SortOrder;
    last_name?: SortOrder;
    phone_number?: SortOrder;
    company_name?: SortOrder;
    subscription_id?: SortOrder;
    free_trial_expiration_date?: SortOrder;
    default_tax_id?: SortOrder;
    address_id?: SortOrder;
    settings?: SortOrder;
  };

  export type UsersAvgOrderByAggregateInput = {
    id?: SortOrder;
    default_tax_id?: SortOrder;
    address_id?: SortOrder;
  };

  export type UsersMaxOrderByAggregateInput = {
    id?: SortOrder;
    email?: SortOrder;
    password?: SortOrder;
    first_name?: SortOrder;
    last_name?: SortOrder;
    phone_number?: SortOrder;
    company_name?: SortOrder;
    subscription_id?: SortOrder;
    free_trial_expiration_date?: SortOrder;
    default_tax_id?: SortOrder;
    address_id?: SortOrder;
  };

  export type UsersMinOrderByAggregateInput = {
    id?: SortOrder;
    email?: SortOrder;
    password?: SortOrder;
    first_name?: SortOrder;
    last_name?: SortOrder;
    phone_number?: SortOrder;
    company_name?: SortOrder;
    subscription_id?: SortOrder;
    free_trial_expiration_date?: SortOrder;
    default_tax_id?: SortOrder;
    address_id?: SortOrder;
  };

  export type UsersSumOrderByAggregateInput = {
    id?: SortOrder;
    default_tax_id?: SortOrder;
    address_id?: SortOrder;
  };

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?:
      | NestedDateTimeNullableWithAggregatesFilter<$PrismaModel>
      | Date
      | string
      | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedDateTimeNullableFilter<$PrismaModel>;
    _max?: NestedDateTimeNullableFilter<$PrismaModel>;
  };

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _avg?: NestedFloatNullableFilter<$PrismaModel>;
    _sum?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedIntNullableFilter<$PrismaModel>;
    _max?: NestedIntNullableFilter<$PrismaModel>;
  };
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>,
          Exclude<
            keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>,
            "path"
          >
        >,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<
        Omit<
          Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>,
          "path"
        >
      >;

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter;
    path?: string[];
    string_contains?: string | StringFieldRefInput<$PrismaModel>;
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>;
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>;
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    not?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedJsonNullableFilter<$PrismaModel>;
    _max?: NestedJsonNullableFilter<$PrismaModel>;
  };

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolFilter<$PrismaModel> | boolean;
  };

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string;
  };

  export type UsersRelationFilter = {
    is?: UsersWhereInput;
    isNot?: UsersWhereInput;
  };

  export type ClientsCountOrderByAggregateInput = {
    id?: SortOrder;
    title?: SortOrder;
    tags?: SortOrder;
    first_name?: SortOrder;
    last_name?: SortOrder;
    company_name?: SortOrder;
    use_company_name_as_primary?: SortOrder;
    mobile_phone_number?: SortOrder;
    work_phone_number?: SortOrder;
    email?: SortOrder;
    quote_follow_up?: SortOrder;
    job_follow_up?: SortOrder;
    invoice_follow_up?: SortOrder;
    upcoming_visit_reminder?: SortOrder;
    referred_by?: SortOrder;
    billing_address_same_as_property?: SortOrder;
    property_address_id?: SortOrder;
    billing_address_id?: SortOrder;
    created_date?: SortOrder;
    status?: SortOrder;
    belongs_to_id?: SortOrder;
  };

  export type ClientsAvgOrderByAggregateInput = {
    id?: SortOrder;
    property_address_id?: SortOrder;
    billing_address_id?: SortOrder;
    belongs_to_id?: SortOrder;
  };

  export type ClientsMaxOrderByAggregateInput = {
    id?: SortOrder;
    title?: SortOrder;
    first_name?: SortOrder;
    last_name?: SortOrder;
    company_name?: SortOrder;
    use_company_name_as_primary?: SortOrder;
    mobile_phone_number?: SortOrder;
    work_phone_number?: SortOrder;
    email?: SortOrder;
    quote_follow_up?: SortOrder;
    job_follow_up?: SortOrder;
    invoice_follow_up?: SortOrder;
    upcoming_visit_reminder?: SortOrder;
    referred_by?: SortOrder;
    billing_address_same_as_property?: SortOrder;
    property_address_id?: SortOrder;
    billing_address_id?: SortOrder;
    created_date?: SortOrder;
    status?: SortOrder;
    belongs_to_id?: SortOrder;
  };

  export type ClientsMinOrderByAggregateInput = {
    id?: SortOrder;
    title?: SortOrder;
    first_name?: SortOrder;
    last_name?: SortOrder;
    company_name?: SortOrder;
    use_company_name_as_primary?: SortOrder;
    mobile_phone_number?: SortOrder;
    work_phone_number?: SortOrder;
    email?: SortOrder;
    quote_follow_up?: SortOrder;
    job_follow_up?: SortOrder;
    invoice_follow_up?: SortOrder;
    upcoming_visit_reminder?: SortOrder;
    referred_by?: SortOrder;
    billing_address_same_as_property?: SortOrder;
    property_address_id?: SortOrder;
    billing_address_id?: SortOrder;
    created_date?: SortOrder;
    status?: SortOrder;
    belongs_to_id?: SortOrder;
  };

  export type ClientsSumOrderByAggregateInput = {
    id?: SortOrder;
    property_address_id?: SortOrder;
    billing_address_id?: SortOrder;
    belongs_to_id?: SortOrder;
  };

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedBoolFilter<$PrismaModel>;
    _max?: NestedBoolFilter<$PrismaModel>;
  };

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedDateTimeFilter<$PrismaModel>;
    _max?: NestedDateTimeFilter<$PrismaModel>;
  };

  export type AssessmentsCountOrderByAggregateInput = {
    id?: SortOrder;
    instructions?: SortOrder;
    start_date?: SortOrder;
    end_date?: SortOrder;
    schedule_later?: SortOrder;
    start_time?: SortOrder;
    end_time?: SortOrder;
    any_time?: SortOrder;
    team?: SortOrder;
  };

  export type AssessmentsAvgOrderByAggregateInput = {
    id?: SortOrder;
  };

  export type AssessmentsMaxOrderByAggregateInput = {
    id?: SortOrder;
    instructions?: SortOrder;
    start_date?: SortOrder;
    end_date?: SortOrder;
    schedule_later?: SortOrder;
    start_time?: SortOrder;
    end_time?: SortOrder;
    any_time?: SortOrder;
    team?: SortOrder;
  };

  export type AssessmentsMinOrderByAggregateInput = {
    id?: SortOrder;
    instructions?: SortOrder;
    start_date?: SortOrder;
    end_date?: SortOrder;
    schedule_later?: SortOrder;
    start_time?: SortOrder;
    end_time?: SortOrder;
    any_time?: SortOrder;
    team?: SortOrder;
  };

  export type AssessmentsSumOrderByAggregateInput = {
    id?: SortOrder;
  };

  export type AssessmentsRelationFilter = {
    is?: AssessmentsWhereInput;
    isNot?: AssessmentsWhereInput;
  };

  export type ClientsRelationFilter = {
    is?: ClientsWhereInput;
    isNot?: ClientsWhereInput;
  };

  export type QuoteRequestListRelationFilter = {
    every?: QuoteRequestWhereInput;
    some?: QuoteRequestWhereInput;
    none?: QuoteRequestWhereInput;
  };

  export type JobRequestListRelationFilter = {
    every?: JobRequestWhereInput;
    some?: JobRequestWhereInput;
    none?: JobRequestWhereInput;
  };

  export type QuoteRequestOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type JobRequestOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type RequestsCountOrderByAggregateInput = {
    id?: SortOrder;
    status?: SortOrder;
    tags?: SortOrder;
    emailed_to_client?: SortOrder;
    texted_to_client?: SortOrder;
    title?: SortOrder;
    service_details?: SortOrder;
    assessment_date?: SortOrder;
    backup_assessment__date?: SortOrder;
    preferred_arrival_times?: SortOrder;
    on_site_assesment_required?: SortOrder;
    client_id?: SortOrder;
    assessment_id?: SortOrder;
    internal_notes?: SortOrder;
    internalAttachmentUrl?: SortOrder;
    link_to_releated_quotes?: SortOrder;
    link_to_releated_jobs?: SortOrder;
    link_to_releated_invoices?: SortOrder;
    belongs_to_id?: SortOrder;
  };

  export type RequestsAvgOrderByAggregateInput = {
    id?: SortOrder;
    client_id?: SortOrder;
    assessment_id?: SortOrder;
    belongs_to_id?: SortOrder;
  };

  export type RequestsMaxOrderByAggregateInput = {
    id?: SortOrder;
    status?: SortOrder;
    emailed_to_client?: SortOrder;
    texted_to_client?: SortOrder;
    title?: SortOrder;
    service_details?: SortOrder;
    assessment_date?: SortOrder;
    backup_assessment__date?: SortOrder;
    preferred_arrival_times?: SortOrder;
    on_site_assesment_required?: SortOrder;
    client_id?: SortOrder;
    assessment_id?: SortOrder;
    internal_notes?: SortOrder;
    internalAttachmentUrl?: SortOrder;
    link_to_releated_quotes?: SortOrder;
    link_to_releated_jobs?: SortOrder;
    link_to_releated_invoices?: SortOrder;
    belongs_to_id?: SortOrder;
  };

  export type RequestsMinOrderByAggregateInput = {
    id?: SortOrder;
    status?: SortOrder;
    emailed_to_client?: SortOrder;
    texted_to_client?: SortOrder;
    title?: SortOrder;
    service_details?: SortOrder;
    assessment_date?: SortOrder;
    backup_assessment__date?: SortOrder;
    preferred_arrival_times?: SortOrder;
    on_site_assesment_required?: SortOrder;
    client_id?: SortOrder;
    assessment_id?: SortOrder;
    internal_notes?: SortOrder;
    internalAttachmentUrl?: SortOrder;
    link_to_releated_quotes?: SortOrder;
    link_to_releated_jobs?: SortOrder;
    link_to_releated_invoices?: SortOrder;
    belongs_to_id?: SortOrder;
  };

  export type RequestsSumOrderByAggregateInput = {
    id?: SortOrder;
    client_id?: SortOrder;
    assessment_id?: SortOrder;
    belongs_to_id?: SortOrder;
  };

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null;
  };

  export type LineItemQuoteListRelationFilter = {
    every?: LineItemQuoteWhereInput;
    some?: LineItemQuoteWhereInput;
    none?: LineItemQuoteWhereInput;
  };

  export type LineItemInvoiceListRelationFilter = {
    every?: LineItemInvoiceWhereInput;
    some?: LineItemInvoiceWhereInput;
    none?: LineItemInvoiceWhereInput;
  };

  export type LineItemJobListRelationFilter = {
    every?: LineItemJobWhereInput;
    some?: LineItemJobWhereInput;
    none?: LineItemJobWhereInput;
  };

  export type LineItemQuoteOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type LineItemInvoiceOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type LineItemJobOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type LineItemsCountOrderByAggregateInput = {
    id?: SortOrder;
    type?: SortOrder;
    name?: SortOrder;
    description?: SortOrder;
    quantity?: SortOrder;
    unit_price?: SortOrder;
    markup?: SortOrder;
    img_url?: SortOrder;
    recommend_item?: SortOrder;
  };

  export type LineItemsAvgOrderByAggregateInput = {
    id?: SortOrder;
    quantity?: SortOrder;
    unit_price?: SortOrder;
    markup?: SortOrder;
  };

  export type LineItemsMaxOrderByAggregateInput = {
    id?: SortOrder;
    type?: SortOrder;
    name?: SortOrder;
    description?: SortOrder;
    quantity?: SortOrder;
    unit_price?: SortOrder;
    markup?: SortOrder;
    img_url?: SortOrder;
    recommend_item?: SortOrder;
  };

  export type LineItemsMinOrderByAggregateInput = {
    id?: SortOrder;
    type?: SortOrder;
    name?: SortOrder;
    description?: SortOrder;
    quantity?: SortOrder;
    unit_price?: SortOrder;
    markup?: SortOrder;
    img_url?: SortOrder;
    recommend_item?: SortOrder;
  };

  export type LineItemsSumOrderByAggregateInput = {
    id?: SortOrder;
    quantity?: SortOrder;
    unit_price?: SortOrder;
    markup?: SortOrder;
  };

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _avg?: NestedFloatNullableFilter<$PrismaModel>;
    _sum?: NestedFloatNullableFilter<$PrismaModel>;
    _min?: NestedFloatNullableFilter<$PrismaModel>;
    _max?: NestedFloatNullableFilter<$PrismaModel>;
  };

  export type JobQuoteListRelationFilter = {
    every?: JobQuoteWhereInput;
    some?: JobQuoteWhereInput;
    none?: JobQuoteWhereInput;
  };

  export type JobQuoteOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type QuotesCountOrderByAggregateInput = {
    id?: SortOrder;
    tags?: SortOrder;
    emailed_to_client?: SortOrder;
    texted_to_client?: SortOrder;
    status?: SortOrder;
    title?: SortOrder;
    quote_number?: SortOrder;
    opportunity_rating?: SortOrder;
    client_id?: SortOrder;
    client_message?: SortOrder;
    discount?: SortOrder;
    discount_unit?: SortOrder;
    tax_id?: SortOrder;
    required_deposit?: SortOrder;
    link_to_releated_jobs?: SortOrder;
    link_to_releated_invoices?: SortOrder;
    belongs_to_id?: SortOrder;
  };

  export type QuotesAvgOrderByAggregateInput = {
    id?: SortOrder;
    client_id?: SortOrder;
    discount?: SortOrder;
    tax_id?: SortOrder;
    required_deposit?: SortOrder;
    belongs_to_id?: SortOrder;
  };

  export type QuotesMaxOrderByAggregateInput = {
    id?: SortOrder;
    emailed_to_client?: SortOrder;
    texted_to_client?: SortOrder;
    status?: SortOrder;
    title?: SortOrder;
    quote_number?: SortOrder;
    opportunity_rating?: SortOrder;
    client_id?: SortOrder;
    client_message?: SortOrder;
    discount?: SortOrder;
    discount_unit?: SortOrder;
    tax_id?: SortOrder;
    required_deposit?: SortOrder;
    link_to_releated_jobs?: SortOrder;
    link_to_releated_invoices?: SortOrder;
    belongs_to_id?: SortOrder;
  };

  export type QuotesMinOrderByAggregateInput = {
    id?: SortOrder;
    emailed_to_client?: SortOrder;
    texted_to_client?: SortOrder;
    status?: SortOrder;
    title?: SortOrder;
    quote_number?: SortOrder;
    opportunity_rating?: SortOrder;
    client_id?: SortOrder;
    client_message?: SortOrder;
    discount?: SortOrder;
    discount_unit?: SortOrder;
    tax_id?: SortOrder;
    required_deposit?: SortOrder;
    link_to_releated_jobs?: SortOrder;
    link_to_releated_invoices?: SortOrder;
    belongs_to_id?: SortOrder;
  };

  export type QuotesSumOrderByAggregateInput = {
    id?: SortOrder;
    client_id?: SortOrder;
    discount?: SortOrder;
    tax_id?: SortOrder;
    required_deposit?: SortOrder;
    belongs_to_id?: SortOrder;
  };

  export type QuotesRelationFilter = {
    is?: QuotesWhereInput;
    isNot?: QuotesWhereInput;
  };

  export type LineItemsRelationFilter = {
    is?: LineItemsWhereInput;
    isNot?: LineItemsWhereInput;
  };

  export type LineItemQuoteQuote_idLine_item_idCompoundUniqueInput = {
    quote_id: number;
    line_item_id: number;
  };

  export type LineItemQuoteCountOrderByAggregateInput = {
    id?: SortOrder;
    quote_id?: SortOrder;
    line_item_id?: SortOrder;
  };

  export type LineItemQuoteAvgOrderByAggregateInput = {
    id?: SortOrder;
    quote_id?: SortOrder;
    line_item_id?: SortOrder;
  };

  export type LineItemQuoteMaxOrderByAggregateInput = {
    id?: SortOrder;
    quote_id?: SortOrder;
    line_item_id?: SortOrder;
  };

  export type LineItemQuoteMinOrderByAggregateInput = {
    id?: SortOrder;
    quote_id?: SortOrder;
    line_item_id?: SortOrder;
  };

  export type LineItemQuoteSumOrderByAggregateInput = {
    id?: SortOrder;
    quote_id?: SortOrder;
    line_item_id?: SortOrder;
  };

  export type RequestsRelationFilter = {
    is?: RequestsWhereInput;
    isNot?: RequestsWhereInput;
  };

  export type QuoteRequestQuoteIdRequestIdCompoundUniqueInput = {
    quoteId: number;
    requestId: number;
  };

  export type QuoteRequestCountOrderByAggregateInput = {
    id?: SortOrder;
    quoteId?: SortOrder;
    requestId?: SortOrder;
  };

  export type QuoteRequestAvgOrderByAggregateInput = {
    id?: SortOrder;
    quoteId?: SortOrder;
    requestId?: SortOrder;
  };

  export type QuoteRequestMaxOrderByAggregateInput = {
    id?: SortOrder;
    quoteId?: SortOrder;
    requestId?: SortOrder;
  };

  export type QuoteRequestMinOrderByAggregateInput = {
    id?: SortOrder;
    quoteId?: SortOrder;
    requestId?: SortOrder;
  };

  export type QuoteRequestSumOrderByAggregateInput = {
    id?: SortOrder;
    quoteId?: SortOrder;
    requestId?: SortOrder;
  };

  export type JobsCountOrderByAggregateInput = {
    id?: SortOrder;
    tags?: SortOrder;
    emailed_to_client?: SortOrder;
    texted_to_client?: SortOrder;
    status?: SortOrder;
    client_id?: SortOrder;
    title?: SortOrder;
    instructions?: SortOrder;
    number?: SortOrder;
    schedule_type?: SortOrder;
    recurring_frequency?: SortOrder;
    recurring_interval?: SortOrder;
    day_of_week?: SortOrder;
    day_of_year?: SortOrder;
    duration?: SortOrder;
    start_date?: SortOrder;
    end_date?: SortOrder;
    start_time?: SortOrder;
    end_time?: SortOrder;
    schedule_later?: SortOrder;
    team?: SortOrder;
    email_team?: SortOrder;
    invoice_reminder?: SortOrder;
    internal_notes?: SortOrder;
    internal_attachment_url?: SortOrder;
    link_to_related_invoices?: SortOrder;
    belongs_to_id?: SortOrder;
  };

  export type JobsAvgOrderByAggregateInput = {
    id?: SortOrder;
    client_id?: SortOrder;
    belongs_to_id?: SortOrder;
  };

  export type JobsMaxOrderByAggregateInput = {
    id?: SortOrder;
    emailed_to_client?: SortOrder;
    texted_to_client?: SortOrder;
    status?: SortOrder;
    client_id?: SortOrder;
    title?: SortOrder;
    instructions?: SortOrder;
    number?: SortOrder;
    schedule_type?: SortOrder;
    recurring_frequency?: SortOrder;
    recurring_interval?: SortOrder;
    day_of_week?: SortOrder;
    day_of_year?: SortOrder;
    duration?: SortOrder;
    start_date?: SortOrder;
    end_date?: SortOrder;
    start_time?: SortOrder;
    end_time?: SortOrder;
    schedule_later?: SortOrder;
    team?: SortOrder;
    email_team?: SortOrder;
    invoice_reminder?: SortOrder;
    internal_notes?: SortOrder;
    internal_attachment_url?: SortOrder;
    link_to_related_invoices?: SortOrder;
    belongs_to_id?: SortOrder;
  };

  export type JobsMinOrderByAggregateInput = {
    id?: SortOrder;
    emailed_to_client?: SortOrder;
    texted_to_client?: SortOrder;
    status?: SortOrder;
    client_id?: SortOrder;
    title?: SortOrder;
    instructions?: SortOrder;
    number?: SortOrder;
    schedule_type?: SortOrder;
    recurring_frequency?: SortOrder;
    recurring_interval?: SortOrder;
    day_of_week?: SortOrder;
    day_of_year?: SortOrder;
    duration?: SortOrder;
    start_date?: SortOrder;
    end_date?: SortOrder;
    start_time?: SortOrder;
    end_time?: SortOrder;
    schedule_later?: SortOrder;
    team?: SortOrder;
    email_team?: SortOrder;
    invoice_reminder?: SortOrder;
    internal_notes?: SortOrder;
    internal_attachment_url?: SortOrder;
    link_to_related_invoices?: SortOrder;
    belongs_to_id?: SortOrder;
  };

  export type JobsSumOrderByAggregateInput = {
    id?: SortOrder;
    client_id?: SortOrder;
    belongs_to_id?: SortOrder;
  };

  export type JobsRelationFilter = {
    is?: JobsWhereInput;
    isNot?: JobsWhereInput;
  };

  export type LineItemJobJob_idLine_item_idCompoundUniqueInput = {
    job_id: number;
    line_item_id: number;
  };

  export type LineItemJobCountOrderByAggregateInput = {
    id?: SortOrder;
    job_id?: SortOrder;
    line_item_id?: SortOrder;
  };

  export type LineItemJobAvgOrderByAggregateInput = {
    id?: SortOrder;
    job_id?: SortOrder;
    line_item_id?: SortOrder;
  };

  export type LineItemJobMaxOrderByAggregateInput = {
    id?: SortOrder;
    job_id?: SortOrder;
    line_item_id?: SortOrder;
  };

  export type LineItemJobMinOrderByAggregateInput = {
    id?: SortOrder;
    job_id?: SortOrder;
    line_item_id?: SortOrder;
  };

  export type LineItemJobSumOrderByAggregateInput = {
    id?: SortOrder;
    job_id?: SortOrder;
    line_item_id?: SortOrder;
  };

  export type JobRequestJob_idRequest_idCompoundUniqueInput = {
    job_id: number;
    request_id: number;
  };

  export type JobRequestCountOrderByAggregateInput = {
    id?: SortOrder;
    job_id?: SortOrder;
    request_id?: SortOrder;
  };

  export type JobRequestAvgOrderByAggregateInput = {
    id?: SortOrder;
    job_id?: SortOrder;
    request_id?: SortOrder;
  };

  export type JobRequestMaxOrderByAggregateInput = {
    id?: SortOrder;
    job_id?: SortOrder;
    request_id?: SortOrder;
  };

  export type JobRequestMinOrderByAggregateInput = {
    id?: SortOrder;
    job_id?: SortOrder;
    request_id?: SortOrder;
  };

  export type JobRequestSumOrderByAggregateInput = {
    id?: SortOrder;
    job_id?: SortOrder;
    request_id?: SortOrder;
  };

  export type JobQuoteJob_idQuote_idCompoundUniqueInput = {
    job_id: number;
    quote_id: number;
  };

  export type JobQuoteCountOrderByAggregateInput = {
    id?: SortOrder;
    job_id?: SortOrder;
    quote_id?: SortOrder;
  };

  export type JobQuoteAvgOrderByAggregateInput = {
    id?: SortOrder;
    job_id?: SortOrder;
    quote_id?: SortOrder;
  };

  export type JobQuoteMaxOrderByAggregateInput = {
    id?: SortOrder;
    job_id?: SortOrder;
    quote_id?: SortOrder;
  };

  export type JobQuoteMinOrderByAggregateInput = {
    id?: SortOrder;
    job_id?: SortOrder;
    quote_id?: SortOrder;
  };

  export type JobQuoteSumOrderByAggregateInput = {
    id?: SortOrder;
    job_id?: SortOrder;
    quote_id?: SortOrder;
  };

  export type JobsNullableRelationFilter = {
    is?: JobsWhereInput | null;
    isNot?: JobsWhereInput | null;
  };

  export type InvoicesCountOrderByAggregateInput = {
    id?: SortOrder;
    tags?: SortOrder;
    emailed_to_client?: SortOrder;
    texted_to_client?: SortOrder;
    issued_date?: SortOrder;
    due_date?: SortOrder;
    status?: SortOrder;
    type?: SortOrder;
    subject?: SortOrder;
    client_id?: SortOrder;
    job_id?: SortOrder;
    tax_id?: SortOrder;
    client_message?: SortOrder;
    internal_notes?: SortOrder;
    internalAttachmentUrl?: SortOrder;
    belongs_to_id?: SortOrder;
  };

  export type InvoicesAvgOrderByAggregateInput = {
    id?: SortOrder;
    client_id?: SortOrder;
    job_id?: SortOrder;
    tax_id?: SortOrder;
    belongs_to_id?: SortOrder;
  };

  export type InvoicesMaxOrderByAggregateInput = {
    id?: SortOrder;
    emailed_to_client?: SortOrder;
    texted_to_client?: SortOrder;
    issued_date?: SortOrder;
    due_date?: SortOrder;
    status?: SortOrder;
    type?: SortOrder;
    subject?: SortOrder;
    client_id?: SortOrder;
    job_id?: SortOrder;
    tax_id?: SortOrder;
    client_message?: SortOrder;
    internal_notes?: SortOrder;
    internalAttachmentUrl?: SortOrder;
    belongs_to_id?: SortOrder;
  };

  export type InvoicesMinOrderByAggregateInput = {
    id?: SortOrder;
    emailed_to_client?: SortOrder;
    texted_to_client?: SortOrder;
    issued_date?: SortOrder;
    due_date?: SortOrder;
    status?: SortOrder;
    type?: SortOrder;
    subject?: SortOrder;
    client_id?: SortOrder;
    job_id?: SortOrder;
    tax_id?: SortOrder;
    client_message?: SortOrder;
    internal_notes?: SortOrder;
    internalAttachmentUrl?: SortOrder;
    belongs_to_id?: SortOrder;
  };

  export type InvoicesSumOrderByAggregateInput = {
    id?: SortOrder;
    client_id?: SortOrder;
    job_id?: SortOrder;
    tax_id?: SortOrder;
    belongs_to_id?: SortOrder;
  };

  export type InvoicesRelationFilter = {
    is?: InvoicesWhereInput;
    isNot?: InvoicesWhereInput;
  };

  export type LineItemInvoiceInvoice_idLine_item_idCompoundUniqueInput = {
    invoice_id: number;
    line_item_id: number;
  };

  export type LineItemInvoiceCountOrderByAggregateInput = {
    id?: SortOrder;
    invoice_id?: SortOrder;
    line_item_id?: SortOrder;
  };

  export type LineItemInvoiceAvgOrderByAggregateInput = {
    id?: SortOrder;
    invoice_id?: SortOrder;
    line_item_id?: SortOrder;
  };

  export type LineItemInvoiceMaxOrderByAggregateInput = {
    id?: SortOrder;
    invoice_id?: SortOrder;
    line_item_id?: SortOrder;
  };

  export type LineItemInvoiceMinOrderByAggregateInput = {
    id?: SortOrder;
    invoice_id?: SortOrder;
    line_item_id?: SortOrder;
  };

  export type LineItemInvoiceSumOrderByAggregateInput = {
    id?: SortOrder;
    invoice_id?: SortOrder;
    line_item_id?: SortOrder;
  };

  export type UsersCreateNestedManyWithoutDefault_taxInput = {
    create?:
      | XOR<
          UsersCreateWithoutDefault_taxInput,
          UsersUncheckedCreateWithoutDefault_taxInput
        >
      | UsersCreateWithoutDefault_taxInput[]
      | UsersUncheckedCreateWithoutDefault_taxInput[];
    connectOrCreate?:
      | UsersCreateOrConnectWithoutDefault_taxInput
      | UsersCreateOrConnectWithoutDefault_taxInput[];
    createMany?: UsersCreateManyDefault_taxInputEnvelope;
    connect?: UsersWhereUniqueInput | UsersWhereUniqueInput[];
  };

  export type QuotesCreateNestedManyWithoutTaxInput = {
    create?:
      | XOR<QuotesCreateWithoutTaxInput, QuotesUncheckedCreateWithoutTaxInput>
      | QuotesCreateWithoutTaxInput[]
      | QuotesUncheckedCreateWithoutTaxInput[];
    connectOrCreate?:
      | QuotesCreateOrConnectWithoutTaxInput
      | QuotesCreateOrConnectWithoutTaxInput[];
    createMany?: QuotesCreateManyTaxInputEnvelope;
    connect?: QuotesWhereUniqueInput | QuotesWhereUniqueInput[];
  };

  export type InvoicesCreateNestedManyWithoutTaxInput = {
    create?:
      | XOR<
          InvoicesCreateWithoutTaxInput,
          InvoicesUncheckedCreateWithoutTaxInput
        >
      | InvoicesCreateWithoutTaxInput[]
      | InvoicesUncheckedCreateWithoutTaxInput[];
    connectOrCreate?:
      | InvoicesCreateOrConnectWithoutTaxInput
      | InvoicesCreateOrConnectWithoutTaxInput[];
    createMany?: InvoicesCreateManyTaxInputEnvelope;
    connect?: InvoicesWhereUniqueInput | InvoicesWhereUniqueInput[];
  };

  export type UsersUncheckedCreateNestedManyWithoutDefault_taxInput = {
    create?:
      | XOR<
          UsersCreateWithoutDefault_taxInput,
          UsersUncheckedCreateWithoutDefault_taxInput
        >
      | UsersCreateWithoutDefault_taxInput[]
      | UsersUncheckedCreateWithoutDefault_taxInput[];
    connectOrCreate?:
      | UsersCreateOrConnectWithoutDefault_taxInput
      | UsersCreateOrConnectWithoutDefault_taxInput[];
    createMany?: UsersCreateManyDefault_taxInputEnvelope;
    connect?: UsersWhereUniqueInput | UsersWhereUniqueInput[];
  };

  export type QuotesUncheckedCreateNestedManyWithoutTaxInput = {
    create?:
      | XOR<QuotesCreateWithoutTaxInput, QuotesUncheckedCreateWithoutTaxInput>
      | QuotesCreateWithoutTaxInput[]
      | QuotesUncheckedCreateWithoutTaxInput[];
    connectOrCreate?:
      | QuotesCreateOrConnectWithoutTaxInput
      | QuotesCreateOrConnectWithoutTaxInput[];
    createMany?: QuotesCreateManyTaxInputEnvelope;
    connect?: QuotesWhereUniqueInput | QuotesWhereUniqueInput[];
  };

  export type InvoicesUncheckedCreateNestedManyWithoutTaxInput = {
    create?:
      | XOR<
          InvoicesCreateWithoutTaxInput,
          InvoicesUncheckedCreateWithoutTaxInput
        >
      | InvoicesCreateWithoutTaxInput[]
      | InvoicesUncheckedCreateWithoutTaxInput[];
    connectOrCreate?:
      | InvoicesCreateOrConnectWithoutTaxInput
      | InvoicesCreateOrConnectWithoutTaxInput[];
    createMany?: InvoicesCreateManyTaxInputEnvelope;
    connect?: InvoicesWhereUniqueInput | InvoicesWhereUniqueInput[];
  };

  export type StringFieldUpdateOperationsInput = {
    set?: string;
  };

  export type FloatFieldUpdateOperationsInput = {
    set?: number;
    increment?: number;
    decrement?: number;
    multiply?: number;
    divide?: number;
  };

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null;
  };

  export type UsersUpdateManyWithoutDefault_taxNestedInput = {
    create?:
      | XOR<
          UsersCreateWithoutDefault_taxInput,
          UsersUncheckedCreateWithoutDefault_taxInput
        >
      | UsersCreateWithoutDefault_taxInput[]
      | UsersUncheckedCreateWithoutDefault_taxInput[];
    connectOrCreate?:
      | UsersCreateOrConnectWithoutDefault_taxInput
      | UsersCreateOrConnectWithoutDefault_taxInput[];
    upsert?:
      | UsersUpsertWithWhereUniqueWithoutDefault_taxInput
      | UsersUpsertWithWhereUniqueWithoutDefault_taxInput[];
    createMany?: UsersCreateManyDefault_taxInputEnvelope;
    set?: UsersWhereUniqueInput | UsersWhereUniqueInput[];
    disconnect?: UsersWhereUniqueInput | UsersWhereUniqueInput[];
    delete?: UsersWhereUniqueInput | UsersWhereUniqueInput[];
    connect?: UsersWhereUniqueInput | UsersWhereUniqueInput[];
    update?:
      | UsersUpdateWithWhereUniqueWithoutDefault_taxInput
      | UsersUpdateWithWhereUniqueWithoutDefault_taxInput[];
    updateMany?:
      | UsersUpdateManyWithWhereWithoutDefault_taxInput
      | UsersUpdateManyWithWhereWithoutDefault_taxInput[];
    deleteMany?: UsersScalarWhereInput | UsersScalarWhereInput[];
  };

  export type QuotesUpdateManyWithoutTaxNestedInput = {
    create?:
      | XOR<QuotesCreateWithoutTaxInput, QuotesUncheckedCreateWithoutTaxInput>
      | QuotesCreateWithoutTaxInput[]
      | QuotesUncheckedCreateWithoutTaxInput[];
    connectOrCreate?:
      | QuotesCreateOrConnectWithoutTaxInput
      | QuotesCreateOrConnectWithoutTaxInput[];
    upsert?:
      | QuotesUpsertWithWhereUniqueWithoutTaxInput
      | QuotesUpsertWithWhereUniqueWithoutTaxInput[];
    createMany?: QuotesCreateManyTaxInputEnvelope;
    set?: QuotesWhereUniqueInput | QuotesWhereUniqueInput[];
    disconnect?: QuotesWhereUniqueInput | QuotesWhereUniqueInput[];
    delete?: QuotesWhereUniqueInput | QuotesWhereUniqueInput[];
    connect?: QuotesWhereUniqueInput | QuotesWhereUniqueInput[];
    update?:
      | QuotesUpdateWithWhereUniqueWithoutTaxInput
      | QuotesUpdateWithWhereUniqueWithoutTaxInput[];
    updateMany?:
      | QuotesUpdateManyWithWhereWithoutTaxInput
      | QuotesUpdateManyWithWhereWithoutTaxInput[];
    deleteMany?: QuotesScalarWhereInput | QuotesScalarWhereInput[];
  };

  export type InvoicesUpdateManyWithoutTaxNestedInput = {
    create?:
      | XOR<
          InvoicesCreateWithoutTaxInput,
          InvoicesUncheckedCreateWithoutTaxInput
        >
      | InvoicesCreateWithoutTaxInput[]
      | InvoicesUncheckedCreateWithoutTaxInput[];
    connectOrCreate?:
      | InvoicesCreateOrConnectWithoutTaxInput
      | InvoicesCreateOrConnectWithoutTaxInput[];
    upsert?:
      | InvoicesUpsertWithWhereUniqueWithoutTaxInput
      | InvoicesUpsertWithWhereUniqueWithoutTaxInput[];
    createMany?: InvoicesCreateManyTaxInputEnvelope;
    set?: InvoicesWhereUniqueInput | InvoicesWhereUniqueInput[];
    disconnect?: InvoicesWhereUniqueInput | InvoicesWhereUniqueInput[];
    delete?: InvoicesWhereUniqueInput | InvoicesWhereUniqueInput[];
    connect?: InvoicesWhereUniqueInput | InvoicesWhereUniqueInput[];
    update?:
      | InvoicesUpdateWithWhereUniqueWithoutTaxInput
      | InvoicesUpdateWithWhereUniqueWithoutTaxInput[];
    updateMany?:
      | InvoicesUpdateManyWithWhereWithoutTaxInput
      | InvoicesUpdateManyWithWhereWithoutTaxInput[];
    deleteMany?: InvoicesScalarWhereInput | InvoicesScalarWhereInput[];
  };

  export type IntFieldUpdateOperationsInput = {
    set?: number;
    increment?: number;
    decrement?: number;
    multiply?: number;
    divide?: number;
  };

  export type UsersUncheckedUpdateManyWithoutDefault_taxNestedInput = {
    create?:
      | XOR<
          UsersCreateWithoutDefault_taxInput,
          UsersUncheckedCreateWithoutDefault_taxInput
        >
      | UsersCreateWithoutDefault_taxInput[]
      | UsersUncheckedCreateWithoutDefault_taxInput[];
    connectOrCreate?:
      | UsersCreateOrConnectWithoutDefault_taxInput
      | UsersCreateOrConnectWithoutDefault_taxInput[];
    upsert?:
      | UsersUpsertWithWhereUniqueWithoutDefault_taxInput
      | UsersUpsertWithWhereUniqueWithoutDefault_taxInput[];
    createMany?: UsersCreateManyDefault_taxInputEnvelope;
    set?: UsersWhereUniqueInput | UsersWhereUniqueInput[];
    disconnect?: UsersWhereUniqueInput | UsersWhereUniqueInput[];
    delete?: UsersWhereUniqueInput | UsersWhereUniqueInput[];
    connect?: UsersWhereUniqueInput | UsersWhereUniqueInput[];
    update?:
      | UsersUpdateWithWhereUniqueWithoutDefault_taxInput
      | UsersUpdateWithWhereUniqueWithoutDefault_taxInput[];
    updateMany?:
      | UsersUpdateManyWithWhereWithoutDefault_taxInput
      | UsersUpdateManyWithWhereWithoutDefault_taxInput[];
    deleteMany?: UsersScalarWhereInput | UsersScalarWhereInput[];
  };

  export type QuotesUncheckedUpdateManyWithoutTaxNestedInput = {
    create?:
      | XOR<QuotesCreateWithoutTaxInput, QuotesUncheckedCreateWithoutTaxInput>
      | QuotesCreateWithoutTaxInput[]
      | QuotesUncheckedCreateWithoutTaxInput[];
    connectOrCreate?:
      | QuotesCreateOrConnectWithoutTaxInput
      | QuotesCreateOrConnectWithoutTaxInput[];
    upsert?:
      | QuotesUpsertWithWhereUniqueWithoutTaxInput
      | QuotesUpsertWithWhereUniqueWithoutTaxInput[];
    createMany?: QuotesCreateManyTaxInputEnvelope;
    set?: QuotesWhereUniqueInput | QuotesWhereUniqueInput[];
    disconnect?: QuotesWhereUniqueInput | QuotesWhereUniqueInput[];
    delete?: QuotesWhereUniqueInput | QuotesWhereUniqueInput[];
    connect?: QuotesWhereUniqueInput | QuotesWhereUniqueInput[];
    update?:
      | QuotesUpdateWithWhereUniqueWithoutTaxInput
      | QuotesUpdateWithWhereUniqueWithoutTaxInput[];
    updateMany?:
      | QuotesUpdateManyWithWhereWithoutTaxInput
      | QuotesUpdateManyWithWhereWithoutTaxInput[];
    deleteMany?: QuotesScalarWhereInput | QuotesScalarWhereInput[];
  };

  export type InvoicesUncheckedUpdateManyWithoutTaxNestedInput = {
    create?:
      | XOR<
          InvoicesCreateWithoutTaxInput,
          InvoicesUncheckedCreateWithoutTaxInput
        >
      | InvoicesCreateWithoutTaxInput[]
      | InvoicesUncheckedCreateWithoutTaxInput[];
    connectOrCreate?:
      | InvoicesCreateOrConnectWithoutTaxInput
      | InvoicesCreateOrConnectWithoutTaxInput[];
    upsert?:
      | InvoicesUpsertWithWhereUniqueWithoutTaxInput
      | InvoicesUpsertWithWhereUniqueWithoutTaxInput[];
    createMany?: InvoicesCreateManyTaxInputEnvelope;
    set?: InvoicesWhereUniqueInput | InvoicesWhereUniqueInput[];
    disconnect?: InvoicesWhereUniqueInput | InvoicesWhereUniqueInput[];
    delete?: InvoicesWhereUniqueInput | InvoicesWhereUniqueInput[];
    connect?: InvoicesWhereUniqueInput | InvoicesWhereUniqueInput[];
    update?:
      | InvoicesUpdateWithWhereUniqueWithoutTaxInput
      | InvoicesUpdateWithWhereUniqueWithoutTaxInput[];
    updateMany?:
      | InvoicesUpdateManyWithWhereWithoutTaxInput
      | InvoicesUpdateManyWithWhereWithoutTaxInput[];
    deleteMany?: InvoicesScalarWhereInput | InvoicesScalarWhereInput[];
  };

  export type UsersCreateNestedManyWithoutAddressInput = {
    create?:
      | XOR<
          UsersCreateWithoutAddressInput,
          UsersUncheckedCreateWithoutAddressInput
        >
      | UsersCreateWithoutAddressInput[]
      | UsersUncheckedCreateWithoutAddressInput[];
    connectOrCreate?:
      | UsersCreateOrConnectWithoutAddressInput
      | UsersCreateOrConnectWithoutAddressInput[];
    createMany?: UsersCreateManyAddressInputEnvelope;
    connect?: UsersWhereUniqueInput | UsersWhereUniqueInput[];
  };

  export type ClientsCreateNestedManyWithoutProperty_addressInput = {
    create?:
      | XOR<
          ClientsCreateWithoutProperty_addressInput,
          ClientsUncheckedCreateWithoutProperty_addressInput
        >
      | ClientsCreateWithoutProperty_addressInput[]
      | ClientsUncheckedCreateWithoutProperty_addressInput[];
    connectOrCreate?:
      | ClientsCreateOrConnectWithoutProperty_addressInput
      | ClientsCreateOrConnectWithoutProperty_addressInput[];
    createMany?: ClientsCreateManyProperty_addressInputEnvelope;
    connect?: ClientsWhereUniqueInput | ClientsWhereUniqueInput[];
  };

  export type ClientsCreateNestedManyWithoutBilling_addressInput = {
    create?:
      | XOR<
          ClientsCreateWithoutBilling_addressInput,
          ClientsUncheckedCreateWithoutBilling_addressInput
        >
      | ClientsCreateWithoutBilling_addressInput[]
      | ClientsUncheckedCreateWithoutBilling_addressInput[];
    connectOrCreate?:
      | ClientsCreateOrConnectWithoutBilling_addressInput
      | ClientsCreateOrConnectWithoutBilling_addressInput[];
    createMany?: ClientsCreateManyBilling_addressInputEnvelope;
    connect?: ClientsWhereUniqueInput | ClientsWhereUniqueInput[];
  };

  export type UsersUncheckedCreateNestedManyWithoutAddressInput = {
    create?:
      | XOR<
          UsersCreateWithoutAddressInput,
          UsersUncheckedCreateWithoutAddressInput
        >
      | UsersCreateWithoutAddressInput[]
      | UsersUncheckedCreateWithoutAddressInput[];
    connectOrCreate?:
      | UsersCreateOrConnectWithoutAddressInput
      | UsersCreateOrConnectWithoutAddressInput[];
    createMany?: UsersCreateManyAddressInputEnvelope;
    connect?: UsersWhereUniqueInput | UsersWhereUniqueInput[];
  };

  export type ClientsUncheckedCreateNestedManyWithoutProperty_addressInput = {
    create?:
      | XOR<
          ClientsCreateWithoutProperty_addressInput,
          ClientsUncheckedCreateWithoutProperty_addressInput
        >
      | ClientsCreateWithoutProperty_addressInput[]
      | ClientsUncheckedCreateWithoutProperty_addressInput[];
    connectOrCreate?:
      | ClientsCreateOrConnectWithoutProperty_addressInput
      | ClientsCreateOrConnectWithoutProperty_addressInput[];
    createMany?: ClientsCreateManyProperty_addressInputEnvelope;
    connect?: ClientsWhereUniqueInput | ClientsWhereUniqueInput[];
  };

  export type ClientsUncheckedCreateNestedManyWithoutBilling_addressInput = {
    create?:
      | XOR<
          ClientsCreateWithoutBilling_addressInput,
          ClientsUncheckedCreateWithoutBilling_addressInput
        >
      | ClientsCreateWithoutBilling_addressInput[]
      | ClientsUncheckedCreateWithoutBilling_addressInput[];
    connectOrCreate?:
      | ClientsCreateOrConnectWithoutBilling_addressInput
      | ClientsCreateOrConnectWithoutBilling_addressInput[];
    createMany?: ClientsCreateManyBilling_addressInputEnvelope;
    connect?: ClientsWhereUniqueInput | ClientsWhereUniqueInput[];
  };

  export type UsersUpdateManyWithoutAddressNestedInput = {
    create?:
      | XOR<
          UsersCreateWithoutAddressInput,
          UsersUncheckedCreateWithoutAddressInput
        >
      | UsersCreateWithoutAddressInput[]
      | UsersUncheckedCreateWithoutAddressInput[];
    connectOrCreate?:
      | UsersCreateOrConnectWithoutAddressInput
      | UsersCreateOrConnectWithoutAddressInput[];
    upsert?:
      | UsersUpsertWithWhereUniqueWithoutAddressInput
      | UsersUpsertWithWhereUniqueWithoutAddressInput[];
    createMany?: UsersCreateManyAddressInputEnvelope;
    set?: UsersWhereUniqueInput | UsersWhereUniqueInput[];
    disconnect?: UsersWhereUniqueInput | UsersWhereUniqueInput[];
    delete?: UsersWhereUniqueInput | UsersWhereUniqueInput[];
    connect?: UsersWhereUniqueInput | UsersWhereUniqueInput[];
    update?:
      | UsersUpdateWithWhereUniqueWithoutAddressInput
      | UsersUpdateWithWhereUniqueWithoutAddressInput[];
    updateMany?:
      | UsersUpdateManyWithWhereWithoutAddressInput
      | UsersUpdateManyWithWhereWithoutAddressInput[];
    deleteMany?: UsersScalarWhereInput | UsersScalarWhereInput[];
  };

  export type ClientsUpdateManyWithoutProperty_addressNestedInput = {
    create?:
      | XOR<
          ClientsCreateWithoutProperty_addressInput,
          ClientsUncheckedCreateWithoutProperty_addressInput
        >
      | ClientsCreateWithoutProperty_addressInput[]
      | ClientsUncheckedCreateWithoutProperty_addressInput[];
    connectOrCreate?:
      | ClientsCreateOrConnectWithoutProperty_addressInput
      | ClientsCreateOrConnectWithoutProperty_addressInput[];
    upsert?:
      | ClientsUpsertWithWhereUniqueWithoutProperty_addressInput
      | ClientsUpsertWithWhereUniqueWithoutProperty_addressInput[];
    createMany?: ClientsCreateManyProperty_addressInputEnvelope;
    set?: ClientsWhereUniqueInput | ClientsWhereUniqueInput[];
    disconnect?: ClientsWhereUniqueInput | ClientsWhereUniqueInput[];
    delete?: ClientsWhereUniqueInput | ClientsWhereUniqueInput[];
    connect?: ClientsWhereUniqueInput | ClientsWhereUniqueInput[];
    update?:
      | ClientsUpdateWithWhereUniqueWithoutProperty_addressInput
      | ClientsUpdateWithWhereUniqueWithoutProperty_addressInput[];
    updateMany?:
      | ClientsUpdateManyWithWhereWithoutProperty_addressInput
      | ClientsUpdateManyWithWhereWithoutProperty_addressInput[];
    deleteMany?: ClientsScalarWhereInput | ClientsScalarWhereInput[];
  };

  export type ClientsUpdateManyWithoutBilling_addressNestedInput = {
    create?:
      | XOR<
          ClientsCreateWithoutBilling_addressInput,
          ClientsUncheckedCreateWithoutBilling_addressInput
        >
      | ClientsCreateWithoutBilling_addressInput[]
      | ClientsUncheckedCreateWithoutBilling_addressInput[];
    connectOrCreate?:
      | ClientsCreateOrConnectWithoutBilling_addressInput
      | ClientsCreateOrConnectWithoutBilling_addressInput[];
    upsert?:
      | ClientsUpsertWithWhereUniqueWithoutBilling_addressInput
      | ClientsUpsertWithWhereUniqueWithoutBilling_addressInput[];
    createMany?: ClientsCreateManyBilling_addressInputEnvelope;
    set?: ClientsWhereUniqueInput | ClientsWhereUniqueInput[];
    disconnect?: ClientsWhereUniqueInput | ClientsWhereUniqueInput[];
    delete?: ClientsWhereUniqueInput | ClientsWhereUniqueInput[];
    connect?: ClientsWhereUniqueInput | ClientsWhereUniqueInput[];
    update?:
      | ClientsUpdateWithWhereUniqueWithoutBilling_addressInput
      | ClientsUpdateWithWhereUniqueWithoutBilling_addressInput[];
    updateMany?:
      | ClientsUpdateManyWithWhereWithoutBilling_addressInput
      | ClientsUpdateManyWithWhereWithoutBilling_addressInput[];
    deleteMany?: ClientsScalarWhereInput | ClientsScalarWhereInput[];
  };

  export type UsersUncheckedUpdateManyWithoutAddressNestedInput = {
    create?:
      | XOR<
          UsersCreateWithoutAddressInput,
          UsersUncheckedCreateWithoutAddressInput
        >
      | UsersCreateWithoutAddressInput[]
      | UsersUncheckedCreateWithoutAddressInput[];
    connectOrCreate?:
      | UsersCreateOrConnectWithoutAddressInput
      | UsersCreateOrConnectWithoutAddressInput[];
    upsert?:
      | UsersUpsertWithWhereUniqueWithoutAddressInput
      | UsersUpsertWithWhereUniqueWithoutAddressInput[];
    createMany?: UsersCreateManyAddressInputEnvelope;
    set?: UsersWhereUniqueInput | UsersWhereUniqueInput[];
    disconnect?: UsersWhereUniqueInput | UsersWhereUniqueInput[];
    delete?: UsersWhereUniqueInput | UsersWhereUniqueInput[];
    connect?: UsersWhereUniqueInput | UsersWhereUniqueInput[];
    update?:
      | UsersUpdateWithWhereUniqueWithoutAddressInput
      | UsersUpdateWithWhereUniqueWithoutAddressInput[];
    updateMany?:
      | UsersUpdateManyWithWhereWithoutAddressInput
      | UsersUpdateManyWithWhereWithoutAddressInput[];
    deleteMany?: UsersScalarWhereInput | UsersScalarWhereInput[];
  };

  export type ClientsUncheckedUpdateManyWithoutProperty_addressNestedInput = {
    create?:
      | XOR<
          ClientsCreateWithoutProperty_addressInput,
          ClientsUncheckedCreateWithoutProperty_addressInput
        >
      | ClientsCreateWithoutProperty_addressInput[]
      | ClientsUncheckedCreateWithoutProperty_addressInput[];
    connectOrCreate?:
      | ClientsCreateOrConnectWithoutProperty_addressInput
      | ClientsCreateOrConnectWithoutProperty_addressInput[];
    upsert?:
      | ClientsUpsertWithWhereUniqueWithoutProperty_addressInput
      | ClientsUpsertWithWhereUniqueWithoutProperty_addressInput[];
    createMany?: ClientsCreateManyProperty_addressInputEnvelope;
    set?: ClientsWhereUniqueInput | ClientsWhereUniqueInput[];
    disconnect?: ClientsWhereUniqueInput | ClientsWhereUniqueInput[];
    delete?: ClientsWhereUniqueInput | ClientsWhereUniqueInput[];
    connect?: ClientsWhereUniqueInput | ClientsWhereUniqueInput[];
    update?:
      | ClientsUpdateWithWhereUniqueWithoutProperty_addressInput
      | ClientsUpdateWithWhereUniqueWithoutProperty_addressInput[];
    updateMany?:
      | ClientsUpdateManyWithWhereWithoutProperty_addressInput
      | ClientsUpdateManyWithWhereWithoutProperty_addressInput[];
    deleteMany?: ClientsScalarWhereInput | ClientsScalarWhereInput[];
  };

  export type ClientsUncheckedUpdateManyWithoutBilling_addressNestedInput = {
    create?:
      | XOR<
          ClientsCreateWithoutBilling_addressInput,
          ClientsUncheckedCreateWithoutBilling_addressInput
        >
      | ClientsCreateWithoutBilling_addressInput[]
      | ClientsUncheckedCreateWithoutBilling_addressInput[];
    connectOrCreate?:
      | ClientsCreateOrConnectWithoutBilling_addressInput
      | ClientsCreateOrConnectWithoutBilling_addressInput[];
    upsert?:
      | ClientsUpsertWithWhereUniqueWithoutBilling_addressInput
      | ClientsUpsertWithWhereUniqueWithoutBilling_addressInput[];
    createMany?: ClientsCreateManyBilling_addressInputEnvelope;
    set?: ClientsWhereUniqueInput | ClientsWhereUniqueInput[];
    disconnect?: ClientsWhereUniqueInput | ClientsWhereUniqueInput[];
    delete?: ClientsWhereUniqueInput | ClientsWhereUniqueInput[];
    connect?: ClientsWhereUniqueInput | ClientsWhereUniqueInput[];
    update?:
      | ClientsUpdateWithWhereUniqueWithoutBilling_addressInput
      | ClientsUpdateWithWhereUniqueWithoutBilling_addressInput[];
    updateMany?:
      | ClientsUpdateManyWithWhereWithoutBilling_addressInput
      | ClientsUpdateManyWithWhereWithoutBilling_addressInput[];
    deleteMany?: ClientsScalarWhereInput | ClientsScalarWhereInput[];
  };

  export type TaxesCreateNestedOneWithoutUsersInput = {
    create?: XOR<
      TaxesCreateWithoutUsersInput,
      TaxesUncheckedCreateWithoutUsersInput
    >;
    connectOrCreate?: TaxesCreateOrConnectWithoutUsersInput;
    connect?: TaxesWhereUniqueInput;
  };

  export type AddressesCreateNestedOneWithoutUsersInput = {
    create?: XOR<
      AddressesCreateWithoutUsersInput,
      AddressesUncheckedCreateWithoutUsersInput
    >;
    connectOrCreate?: AddressesCreateOrConnectWithoutUsersInput;
    connect?: AddressesWhereUniqueInput;
  };

  export type ClientsCreateNestedManyWithoutBelongs_toInput = {
    create?:
      | XOR<
          ClientsCreateWithoutBelongs_toInput,
          ClientsUncheckedCreateWithoutBelongs_toInput
        >
      | ClientsCreateWithoutBelongs_toInput[]
      | ClientsUncheckedCreateWithoutBelongs_toInput[];
    connectOrCreate?:
      | ClientsCreateOrConnectWithoutBelongs_toInput
      | ClientsCreateOrConnectWithoutBelongs_toInput[];
    createMany?: ClientsCreateManyBelongs_toInputEnvelope;
    connect?: ClientsWhereUniqueInput | ClientsWhereUniqueInput[];
  };

  export type RequestsCreateNestedManyWithoutBelongs_toInput = {
    create?:
      | XOR<
          RequestsCreateWithoutBelongs_toInput,
          RequestsUncheckedCreateWithoutBelongs_toInput
        >
      | RequestsCreateWithoutBelongs_toInput[]
      | RequestsUncheckedCreateWithoutBelongs_toInput[];
    connectOrCreate?:
      | RequestsCreateOrConnectWithoutBelongs_toInput
      | RequestsCreateOrConnectWithoutBelongs_toInput[];
    createMany?: RequestsCreateManyBelongs_toInputEnvelope;
    connect?: RequestsWhereUniqueInput | RequestsWhereUniqueInput[];
  };

  export type JobsCreateNestedManyWithoutBelongs_toInput = {
    create?:
      | XOR<
          JobsCreateWithoutBelongs_toInput,
          JobsUncheckedCreateWithoutBelongs_toInput
        >
      | JobsCreateWithoutBelongs_toInput[]
      | JobsUncheckedCreateWithoutBelongs_toInput[];
    connectOrCreate?:
      | JobsCreateOrConnectWithoutBelongs_toInput
      | JobsCreateOrConnectWithoutBelongs_toInput[];
    createMany?: JobsCreateManyBelongs_toInputEnvelope;
    connect?: JobsWhereUniqueInput | JobsWhereUniqueInput[];
  };

  export type QuotesCreateNestedManyWithoutBelongs_toInput = {
    create?:
      | XOR<
          QuotesCreateWithoutBelongs_toInput,
          QuotesUncheckedCreateWithoutBelongs_toInput
        >
      | QuotesCreateWithoutBelongs_toInput[]
      | QuotesUncheckedCreateWithoutBelongs_toInput[];
    connectOrCreate?:
      | QuotesCreateOrConnectWithoutBelongs_toInput
      | QuotesCreateOrConnectWithoutBelongs_toInput[];
    createMany?: QuotesCreateManyBelongs_toInputEnvelope;
    connect?: QuotesWhereUniqueInput | QuotesWhereUniqueInput[];
  };

  export type InvoicesCreateNestedManyWithoutBelongs_toInput = {
    create?:
      | XOR<
          InvoicesCreateWithoutBelongs_toInput,
          InvoicesUncheckedCreateWithoutBelongs_toInput
        >
      | InvoicesCreateWithoutBelongs_toInput[]
      | InvoicesUncheckedCreateWithoutBelongs_toInput[];
    connectOrCreate?:
      | InvoicesCreateOrConnectWithoutBelongs_toInput
      | InvoicesCreateOrConnectWithoutBelongs_toInput[];
    createMany?: InvoicesCreateManyBelongs_toInputEnvelope;
    connect?: InvoicesWhereUniqueInput | InvoicesWhereUniqueInput[];
  };

  export type ClientsUncheckedCreateNestedManyWithoutBelongs_toInput = {
    create?:
      | XOR<
          ClientsCreateWithoutBelongs_toInput,
          ClientsUncheckedCreateWithoutBelongs_toInput
        >
      | ClientsCreateWithoutBelongs_toInput[]
      | ClientsUncheckedCreateWithoutBelongs_toInput[];
    connectOrCreate?:
      | ClientsCreateOrConnectWithoutBelongs_toInput
      | ClientsCreateOrConnectWithoutBelongs_toInput[];
    createMany?: ClientsCreateManyBelongs_toInputEnvelope;
    connect?: ClientsWhereUniqueInput | ClientsWhereUniqueInput[];
  };

  export type RequestsUncheckedCreateNestedManyWithoutBelongs_toInput = {
    create?:
      | XOR<
          RequestsCreateWithoutBelongs_toInput,
          RequestsUncheckedCreateWithoutBelongs_toInput
        >
      | RequestsCreateWithoutBelongs_toInput[]
      | RequestsUncheckedCreateWithoutBelongs_toInput[];
    connectOrCreate?:
      | RequestsCreateOrConnectWithoutBelongs_toInput
      | RequestsCreateOrConnectWithoutBelongs_toInput[];
    createMany?: RequestsCreateManyBelongs_toInputEnvelope;
    connect?: RequestsWhereUniqueInput | RequestsWhereUniqueInput[];
  };

  export type JobsUncheckedCreateNestedManyWithoutBelongs_toInput = {
    create?:
      | XOR<
          JobsCreateWithoutBelongs_toInput,
          JobsUncheckedCreateWithoutBelongs_toInput
        >
      | JobsCreateWithoutBelongs_toInput[]
      | JobsUncheckedCreateWithoutBelongs_toInput[];
    connectOrCreate?:
      | JobsCreateOrConnectWithoutBelongs_toInput
      | JobsCreateOrConnectWithoutBelongs_toInput[];
    createMany?: JobsCreateManyBelongs_toInputEnvelope;
    connect?: JobsWhereUniqueInput | JobsWhereUniqueInput[];
  };

  export type QuotesUncheckedCreateNestedManyWithoutBelongs_toInput = {
    create?:
      | XOR<
          QuotesCreateWithoutBelongs_toInput,
          QuotesUncheckedCreateWithoutBelongs_toInput
        >
      | QuotesCreateWithoutBelongs_toInput[]
      | QuotesUncheckedCreateWithoutBelongs_toInput[];
    connectOrCreate?:
      | QuotesCreateOrConnectWithoutBelongs_toInput
      | QuotesCreateOrConnectWithoutBelongs_toInput[];
    createMany?: QuotesCreateManyBelongs_toInputEnvelope;
    connect?: QuotesWhereUniqueInput | QuotesWhereUniqueInput[];
  };

  export type InvoicesUncheckedCreateNestedManyWithoutBelongs_toInput = {
    create?:
      | XOR<
          InvoicesCreateWithoutBelongs_toInput,
          InvoicesUncheckedCreateWithoutBelongs_toInput
        >
      | InvoicesCreateWithoutBelongs_toInput[]
      | InvoicesUncheckedCreateWithoutBelongs_toInput[];
    connectOrCreate?:
      | InvoicesCreateOrConnectWithoutBelongs_toInput
      | InvoicesCreateOrConnectWithoutBelongs_toInput[];
    createMany?: InvoicesCreateManyBelongs_toInputEnvelope;
    connect?: InvoicesWhereUniqueInput | InvoicesWhereUniqueInput[];
  };

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null;
  };

  export type TaxesUpdateOneWithoutUsersNestedInput = {
    create?: XOR<
      TaxesCreateWithoutUsersInput,
      TaxesUncheckedCreateWithoutUsersInput
    >;
    connectOrCreate?: TaxesCreateOrConnectWithoutUsersInput;
    upsert?: TaxesUpsertWithoutUsersInput;
    disconnect?: TaxesWhereInput | boolean;
    delete?: TaxesWhereInput | boolean;
    connect?: TaxesWhereUniqueInput;
    update?: XOR<
      XOR<
        TaxesUpdateToOneWithWhereWithoutUsersInput,
        TaxesUpdateWithoutUsersInput
      >,
      TaxesUncheckedUpdateWithoutUsersInput
    >;
  };

  export type AddressesUpdateOneWithoutUsersNestedInput = {
    create?: XOR<
      AddressesCreateWithoutUsersInput,
      AddressesUncheckedCreateWithoutUsersInput
    >;
    connectOrCreate?: AddressesCreateOrConnectWithoutUsersInput;
    upsert?: AddressesUpsertWithoutUsersInput;
    disconnect?: AddressesWhereInput | boolean;
    delete?: AddressesWhereInput | boolean;
    connect?: AddressesWhereUniqueInput;
    update?: XOR<
      XOR<
        AddressesUpdateToOneWithWhereWithoutUsersInput,
        AddressesUpdateWithoutUsersInput
      >,
      AddressesUncheckedUpdateWithoutUsersInput
    >;
  };

  export type ClientsUpdateManyWithoutBelongs_toNestedInput = {
    create?:
      | XOR<
          ClientsCreateWithoutBelongs_toInput,
          ClientsUncheckedCreateWithoutBelongs_toInput
        >
      | ClientsCreateWithoutBelongs_toInput[]
      | ClientsUncheckedCreateWithoutBelongs_toInput[];
    connectOrCreate?:
      | ClientsCreateOrConnectWithoutBelongs_toInput
      | ClientsCreateOrConnectWithoutBelongs_toInput[];
    upsert?:
      | ClientsUpsertWithWhereUniqueWithoutBelongs_toInput
      | ClientsUpsertWithWhereUniqueWithoutBelongs_toInput[];
    createMany?: ClientsCreateManyBelongs_toInputEnvelope;
    set?: ClientsWhereUniqueInput | ClientsWhereUniqueInput[];
    disconnect?: ClientsWhereUniqueInput | ClientsWhereUniqueInput[];
    delete?: ClientsWhereUniqueInput | ClientsWhereUniqueInput[];
    connect?: ClientsWhereUniqueInput | ClientsWhereUniqueInput[];
    update?:
      | ClientsUpdateWithWhereUniqueWithoutBelongs_toInput
      | ClientsUpdateWithWhereUniqueWithoutBelongs_toInput[];
    updateMany?:
      | ClientsUpdateManyWithWhereWithoutBelongs_toInput
      | ClientsUpdateManyWithWhereWithoutBelongs_toInput[];
    deleteMany?: ClientsScalarWhereInput | ClientsScalarWhereInput[];
  };

  export type RequestsUpdateManyWithoutBelongs_toNestedInput = {
    create?:
      | XOR<
          RequestsCreateWithoutBelongs_toInput,
          RequestsUncheckedCreateWithoutBelongs_toInput
        >
      | RequestsCreateWithoutBelongs_toInput[]
      | RequestsUncheckedCreateWithoutBelongs_toInput[];
    connectOrCreate?:
      | RequestsCreateOrConnectWithoutBelongs_toInput
      | RequestsCreateOrConnectWithoutBelongs_toInput[];
    upsert?:
      | RequestsUpsertWithWhereUniqueWithoutBelongs_toInput
      | RequestsUpsertWithWhereUniqueWithoutBelongs_toInput[];
    createMany?: RequestsCreateManyBelongs_toInputEnvelope;
    set?: RequestsWhereUniqueInput | RequestsWhereUniqueInput[];
    disconnect?: RequestsWhereUniqueInput | RequestsWhereUniqueInput[];
    delete?: RequestsWhereUniqueInput | RequestsWhereUniqueInput[];
    connect?: RequestsWhereUniqueInput | RequestsWhereUniqueInput[];
    update?:
      | RequestsUpdateWithWhereUniqueWithoutBelongs_toInput
      | RequestsUpdateWithWhereUniqueWithoutBelongs_toInput[];
    updateMany?:
      | RequestsUpdateManyWithWhereWithoutBelongs_toInput
      | RequestsUpdateManyWithWhereWithoutBelongs_toInput[];
    deleteMany?: RequestsScalarWhereInput | RequestsScalarWhereInput[];
  };

  export type JobsUpdateManyWithoutBelongs_toNestedInput = {
    create?:
      | XOR<
          JobsCreateWithoutBelongs_toInput,
          JobsUncheckedCreateWithoutBelongs_toInput
        >
      | JobsCreateWithoutBelongs_toInput[]
      | JobsUncheckedCreateWithoutBelongs_toInput[];
    connectOrCreate?:
      | JobsCreateOrConnectWithoutBelongs_toInput
      | JobsCreateOrConnectWithoutBelongs_toInput[];
    upsert?:
      | JobsUpsertWithWhereUniqueWithoutBelongs_toInput
      | JobsUpsertWithWhereUniqueWithoutBelongs_toInput[];
    createMany?: JobsCreateManyBelongs_toInputEnvelope;
    set?: JobsWhereUniqueInput | JobsWhereUniqueInput[];
    disconnect?: JobsWhereUniqueInput | JobsWhereUniqueInput[];
    delete?: JobsWhereUniqueInput | JobsWhereUniqueInput[];
    connect?: JobsWhereUniqueInput | JobsWhereUniqueInput[];
    update?:
      | JobsUpdateWithWhereUniqueWithoutBelongs_toInput
      | JobsUpdateWithWhereUniqueWithoutBelongs_toInput[];
    updateMany?:
      | JobsUpdateManyWithWhereWithoutBelongs_toInput
      | JobsUpdateManyWithWhereWithoutBelongs_toInput[];
    deleteMany?: JobsScalarWhereInput | JobsScalarWhereInput[];
  };

  export type QuotesUpdateManyWithoutBelongs_toNestedInput = {
    create?:
      | XOR<
          QuotesCreateWithoutBelongs_toInput,
          QuotesUncheckedCreateWithoutBelongs_toInput
        >
      | QuotesCreateWithoutBelongs_toInput[]
      | QuotesUncheckedCreateWithoutBelongs_toInput[];
    connectOrCreate?:
      | QuotesCreateOrConnectWithoutBelongs_toInput
      | QuotesCreateOrConnectWithoutBelongs_toInput[];
    upsert?:
      | QuotesUpsertWithWhereUniqueWithoutBelongs_toInput
      | QuotesUpsertWithWhereUniqueWithoutBelongs_toInput[];
    createMany?: QuotesCreateManyBelongs_toInputEnvelope;
    set?: QuotesWhereUniqueInput | QuotesWhereUniqueInput[];
    disconnect?: QuotesWhereUniqueInput | QuotesWhereUniqueInput[];
    delete?: QuotesWhereUniqueInput | QuotesWhereUniqueInput[];
    connect?: QuotesWhereUniqueInput | QuotesWhereUniqueInput[];
    update?:
      | QuotesUpdateWithWhereUniqueWithoutBelongs_toInput
      | QuotesUpdateWithWhereUniqueWithoutBelongs_toInput[];
    updateMany?:
      | QuotesUpdateManyWithWhereWithoutBelongs_toInput
      | QuotesUpdateManyWithWhereWithoutBelongs_toInput[];
    deleteMany?: QuotesScalarWhereInput | QuotesScalarWhereInput[];
  };

  export type InvoicesUpdateManyWithoutBelongs_toNestedInput = {
    create?:
      | XOR<
          InvoicesCreateWithoutBelongs_toInput,
          InvoicesUncheckedCreateWithoutBelongs_toInput
        >
      | InvoicesCreateWithoutBelongs_toInput[]
      | InvoicesUncheckedCreateWithoutBelongs_toInput[];
    connectOrCreate?:
      | InvoicesCreateOrConnectWithoutBelongs_toInput
      | InvoicesCreateOrConnectWithoutBelongs_toInput[];
    upsert?:
      | InvoicesUpsertWithWhereUniqueWithoutBelongs_toInput
      | InvoicesUpsertWithWhereUniqueWithoutBelongs_toInput[];
    createMany?: InvoicesCreateManyBelongs_toInputEnvelope;
    set?: InvoicesWhereUniqueInput | InvoicesWhereUniqueInput[];
    disconnect?: InvoicesWhereUniqueInput | InvoicesWhereUniqueInput[];
    delete?: InvoicesWhereUniqueInput | InvoicesWhereUniqueInput[];
    connect?: InvoicesWhereUniqueInput | InvoicesWhereUniqueInput[];
    update?:
      | InvoicesUpdateWithWhereUniqueWithoutBelongs_toInput
      | InvoicesUpdateWithWhereUniqueWithoutBelongs_toInput[];
    updateMany?:
      | InvoicesUpdateManyWithWhereWithoutBelongs_toInput
      | InvoicesUpdateManyWithWhereWithoutBelongs_toInput[];
    deleteMany?: InvoicesScalarWhereInput | InvoicesScalarWhereInput[];
  };

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null;
    increment?: number;
    decrement?: number;
    multiply?: number;
    divide?: number;
  };

  export type ClientsUncheckedUpdateManyWithoutBelongs_toNestedInput = {
    create?:
      | XOR<
          ClientsCreateWithoutBelongs_toInput,
          ClientsUncheckedCreateWithoutBelongs_toInput
        >
      | ClientsCreateWithoutBelongs_toInput[]
      | ClientsUncheckedCreateWithoutBelongs_toInput[];
    connectOrCreate?:
      | ClientsCreateOrConnectWithoutBelongs_toInput
      | ClientsCreateOrConnectWithoutBelongs_toInput[];
    upsert?:
      | ClientsUpsertWithWhereUniqueWithoutBelongs_toInput
      | ClientsUpsertWithWhereUniqueWithoutBelongs_toInput[];
    createMany?: ClientsCreateManyBelongs_toInputEnvelope;
    set?: ClientsWhereUniqueInput | ClientsWhereUniqueInput[];
    disconnect?: ClientsWhereUniqueInput | ClientsWhereUniqueInput[];
    delete?: ClientsWhereUniqueInput | ClientsWhereUniqueInput[];
    connect?: ClientsWhereUniqueInput | ClientsWhereUniqueInput[];
    update?:
      | ClientsUpdateWithWhereUniqueWithoutBelongs_toInput
      | ClientsUpdateWithWhereUniqueWithoutBelongs_toInput[];
    updateMany?:
      | ClientsUpdateManyWithWhereWithoutBelongs_toInput
      | ClientsUpdateManyWithWhereWithoutBelongs_toInput[];
    deleteMany?: ClientsScalarWhereInput | ClientsScalarWhereInput[];
  };

  export type RequestsUncheckedUpdateManyWithoutBelongs_toNestedInput = {
    create?:
      | XOR<
          RequestsCreateWithoutBelongs_toInput,
          RequestsUncheckedCreateWithoutBelongs_toInput
        >
      | RequestsCreateWithoutBelongs_toInput[]
      | RequestsUncheckedCreateWithoutBelongs_toInput[];
    connectOrCreate?:
      | RequestsCreateOrConnectWithoutBelongs_toInput
      | RequestsCreateOrConnectWithoutBelongs_toInput[];
    upsert?:
      | RequestsUpsertWithWhereUniqueWithoutBelongs_toInput
      | RequestsUpsertWithWhereUniqueWithoutBelongs_toInput[];
    createMany?: RequestsCreateManyBelongs_toInputEnvelope;
    set?: RequestsWhereUniqueInput | RequestsWhereUniqueInput[];
    disconnect?: RequestsWhereUniqueInput | RequestsWhereUniqueInput[];
    delete?: RequestsWhereUniqueInput | RequestsWhereUniqueInput[];
    connect?: RequestsWhereUniqueInput | RequestsWhereUniqueInput[];
    update?:
      | RequestsUpdateWithWhereUniqueWithoutBelongs_toInput
      | RequestsUpdateWithWhereUniqueWithoutBelongs_toInput[];
    updateMany?:
      | RequestsUpdateManyWithWhereWithoutBelongs_toInput
      | RequestsUpdateManyWithWhereWithoutBelongs_toInput[];
    deleteMany?: RequestsScalarWhereInput | RequestsScalarWhereInput[];
  };

  export type JobsUncheckedUpdateManyWithoutBelongs_toNestedInput = {
    create?:
      | XOR<
          JobsCreateWithoutBelongs_toInput,
          JobsUncheckedCreateWithoutBelongs_toInput
        >
      | JobsCreateWithoutBelongs_toInput[]
      | JobsUncheckedCreateWithoutBelongs_toInput[];
    connectOrCreate?:
      | JobsCreateOrConnectWithoutBelongs_toInput
      | JobsCreateOrConnectWithoutBelongs_toInput[];
    upsert?:
      | JobsUpsertWithWhereUniqueWithoutBelongs_toInput
      | JobsUpsertWithWhereUniqueWithoutBelongs_toInput[];
    createMany?: JobsCreateManyBelongs_toInputEnvelope;
    set?: JobsWhereUniqueInput | JobsWhereUniqueInput[];
    disconnect?: JobsWhereUniqueInput | JobsWhereUniqueInput[];
    delete?: JobsWhereUniqueInput | JobsWhereUniqueInput[];
    connect?: JobsWhereUniqueInput | JobsWhereUniqueInput[];
    update?:
      | JobsUpdateWithWhereUniqueWithoutBelongs_toInput
      | JobsUpdateWithWhereUniqueWithoutBelongs_toInput[];
    updateMany?:
      | JobsUpdateManyWithWhereWithoutBelongs_toInput
      | JobsUpdateManyWithWhereWithoutBelongs_toInput[];
    deleteMany?: JobsScalarWhereInput | JobsScalarWhereInput[];
  };

  export type QuotesUncheckedUpdateManyWithoutBelongs_toNestedInput = {
    create?:
      | XOR<
          QuotesCreateWithoutBelongs_toInput,
          QuotesUncheckedCreateWithoutBelongs_toInput
        >
      | QuotesCreateWithoutBelongs_toInput[]
      | QuotesUncheckedCreateWithoutBelongs_toInput[];
    connectOrCreate?:
      | QuotesCreateOrConnectWithoutBelongs_toInput
      | QuotesCreateOrConnectWithoutBelongs_toInput[];
    upsert?:
      | QuotesUpsertWithWhereUniqueWithoutBelongs_toInput
      | QuotesUpsertWithWhereUniqueWithoutBelongs_toInput[];
    createMany?: QuotesCreateManyBelongs_toInputEnvelope;
    set?: QuotesWhereUniqueInput | QuotesWhereUniqueInput[];
    disconnect?: QuotesWhereUniqueInput | QuotesWhereUniqueInput[];
    delete?: QuotesWhereUniqueInput | QuotesWhereUniqueInput[];
    connect?: QuotesWhereUniqueInput | QuotesWhereUniqueInput[];
    update?:
      | QuotesUpdateWithWhereUniqueWithoutBelongs_toInput
      | QuotesUpdateWithWhereUniqueWithoutBelongs_toInput[];
    updateMany?:
      | QuotesUpdateManyWithWhereWithoutBelongs_toInput
      | QuotesUpdateManyWithWhereWithoutBelongs_toInput[];
    deleteMany?: QuotesScalarWhereInput | QuotesScalarWhereInput[];
  };

  export type InvoicesUncheckedUpdateManyWithoutBelongs_toNestedInput = {
    create?:
      | XOR<
          InvoicesCreateWithoutBelongs_toInput,
          InvoicesUncheckedCreateWithoutBelongs_toInput
        >
      | InvoicesCreateWithoutBelongs_toInput[]
      | InvoicesUncheckedCreateWithoutBelongs_toInput[];
    connectOrCreate?:
      | InvoicesCreateOrConnectWithoutBelongs_toInput
      | InvoicesCreateOrConnectWithoutBelongs_toInput[];
    upsert?:
      | InvoicesUpsertWithWhereUniqueWithoutBelongs_toInput
      | InvoicesUpsertWithWhereUniqueWithoutBelongs_toInput[];
    createMany?: InvoicesCreateManyBelongs_toInputEnvelope;
    set?: InvoicesWhereUniqueInput | InvoicesWhereUniqueInput[];
    disconnect?: InvoicesWhereUniqueInput | InvoicesWhereUniqueInput[];
    delete?: InvoicesWhereUniqueInput | InvoicesWhereUniqueInput[];
    connect?: InvoicesWhereUniqueInput | InvoicesWhereUniqueInput[];
    update?:
      | InvoicesUpdateWithWhereUniqueWithoutBelongs_toInput
      | InvoicesUpdateWithWhereUniqueWithoutBelongs_toInput[];
    updateMany?:
      | InvoicesUpdateManyWithWhereWithoutBelongs_toInput
      | InvoicesUpdateManyWithWhereWithoutBelongs_toInput[];
    deleteMany?: InvoicesScalarWhereInput | InvoicesScalarWhereInput[];
  };

  export type AddressesCreateNestedOneWithoutProperty_clientsInput = {
    create?: XOR<
      AddressesCreateWithoutProperty_clientsInput,
      AddressesUncheckedCreateWithoutProperty_clientsInput
    >;
    connectOrCreate?: AddressesCreateOrConnectWithoutProperty_clientsInput;
    connect?: AddressesWhereUniqueInput;
  };

  export type AddressesCreateNestedOneWithoutBilling_clientsInput = {
    create?: XOR<
      AddressesCreateWithoutBilling_clientsInput,
      AddressesUncheckedCreateWithoutBilling_clientsInput
    >;
    connectOrCreate?: AddressesCreateOrConnectWithoutBilling_clientsInput;
    connect?: AddressesWhereUniqueInput;
  };

  export type RequestsCreateNestedManyWithoutClientInput = {
    create?:
      | XOR<
          RequestsCreateWithoutClientInput,
          RequestsUncheckedCreateWithoutClientInput
        >
      | RequestsCreateWithoutClientInput[]
      | RequestsUncheckedCreateWithoutClientInput[];
    connectOrCreate?:
      | RequestsCreateOrConnectWithoutClientInput
      | RequestsCreateOrConnectWithoutClientInput[];
    createMany?: RequestsCreateManyClientInputEnvelope;
    connect?: RequestsWhereUniqueInput | RequestsWhereUniqueInput[];
  };

  export type QuotesCreateNestedManyWithoutClientInput = {
    create?:
      | XOR<
          QuotesCreateWithoutClientInput,
          QuotesUncheckedCreateWithoutClientInput
        >
      | QuotesCreateWithoutClientInput[]
      | QuotesUncheckedCreateWithoutClientInput[];
    connectOrCreate?:
      | QuotesCreateOrConnectWithoutClientInput
      | QuotesCreateOrConnectWithoutClientInput[];
    createMany?: QuotesCreateManyClientInputEnvelope;
    connect?: QuotesWhereUniqueInput | QuotesWhereUniqueInput[];
  };

  export type JobsCreateNestedManyWithoutClientInput = {
    create?:
      | XOR<JobsCreateWithoutClientInput, JobsUncheckedCreateWithoutClientInput>
      | JobsCreateWithoutClientInput[]
      | JobsUncheckedCreateWithoutClientInput[];
    connectOrCreate?:
      | JobsCreateOrConnectWithoutClientInput
      | JobsCreateOrConnectWithoutClientInput[];
    createMany?: JobsCreateManyClientInputEnvelope;
    connect?: JobsWhereUniqueInput | JobsWhereUniqueInput[];
  };

  export type InvoicesCreateNestedManyWithoutClientInput = {
    create?:
      | XOR<
          InvoicesCreateWithoutClientInput,
          InvoicesUncheckedCreateWithoutClientInput
        >
      | InvoicesCreateWithoutClientInput[]
      | InvoicesUncheckedCreateWithoutClientInput[];
    connectOrCreate?:
      | InvoicesCreateOrConnectWithoutClientInput
      | InvoicesCreateOrConnectWithoutClientInput[];
    createMany?: InvoicesCreateManyClientInputEnvelope;
    connect?: InvoicesWhereUniqueInput | InvoicesWhereUniqueInput[];
  };

  export type UsersCreateNestedOneWithoutClientsInput = {
    create?: XOR<
      UsersCreateWithoutClientsInput,
      UsersUncheckedCreateWithoutClientsInput
    >;
    connectOrCreate?: UsersCreateOrConnectWithoutClientsInput;
    connect?: UsersWhereUniqueInput;
  };

  export type RequestsUncheckedCreateNestedManyWithoutClientInput = {
    create?:
      | XOR<
          RequestsCreateWithoutClientInput,
          RequestsUncheckedCreateWithoutClientInput
        >
      | RequestsCreateWithoutClientInput[]
      | RequestsUncheckedCreateWithoutClientInput[];
    connectOrCreate?:
      | RequestsCreateOrConnectWithoutClientInput
      | RequestsCreateOrConnectWithoutClientInput[];
    createMany?: RequestsCreateManyClientInputEnvelope;
    connect?: RequestsWhereUniqueInput | RequestsWhereUniqueInput[];
  };

  export type QuotesUncheckedCreateNestedManyWithoutClientInput = {
    create?:
      | XOR<
          QuotesCreateWithoutClientInput,
          QuotesUncheckedCreateWithoutClientInput
        >
      | QuotesCreateWithoutClientInput[]
      | QuotesUncheckedCreateWithoutClientInput[];
    connectOrCreate?:
      | QuotesCreateOrConnectWithoutClientInput
      | QuotesCreateOrConnectWithoutClientInput[];
    createMany?: QuotesCreateManyClientInputEnvelope;
    connect?: QuotesWhereUniqueInput | QuotesWhereUniqueInput[];
  };

  export type JobsUncheckedCreateNestedManyWithoutClientInput = {
    create?:
      | XOR<JobsCreateWithoutClientInput, JobsUncheckedCreateWithoutClientInput>
      | JobsCreateWithoutClientInput[]
      | JobsUncheckedCreateWithoutClientInput[];
    connectOrCreate?:
      | JobsCreateOrConnectWithoutClientInput
      | JobsCreateOrConnectWithoutClientInput[];
    createMany?: JobsCreateManyClientInputEnvelope;
    connect?: JobsWhereUniqueInput | JobsWhereUniqueInput[];
  };

  export type InvoicesUncheckedCreateNestedManyWithoutClientInput = {
    create?:
      | XOR<
          InvoicesCreateWithoutClientInput,
          InvoicesUncheckedCreateWithoutClientInput
        >
      | InvoicesCreateWithoutClientInput[]
      | InvoicesUncheckedCreateWithoutClientInput[];
    connectOrCreate?:
      | InvoicesCreateOrConnectWithoutClientInput
      | InvoicesCreateOrConnectWithoutClientInput[];
    createMany?: InvoicesCreateManyClientInputEnvelope;
    connect?: InvoicesWhereUniqueInput | InvoicesWhereUniqueInput[];
  };

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean;
  };

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string;
  };

  export type AddressesUpdateOneWithoutProperty_clientsNestedInput = {
    create?: XOR<
      AddressesCreateWithoutProperty_clientsInput,
      AddressesUncheckedCreateWithoutProperty_clientsInput
    >;
    connectOrCreate?: AddressesCreateOrConnectWithoutProperty_clientsInput;
    upsert?: AddressesUpsertWithoutProperty_clientsInput;
    disconnect?: AddressesWhereInput | boolean;
    delete?: AddressesWhereInput | boolean;
    connect?: AddressesWhereUniqueInput;
    update?: XOR<
      XOR<
        AddressesUpdateToOneWithWhereWithoutProperty_clientsInput,
        AddressesUpdateWithoutProperty_clientsInput
      >,
      AddressesUncheckedUpdateWithoutProperty_clientsInput
    >;
  };

  export type AddressesUpdateOneWithoutBilling_clientsNestedInput = {
    create?: XOR<
      AddressesCreateWithoutBilling_clientsInput,
      AddressesUncheckedCreateWithoutBilling_clientsInput
    >;
    connectOrCreate?: AddressesCreateOrConnectWithoutBilling_clientsInput;
    upsert?: AddressesUpsertWithoutBilling_clientsInput;
    disconnect?: AddressesWhereInput | boolean;
    delete?: AddressesWhereInput | boolean;
    connect?: AddressesWhereUniqueInput;
    update?: XOR<
      XOR<
        AddressesUpdateToOneWithWhereWithoutBilling_clientsInput,
        AddressesUpdateWithoutBilling_clientsInput
      >,
      AddressesUncheckedUpdateWithoutBilling_clientsInput
    >;
  };

  export type RequestsUpdateManyWithoutClientNestedInput = {
    create?:
      | XOR<
          RequestsCreateWithoutClientInput,
          RequestsUncheckedCreateWithoutClientInput
        >
      | RequestsCreateWithoutClientInput[]
      | RequestsUncheckedCreateWithoutClientInput[];
    connectOrCreate?:
      | RequestsCreateOrConnectWithoutClientInput
      | RequestsCreateOrConnectWithoutClientInput[];
    upsert?:
      | RequestsUpsertWithWhereUniqueWithoutClientInput
      | RequestsUpsertWithWhereUniqueWithoutClientInput[];
    createMany?: RequestsCreateManyClientInputEnvelope;
    set?: RequestsWhereUniqueInput | RequestsWhereUniqueInput[];
    disconnect?: RequestsWhereUniqueInput | RequestsWhereUniqueInput[];
    delete?: RequestsWhereUniqueInput | RequestsWhereUniqueInput[];
    connect?: RequestsWhereUniqueInput | RequestsWhereUniqueInput[];
    update?:
      | RequestsUpdateWithWhereUniqueWithoutClientInput
      | RequestsUpdateWithWhereUniqueWithoutClientInput[];
    updateMany?:
      | RequestsUpdateManyWithWhereWithoutClientInput
      | RequestsUpdateManyWithWhereWithoutClientInput[];
    deleteMany?: RequestsScalarWhereInput | RequestsScalarWhereInput[];
  };

  export type QuotesUpdateManyWithoutClientNestedInput = {
    create?:
      | XOR<
          QuotesCreateWithoutClientInput,
          QuotesUncheckedCreateWithoutClientInput
        >
      | QuotesCreateWithoutClientInput[]
      | QuotesUncheckedCreateWithoutClientInput[];
    connectOrCreate?:
      | QuotesCreateOrConnectWithoutClientInput
      | QuotesCreateOrConnectWithoutClientInput[];
    upsert?:
      | QuotesUpsertWithWhereUniqueWithoutClientInput
      | QuotesUpsertWithWhereUniqueWithoutClientInput[];
    createMany?: QuotesCreateManyClientInputEnvelope;
    set?: QuotesWhereUniqueInput | QuotesWhereUniqueInput[];
    disconnect?: QuotesWhereUniqueInput | QuotesWhereUniqueInput[];
    delete?: QuotesWhereUniqueInput | QuotesWhereUniqueInput[];
    connect?: QuotesWhereUniqueInput | QuotesWhereUniqueInput[];
    update?:
      | QuotesUpdateWithWhereUniqueWithoutClientInput
      | QuotesUpdateWithWhereUniqueWithoutClientInput[];
    updateMany?:
      | QuotesUpdateManyWithWhereWithoutClientInput
      | QuotesUpdateManyWithWhereWithoutClientInput[];
    deleteMany?: QuotesScalarWhereInput | QuotesScalarWhereInput[];
  };

  export type JobsUpdateManyWithoutClientNestedInput = {
    create?:
      | XOR<JobsCreateWithoutClientInput, JobsUncheckedCreateWithoutClientInput>
      | JobsCreateWithoutClientInput[]
      | JobsUncheckedCreateWithoutClientInput[];
    connectOrCreate?:
      | JobsCreateOrConnectWithoutClientInput
      | JobsCreateOrConnectWithoutClientInput[];
    upsert?:
      | JobsUpsertWithWhereUniqueWithoutClientInput
      | JobsUpsertWithWhereUniqueWithoutClientInput[];
    createMany?: JobsCreateManyClientInputEnvelope;
    set?: JobsWhereUniqueInput | JobsWhereUniqueInput[];
    disconnect?: JobsWhereUniqueInput | JobsWhereUniqueInput[];
    delete?: JobsWhereUniqueInput | JobsWhereUniqueInput[];
    connect?: JobsWhereUniqueInput | JobsWhereUniqueInput[];
    update?:
      | JobsUpdateWithWhereUniqueWithoutClientInput
      | JobsUpdateWithWhereUniqueWithoutClientInput[];
    updateMany?:
      | JobsUpdateManyWithWhereWithoutClientInput
      | JobsUpdateManyWithWhereWithoutClientInput[];
    deleteMany?: JobsScalarWhereInput | JobsScalarWhereInput[];
  };

  export type InvoicesUpdateManyWithoutClientNestedInput = {
    create?:
      | XOR<
          InvoicesCreateWithoutClientInput,
          InvoicesUncheckedCreateWithoutClientInput
        >
      | InvoicesCreateWithoutClientInput[]
      | InvoicesUncheckedCreateWithoutClientInput[];
    connectOrCreate?:
      | InvoicesCreateOrConnectWithoutClientInput
      | InvoicesCreateOrConnectWithoutClientInput[];
    upsert?:
      | InvoicesUpsertWithWhereUniqueWithoutClientInput
      | InvoicesUpsertWithWhereUniqueWithoutClientInput[];
    createMany?: InvoicesCreateManyClientInputEnvelope;
    set?: InvoicesWhereUniqueInput | InvoicesWhereUniqueInput[];
    disconnect?: InvoicesWhereUniqueInput | InvoicesWhereUniqueInput[];
    delete?: InvoicesWhereUniqueInput | InvoicesWhereUniqueInput[];
    connect?: InvoicesWhereUniqueInput | InvoicesWhereUniqueInput[];
    update?:
      | InvoicesUpdateWithWhereUniqueWithoutClientInput
      | InvoicesUpdateWithWhereUniqueWithoutClientInput[];
    updateMany?:
      | InvoicesUpdateManyWithWhereWithoutClientInput
      | InvoicesUpdateManyWithWhereWithoutClientInput[];
    deleteMany?: InvoicesScalarWhereInput | InvoicesScalarWhereInput[];
  };

  export type UsersUpdateOneRequiredWithoutClientsNestedInput = {
    create?: XOR<
      UsersCreateWithoutClientsInput,
      UsersUncheckedCreateWithoutClientsInput
    >;
    connectOrCreate?: UsersCreateOrConnectWithoutClientsInput;
    upsert?: UsersUpsertWithoutClientsInput;
    connect?: UsersWhereUniqueInput;
    update?: XOR<
      XOR<
        UsersUpdateToOneWithWhereWithoutClientsInput,
        UsersUpdateWithoutClientsInput
      >,
      UsersUncheckedUpdateWithoutClientsInput
    >;
  };

  export type RequestsUncheckedUpdateManyWithoutClientNestedInput = {
    create?:
      | XOR<
          RequestsCreateWithoutClientInput,
          RequestsUncheckedCreateWithoutClientInput
        >
      | RequestsCreateWithoutClientInput[]
      | RequestsUncheckedCreateWithoutClientInput[];
    connectOrCreate?:
      | RequestsCreateOrConnectWithoutClientInput
      | RequestsCreateOrConnectWithoutClientInput[];
    upsert?:
      | RequestsUpsertWithWhereUniqueWithoutClientInput
      | RequestsUpsertWithWhereUniqueWithoutClientInput[];
    createMany?: RequestsCreateManyClientInputEnvelope;
    set?: RequestsWhereUniqueInput | RequestsWhereUniqueInput[];
    disconnect?: RequestsWhereUniqueInput | RequestsWhereUniqueInput[];
    delete?: RequestsWhereUniqueInput | RequestsWhereUniqueInput[];
    connect?: RequestsWhereUniqueInput | RequestsWhereUniqueInput[];
    update?:
      | RequestsUpdateWithWhereUniqueWithoutClientInput
      | RequestsUpdateWithWhereUniqueWithoutClientInput[];
    updateMany?:
      | RequestsUpdateManyWithWhereWithoutClientInput
      | RequestsUpdateManyWithWhereWithoutClientInput[];
    deleteMany?: RequestsScalarWhereInput | RequestsScalarWhereInput[];
  };

  export type QuotesUncheckedUpdateManyWithoutClientNestedInput = {
    create?:
      | XOR<
          QuotesCreateWithoutClientInput,
          QuotesUncheckedCreateWithoutClientInput
        >
      | QuotesCreateWithoutClientInput[]
      | QuotesUncheckedCreateWithoutClientInput[];
    connectOrCreate?:
      | QuotesCreateOrConnectWithoutClientInput
      | QuotesCreateOrConnectWithoutClientInput[];
    upsert?:
      | QuotesUpsertWithWhereUniqueWithoutClientInput
      | QuotesUpsertWithWhereUniqueWithoutClientInput[];
    createMany?: QuotesCreateManyClientInputEnvelope;
    set?: QuotesWhereUniqueInput | QuotesWhereUniqueInput[];
    disconnect?: QuotesWhereUniqueInput | QuotesWhereUniqueInput[];
    delete?: QuotesWhereUniqueInput | QuotesWhereUniqueInput[];
    connect?: QuotesWhereUniqueInput | QuotesWhereUniqueInput[];
    update?:
      | QuotesUpdateWithWhereUniqueWithoutClientInput
      | QuotesUpdateWithWhereUniqueWithoutClientInput[];
    updateMany?:
      | QuotesUpdateManyWithWhereWithoutClientInput
      | QuotesUpdateManyWithWhereWithoutClientInput[];
    deleteMany?: QuotesScalarWhereInput | QuotesScalarWhereInput[];
  };

  export type JobsUncheckedUpdateManyWithoutClientNestedInput = {
    create?:
      | XOR<JobsCreateWithoutClientInput, JobsUncheckedCreateWithoutClientInput>
      | JobsCreateWithoutClientInput[]
      | JobsUncheckedCreateWithoutClientInput[];
    connectOrCreate?:
      | JobsCreateOrConnectWithoutClientInput
      | JobsCreateOrConnectWithoutClientInput[];
    upsert?:
      | JobsUpsertWithWhereUniqueWithoutClientInput
      | JobsUpsertWithWhereUniqueWithoutClientInput[];
    createMany?: JobsCreateManyClientInputEnvelope;
    set?: JobsWhereUniqueInput | JobsWhereUniqueInput[];
    disconnect?: JobsWhereUniqueInput | JobsWhereUniqueInput[];
    delete?: JobsWhereUniqueInput | JobsWhereUniqueInput[];
    connect?: JobsWhereUniqueInput | JobsWhereUniqueInput[];
    update?:
      | JobsUpdateWithWhereUniqueWithoutClientInput
      | JobsUpdateWithWhereUniqueWithoutClientInput[];
    updateMany?:
      | JobsUpdateManyWithWhereWithoutClientInput
      | JobsUpdateManyWithWhereWithoutClientInput[];
    deleteMany?: JobsScalarWhereInput | JobsScalarWhereInput[];
  };

  export type InvoicesUncheckedUpdateManyWithoutClientNestedInput = {
    create?:
      | XOR<
          InvoicesCreateWithoutClientInput,
          InvoicesUncheckedCreateWithoutClientInput
        >
      | InvoicesCreateWithoutClientInput[]
      | InvoicesUncheckedCreateWithoutClientInput[];
    connectOrCreate?:
      | InvoicesCreateOrConnectWithoutClientInput
      | InvoicesCreateOrConnectWithoutClientInput[];
    upsert?:
      | InvoicesUpsertWithWhereUniqueWithoutClientInput
      | InvoicesUpsertWithWhereUniqueWithoutClientInput[];
    createMany?: InvoicesCreateManyClientInputEnvelope;
    set?: InvoicesWhereUniqueInput | InvoicesWhereUniqueInput[];
    disconnect?: InvoicesWhereUniqueInput | InvoicesWhereUniqueInput[];
    delete?: InvoicesWhereUniqueInput | InvoicesWhereUniqueInput[];
    connect?: InvoicesWhereUniqueInput | InvoicesWhereUniqueInput[];
    update?:
      | InvoicesUpdateWithWhereUniqueWithoutClientInput
      | InvoicesUpdateWithWhereUniqueWithoutClientInput[];
    updateMany?:
      | InvoicesUpdateManyWithWhereWithoutClientInput
      | InvoicesUpdateManyWithWhereWithoutClientInput[];
    deleteMany?: InvoicesScalarWhereInput | InvoicesScalarWhereInput[];
  };

  export type RequestsCreateNestedManyWithoutAssessmentInput = {
    create?:
      | XOR<
          RequestsCreateWithoutAssessmentInput,
          RequestsUncheckedCreateWithoutAssessmentInput
        >
      | RequestsCreateWithoutAssessmentInput[]
      | RequestsUncheckedCreateWithoutAssessmentInput[];
    connectOrCreate?:
      | RequestsCreateOrConnectWithoutAssessmentInput
      | RequestsCreateOrConnectWithoutAssessmentInput[];
    createMany?: RequestsCreateManyAssessmentInputEnvelope;
    connect?: RequestsWhereUniqueInput | RequestsWhereUniqueInput[];
  };

  export type RequestsUncheckedCreateNestedManyWithoutAssessmentInput = {
    create?:
      | XOR<
          RequestsCreateWithoutAssessmentInput,
          RequestsUncheckedCreateWithoutAssessmentInput
        >
      | RequestsCreateWithoutAssessmentInput[]
      | RequestsUncheckedCreateWithoutAssessmentInput[];
    connectOrCreate?:
      | RequestsCreateOrConnectWithoutAssessmentInput
      | RequestsCreateOrConnectWithoutAssessmentInput[];
    createMany?: RequestsCreateManyAssessmentInputEnvelope;
    connect?: RequestsWhereUniqueInput | RequestsWhereUniqueInput[];
  };

  export type RequestsUpdateManyWithoutAssessmentNestedInput = {
    create?:
      | XOR<
          RequestsCreateWithoutAssessmentInput,
          RequestsUncheckedCreateWithoutAssessmentInput
        >
      | RequestsCreateWithoutAssessmentInput[]
      | RequestsUncheckedCreateWithoutAssessmentInput[];
    connectOrCreate?:
      | RequestsCreateOrConnectWithoutAssessmentInput
      | RequestsCreateOrConnectWithoutAssessmentInput[];
    upsert?:
      | RequestsUpsertWithWhereUniqueWithoutAssessmentInput
      | RequestsUpsertWithWhereUniqueWithoutAssessmentInput[];
    createMany?: RequestsCreateManyAssessmentInputEnvelope;
    set?: RequestsWhereUniqueInput | RequestsWhereUniqueInput[];
    disconnect?: RequestsWhereUniqueInput | RequestsWhereUniqueInput[];
    delete?: RequestsWhereUniqueInput | RequestsWhereUniqueInput[];
    connect?: RequestsWhereUniqueInput | RequestsWhereUniqueInput[];
    update?:
      | RequestsUpdateWithWhereUniqueWithoutAssessmentInput
      | RequestsUpdateWithWhereUniqueWithoutAssessmentInput[];
    updateMany?:
      | RequestsUpdateManyWithWhereWithoutAssessmentInput
      | RequestsUpdateManyWithWhereWithoutAssessmentInput[];
    deleteMany?: RequestsScalarWhereInput | RequestsScalarWhereInput[];
  };

  export type RequestsUncheckedUpdateManyWithoutAssessmentNestedInput = {
    create?:
      | XOR<
          RequestsCreateWithoutAssessmentInput,
          RequestsUncheckedCreateWithoutAssessmentInput
        >
      | RequestsCreateWithoutAssessmentInput[]
      | RequestsUncheckedCreateWithoutAssessmentInput[];
    connectOrCreate?:
      | RequestsCreateOrConnectWithoutAssessmentInput
      | RequestsCreateOrConnectWithoutAssessmentInput[];
    upsert?:
      | RequestsUpsertWithWhereUniqueWithoutAssessmentInput
      | RequestsUpsertWithWhereUniqueWithoutAssessmentInput[];
    createMany?: RequestsCreateManyAssessmentInputEnvelope;
    set?: RequestsWhereUniqueInput | RequestsWhereUniqueInput[];
    disconnect?: RequestsWhereUniqueInput | RequestsWhereUniqueInput[];
    delete?: RequestsWhereUniqueInput | RequestsWhereUniqueInput[];
    connect?: RequestsWhereUniqueInput | RequestsWhereUniqueInput[];
    update?:
      | RequestsUpdateWithWhereUniqueWithoutAssessmentInput
      | RequestsUpdateWithWhereUniqueWithoutAssessmentInput[];
    updateMany?:
      | RequestsUpdateManyWithWhereWithoutAssessmentInput
      | RequestsUpdateManyWithWhereWithoutAssessmentInput[];
    deleteMany?: RequestsScalarWhereInput | RequestsScalarWhereInput[];
  };

  export type AssessmentsCreateNestedOneWithoutRequestsInput = {
    create?: XOR<
      AssessmentsCreateWithoutRequestsInput,
      AssessmentsUncheckedCreateWithoutRequestsInput
    >;
    connectOrCreate?: AssessmentsCreateOrConnectWithoutRequestsInput;
    connect?: AssessmentsWhereUniqueInput;
  };

  export type ClientsCreateNestedOneWithoutRequestsInput = {
    create?: XOR<
      ClientsCreateWithoutRequestsInput,
      ClientsUncheckedCreateWithoutRequestsInput
    >;
    connectOrCreate?: ClientsCreateOrConnectWithoutRequestsInput;
    connect?: ClientsWhereUniqueInput;
  };

  export type QuoteRequestCreateNestedManyWithoutRequestInput = {
    create?:
      | XOR<
          QuoteRequestCreateWithoutRequestInput,
          QuoteRequestUncheckedCreateWithoutRequestInput
        >
      | QuoteRequestCreateWithoutRequestInput[]
      | QuoteRequestUncheckedCreateWithoutRequestInput[];
    connectOrCreate?:
      | QuoteRequestCreateOrConnectWithoutRequestInput
      | QuoteRequestCreateOrConnectWithoutRequestInput[];
    createMany?: QuoteRequestCreateManyRequestInputEnvelope;
    connect?: QuoteRequestWhereUniqueInput | QuoteRequestWhereUniqueInput[];
  };

  export type JobRequestCreateNestedManyWithoutRequestInput = {
    create?:
      | XOR<
          JobRequestCreateWithoutRequestInput,
          JobRequestUncheckedCreateWithoutRequestInput
        >
      | JobRequestCreateWithoutRequestInput[]
      | JobRequestUncheckedCreateWithoutRequestInput[];
    connectOrCreate?:
      | JobRequestCreateOrConnectWithoutRequestInput
      | JobRequestCreateOrConnectWithoutRequestInput[];
    createMany?: JobRequestCreateManyRequestInputEnvelope;
    connect?: JobRequestWhereUniqueInput | JobRequestWhereUniqueInput[];
  };

  export type UsersCreateNestedOneWithoutRequestsInput = {
    create?: XOR<
      UsersCreateWithoutRequestsInput,
      UsersUncheckedCreateWithoutRequestsInput
    >;
    connectOrCreate?: UsersCreateOrConnectWithoutRequestsInput;
    connect?: UsersWhereUniqueInput;
  };

  export type QuoteRequestUncheckedCreateNestedManyWithoutRequestInput = {
    create?:
      | XOR<
          QuoteRequestCreateWithoutRequestInput,
          QuoteRequestUncheckedCreateWithoutRequestInput
        >
      | QuoteRequestCreateWithoutRequestInput[]
      | QuoteRequestUncheckedCreateWithoutRequestInput[];
    connectOrCreate?:
      | QuoteRequestCreateOrConnectWithoutRequestInput
      | QuoteRequestCreateOrConnectWithoutRequestInput[];
    createMany?: QuoteRequestCreateManyRequestInputEnvelope;
    connect?: QuoteRequestWhereUniqueInput | QuoteRequestWhereUniqueInput[];
  };

  export type JobRequestUncheckedCreateNestedManyWithoutRequestInput = {
    create?:
      | XOR<
          JobRequestCreateWithoutRequestInput,
          JobRequestUncheckedCreateWithoutRequestInput
        >
      | JobRequestCreateWithoutRequestInput[]
      | JobRequestUncheckedCreateWithoutRequestInput[];
    connectOrCreate?:
      | JobRequestCreateOrConnectWithoutRequestInput
      | JobRequestCreateOrConnectWithoutRequestInput[];
    createMany?: JobRequestCreateManyRequestInputEnvelope;
    connect?: JobRequestWhereUniqueInput | JobRequestWhereUniqueInput[];
  };

  export type AssessmentsUpdateOneRequiredWithoutRequestsNestedInput = {
    create?: XOR<
      AssessmentsCreateWithoutRequestsInput,
      AssessmentsUncheckedCreateWithoutRequestsInput
    >;
    connectOrCreate?: AssessmentsCreateOrConnectWithoutRequestsInput;
    upsert?: AssessmentsUpsertWithoutRequestsInput;
    connect?: AssessmentsWhereUniqueInput;
    update?: XOR<
      XOR<
        AssessmentsUpdateToOneWithWhereWithoutRequestsInput,
        AssessmentsUpdateWithoutRequestsInput
      >,
      AssessmentsUncheckedUpdateWithoutRequestsInput
    >;
  };

  export type ClientsUpdateOneRequiredWithoutRequestsNestedInput = {
    create?: XOR<
      ClientsCreateWithoutRequestsInput,
      ClientsUncheckedCreateWithoutRequestsInput
    >;
    connectOrCreate?: ClientsCreateOrConnectWithoutRequestsInput;
    upsert?: ClientsUpsertWithoutRequestsInput;
    connect?: ClientsWhereUniqueInput;
    update?: XOR<
      XOR<
        ClientsUpdateToOneWithWhereWithoutRequestsInput,
        ClientsUpdateWithoutRequestsInput
      >,
      ClientsUncheckedUpdateWithoutRequestsInput
    >;
  };

  export type QuoteRequestUpdateManyWithoutRequestNestedInput = {
    create?:
      | XOR<
          QuoteRequestCreateWithoutRequestInput,
          QuoteRequestUncheckedCreateWithoutRequestInput
        >
      | QuoteRequestCreateWithoutRequestInput[]
      | QuoteRequestUncheckedCreateWithoutRequestInput[];
    connectOrCreate?:
      | QuoteRequestCreateOrConnectWithoutRequestInput
      | QuoteRequestCreateOrConnectWithoutRequestInput[];
    upsert?:
      | QuoteRequestUpsertWithWhereUniqueWithoutRequestInput
      | QuoteRequestUpsertWithWhereUniqueWithoutRequestInput[];
    createMany?: QuoteRequestCreateManyRequestInputEnvelope;
    set?: QuoteRequestWhereUniqueInput | QuoteRequestWhereUniqueInput[];
    disconnect?: QuoteRequestWhereUniqueInput | QuoteRequestWhereUniqueInput[];
    delete?: QuoteRequestWhereUniqueInput | QuoteRequestWhereUniqueInput[];
    connect?: QuoteRequestWhereUniqueInput | QuoteRequestWhereUniqueInput[];
    update?:
      | QuoteRequestUpdateWithWhereUniqueWithoutRequestInput
      | QuoteRequestUpdateWithWhereUniqueWithoutRequestInput[];
    updateMany?:
      | QuoteRequestUpdateManyWithWhereWithoutRequestInput
      | QuoteRequestUpdateManyWithWhereWithoutRequestInput[];
    deleteMany?: QuoteRequestScalarWhereInput | QuoteRequestScalarWhereInput[];
  };

  export type JobRequestUpdateManyWithoutRequestNestedInput = {
    create?:
      | XOR<
          JobRequestCreateWithoutRequestInput,
          JobRequestUncheckedCreateWithoutRequestInput
        >
      | JobRequestCreateWithoutRequestInput[]
      | JobRequestUncheckedCreateWithoutRequestInput[];
    connectOrCreate?:
      | JobRequestCreateOrConnectWithoutRequestInput
      | JobRequestCreateOrConnectWithoutRequestInput[];
    upsert?:
      | JobRequestUpsertWithWhereUniqueWithoutRequestInput
      | JobRequestUpsertWithWhereUniqueWithoutRequestInput[];
    createMany?: JobRequestCreateManyRequestInputEnvelope;
    set?: JobRequestWhereUniqueInput | JobRequestWhereUniqueInput[];
    disconnect?: JobRequestWhereUniqueInput | JobRequestWhereUniqueInput[];
    delete?: JobRequestWhereUniqueInput | JobRequestWhereUniqueInput[];
    connect?: JobRequestWhereUniqueInput | JobRequestWhereUniqueInput[];
    update?:
      | JobRequestUpdateWithWhereUniqueWithoutRequestInput
      | JobRequestUpdateWithWhereUniqueWithoutRequestInput[];
    updateMany?:
      | JobRequestUpdateManyWithWhereWithoutRequestInput
      | JobRequestUpdateManyWithWhereWithoutRequestInput[];
    deleteMany?: JobRequestScalarWhereInput | JobRequestScalarWhereInput[];
  };

  export type UsersUpdateOneRequiredWithoutRequestsNestedInput = {
    create?: XOR<
      UsersCreateWithoutRequestsInput,
      UsersUncheckedCreateWithoutRequestsInput
    >;
    connectOrCreate?: UsersCreateOrConnectWithoutRequestsInput;
    upsert?: UsersUpsertWithoutRequestsInput;
    connect?: UsersWhereUniqueInput;
    update?: XOR<
      XOR<
        UsersUpdateToOneWithWhereWithoutRequestsInput,
        UsersUpdateWithoutRequestsInput
      >,
      UsersUncheckedUpdateWithoutRequestsInput
    >;
  };

  export type QuoteRequestUncheckedUpdateManyWithoutRequestNestedInput = {
    create?:
      | XOR<
          QuoteRequestCreateWithoutRequestInput,
          QuoteRequestUncheckedCreateWithoutRequestInput
        >
      | QuoteRequestCreateWithoutRequestInput[]
      | QuoteRequestUncheckedCreateWithoutRequestInput[];
    connectOrCreate?:
      | QuoteRequestCreateOrConnectWithoutRequestInput
      | QuoteRequestCreateOrConnectWithoutRequestInput[];
    upsert?:
      | QuoteRequestUpsertWithWhereUniqueWithoutRequestInput
      | QuoteRequestUpsertWithWhereUniqueWithoutRequestInput[];
    createMany?: QuoteRequestCreateManyRequestInputEnvelope;
    set?: QuoteRequestWhereUniqueInput | QuoteRequestWhereUniqueInput[];
    disconnect?: QuoteRequestWhereUniqueInput | QuoteRequestWhereUniqueInput[];
    delete?: QuoteRequestWhereUniqueInput | QuoteRequestWhereUniqueInput[];
    connect?: QuoteRequestWhereUniqueInput | QuoteRequestWhereUniqueInput[];
    update?:
      | QuoteRequestUpdateWithWhereUniqueWithoutRequestInput
      | QuoteRequestUpdateWithWhereUniqueWithoutRequestInput[];
    updateMany?:
      | QuoteRequestUpdateManyWithWhereWithoutRequestInput
      | QuoteRequestUpdateManyWithWhereWithoutRequestInput[];
    deleteMany?: QuoteRequestScalarWhereInput | QuoteRequestScalarWhereInput[];
  };

  export type JobRequestUncheckedUpdateManyWithoutRequestNestedInput = {
    create?:
      | XOR<
          JobRequestCreateWithoutRequestInput,
          JobRequestUncheckedCreateWithoutRequestInput
        >
      | JobRequestCreateWithoutRequestInput[]
      | JobRequestUncheckedCreateWithoutRequestInput[];
    connectOrCreate?:
      | JobRequestCreateOrConnectWithoutRequestInput
      | JobRequestCreateOrConnectWithoutRequestInput[];
    upsert?:
      | JobRequestUpsertWithWhereUniqueWithoutRequestInput
      | JobRequestUpsertWithWhereUniqueWithoutRequestInput[];
    createMany?: JobRequestCreateManyRequestInputEnvelope;
    set?: JobRequestWhereUniqueInput | JobRequestWhereUniqueInput[];
    disconnect?: JobRequestWhereUniqueInput | JobRequestWhereUniqueInput[];
    delete?: JobRequestWhereUniqueInput | JobRequestWhereUniqueInput[];
    connect?: JobRequestWhereUniqueInput | JobRequestWhereUniqueInput[];
    update?:
      | JobRequestUpdateWithWhereUniqueWithoutRequestInput
      | JobRequestUpdateWithWhereUniqueWithoutRequestInput[];
    updateMany?:
      | JobRequestUpdateManyWithWhereWithoutRequestInput
      | JobRequestUpdateManyWithWhereWithoutRequestInput[];
    deleteMany?: JobRequestScalarWhereInput | JobRequestScalarWhereInput[];
  };

  export type LineItemQuoteCreateNestedManyWithoutLine_itemInput = {
    create?:
      | XOR<
          LineItemQuoteCreateWithoutLine_itemInput,
          LineItemQuoteUncheckedCreateWithoutLine_itemInput
        >
      | LineItemQuoteCreateWithoutLine_itemInput[]
      | LineItemQuoteUncheckedCreateWithoutLine_itemInput[];
    connectOrCreate?:
      | LineItemQuoteCreateOrConnectWithoutLine_itemInput
      | LineItemQuoteCreateOrConnectWithoutLine_itemInput[];
    createMany?: LineItemQuoteCreateManyLine_itemInputEnvelope;
    connect?: LineItemQuoteWhereUniqueInput | LineItemQuoteWhereUniqueInput[];
  };

  export type LineItemInvoiceCreateNestedManyWithoutLine_itemInput = {
    create?:
      | XOR<
          LineItemInvoiceCreateWithoutLine_itemInput,
          LineItemInvoiceUncheckedCreateWithoutLine_itemInput
        >
      | LineItemInvoiceCreateWithoutLine_itemInput[]
      | LineItemInvoiceUncheckedCreateWithoutLine_itemInput[];
    connectOrCreate?:
      | LineItemInvoiceCreateOrConnectWithoutLine_itemInput
      | LineItemInvoiceCreateOrConnectWithoutLine_itemInput[];
    createMany?: LineItemInvoiceCreateManyLine_itemInputEnvelope;
    connect?:
      | LineItemInvoiceWhereUniqueInput
      | LineItemInvoiceWhereUniqueInput[];
  };

  export type LineItemJobCreateNestedManyWithoutLine_itemInput = {
    create?:
      | XOR<
          LineItemJobCreateWithoutLine_itemInput,
          LineItemJobUncheckedCreateWithoutLine_itemInput
        >
      | LineItemJobCreateWithoutLine_itemInput[]
      | LineItemJobUncheckedCreateWithoutLine_itemInput[];
    connectOrCreate?:
      | LineItemJobCreateOrConnectWithoutLine_itemInput
      | LineItemJobCreateOrConnectWithoutLine_itemInput[];
    createMany?: LineItemJobCreateManyLine_itemInputEnvelope;
    connect?: LineItemJobWhereUniqueInput | LineItemJobWhereUniqueInput[];
  };

  export type LineItemQuoteUncheckedCreateNestedManyWithoutLine_itemInput = {
    create?:
      | XOR<
          LineItemQuoteCreateWithoutLine_itemInput,
          LineItemQuoteUncheckedCreateWithoutLine_itemInput
        >
      | LineItemQuoteCreateWithoutLine_itemInput[]
      | LineItemQuoteUncheckedCreateWithoutLine_itemInput[];
    connectOrCreate?:
      | LineItemQuoteCreateOrConnectWithoutLine_itemInput
      | LineItemQuoteCreateOrConnectWithoutLine_itemInput[];
    createMany?: LineItemQuoteCreateManyLine_itemInputEnvelope;
    connect?: LineItemQuoteWhereUniqueInput | LineItemQuoteWhereUniqueInput[];
  };

  export type LineItemInvoiceUncheckedCreateNestedManyWithoutLine_itemInput = {
    create?:
      | XOR<
          LineItemInvoiceCreateWithoutLine_itemInput,
          LineItemInvoiceUncheckedCreateWithoutLine_itemInput
        >
      | LineItemInvoiceCreateWithoutLine_itemInput[]
      | LineItemInvoiceUncheckedCreateWithoutLine_itemInput[];
    connectOrCreate?:
      | LineItemInvoiceCreateOrConnectWithoutLine_itemInput
      | LineItemInvoiceCreateOrConnectWithoutLine_itemInput[];
    createMany?: LineItemInvoiceCreateManyLine_itemInputEnvelope;
    connect?:
      | LineItemInvoiceWhereUniqueInput
      | LineItemInvoiceWhereUniqueInput[];
  };

  export type LineItemJobUncheckedCreateNestedManyWithoutLine_itemInput = {
    create?:
      | XOR<
          LineItemJobCreateWithoutLine_itemInput,
          LineItemJobUncheckedCreateWithoutLine_itemInput
        >
      | LineItemJobCreateWithoutLine_itemInput[]
      | LineItemJobUncheckedCreateWithoutLine_itemInput[];
    connectOrCreate?:
      | LineItemJobCreateOrConnectWithoutLine_itemInput
      | LineItemJobCreateOrConnectWithoutLine_itemInput[];
    createMany?: LineItemJobCreateManyLine_itemInputEnvelope;
    connect?: LineItemJobWhereUniqueInput | LineItemJobWhereUniqueInput[];
  };

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null;
    increment?: number;
    decrement?: number;
    multiply?: number;
    divide?: number;
  };

  export type LineItemQuoteUpdateManyWithoutLine_itemNestedInput = {
    create?:
      | XOR<
          LineItemQuoteCreateWithoutLine_itemInput,
          LineItemQuoteUncheckedCreateWithoutLine_itemInput
        >
      | LineItemQuoteCreateWithoutLine_itemInput[]
      | LineItemQuoteUncheckedCreateWithoutLine_itemInput[];
    connectOrCreate?:
      | LineItemQuoteCreateOrConnectWithoutLine_itemInput
      | LineItemQuoteCreateOrConnectWithoutLine_itemInput[];
    upsert?:
      | LineItemQuoteUpsertWithWhereUniqueWithoutLine_itemInput
      | LineItemQuoteUpsertWithWhereUniqueWithoutLine_itemInput[];
    createMany?: LineItemQuoteCreateManyLine_itemInputEnvelope;
    set?: LineItemQuoteWhereUniqueInput | LineItemQuoteWhereUniqueInput[];
    disconnect?:
      | LineItemQuoteWhereUniqueInput
      | LineItemQuoteWhereUniqueInput[];
    delete?: LineItemQuoteWhereUniqueInput | LineItemQuoteWhereUniqueInput[];
    connect?: LineItemQuoteWhereUniqueInput | LineItemQuoteWhereUniqueInput[];
    update?:
      | LineItemQuoteUpdateWithWhereUniqueWithoutLine_itemInput
      | LineItemQuoteUpdateWithWhereUniqueWithoutLine_itemInput[];
    updateMany?:
      | LineItemQuoteUpdateManyWithWhereWithoutLine_itemInput
      | LineItemQuoteUpdateManyWithWhereWithoutLine_itemInput[];
    deleteMany?:
      | LineItemQuoteScalarWhereInput
      | LineItemQuoteScalarWhereInput[];
  };

  export type LineItemInvoiceUpdateManyWithoutLine_itemNestedInput = {
    create?:
      | XOR<
          LineItemInvoiceCreateWithoutLine_itemInput,
          LineItemInvoiceUncheckedCreateWithoutLine_itemInput
        >
      | LineItemInvoiceCreateWithoutLine_itemInput[]
      | LineItemInvoiceUncheckedCreateWithoutLine_itemInput[];
    connectOrCreate?:
      | LineItemInvoiceCreateOrConnectWithoutLine_itemInput
      | LineItemInvoiceCreateOrConnectWithoutLine_itemInput[];
    upsert?:
      | LineItemInvoiceUpsertWithWhereUniqueWithoutLine_itemInput
      | LineItemInvoiceUpsertWithWhereUniqueWithoutLine_itemInput[];
    createMany?: LineItemInvoiceCreateManyLine_itemInputEnvelope;
    set?: LineItemInvoiceWhereUniqueInput | LineItemInvoiceWhereUniqueInput[];
    disconnect?:
      | LineItemInvoiceWhereUniqueInput
      | LineItemInvoiceWhereUniqueInput[];
    delete?:
      | LineItemInvoiceWhereUniqueInput
      | LineItemInvoiceWhereUniqueInput[];
    connect?:
      | LineItemInvoiceWhereUniqueInput
      | LineItemInvoiceWhereUniqueInput[];
    update?:
      | LineItemInvoiceUpdateWithWhereUniqueWithoutLine_itemInput
      | LineItemInvoiceUpdateWithWhereUniqueWithoutLine_itemInput[];
    updateMany?:
      | LineItemInvoiceUpdateManyWithWhereWithoutLine_itemInput
      | LineItemInvoiceUpdateManyWithWhereWithoutLine_itemInput[];
    deleteMany?:
      | LineItemInvoiceScalarWhereInput
      | LineItemInvoiceScalarWhereInput[];
  };

  export type LineItemJobUpdateManyWithoutLine_itemNestedInput = {
    create?:
      | XOR<
          LineItemJobCreateWithoutLine_itemInput,
          LineItemJobUncheckedCreateWithoutLine_itemInput
        >
      | LineItemJobCreateWithoutLine_itemInput[]
      | LineItemJobUncheckedCreateWithoutLine_itemInput[];
    connectOrCreate?:
      | LineItemJobCreateOrConnectWithoutLine_itemInput
      | LineItemJobCreateOrConnectWithoutLine_itemInput[];
    upsert?:
      | LineItemJobUpsertWithWhereUniqueWithoutLine_itemInput
      | LineItemJobUpsertWithWhereUniqueWithoutLine_itemInput[];
    createMany?: LineItemJobCreateManyLine_itemInputEnvelope;
    set?: LineItemJobWhereUniqueInput | LineItemJobWhereUniqueInput[];
    disconnect?: LineItemJobWhereUniqueInput | LineItemJobWhereUniqueInput[];
    delete?: LineItemJobWhereUniqueInput | LineItemJobWhereUniqueInput[];
    connect?: LineItemJobWhereUniqueInput | LineItemJobWhereUniqueInput[];
    update?:
      | LineItemJobUpdateWithWhereUniqueWithoutLine_itemInput
      | LineItemJobUpdateWithWhereUniqueWithoutLine_itemInput[];
    updateMany?:
      | LineItemJobUpdateManyWithWhereWithoutLine_itemInput
      | LineItemJobUpdateManyWithWhereWithoutLine_itemInput[];
    deleteMany?: LineItemJobScalarWhereInput | LineItemJobScalarWhereInput[];
  };

  export type LineItemQuoteUncheckedUpdateManyWithoutLine_itemNestedInput = {
    create?:
      | XOR<
          LineItemQuoteCreateWithoutLine_itemInput,
          LineItemQuoteUncheckedCreateWithoutLine_itemInput
        >
      | LineItemQuoteCreateWithoutLine_itemInput[]
      | LineItemQuoteUncheckedCreateWithoutLine_itemInput[];
    connectOrCreate?:
      | LineItemQuoteCreateOrConnectWithoutLine_itemInput
      | LineItemQuoteCreateOrConnectWithoutLine_itemInput[];
    upsert?:
      | LineItemQuoteUpsertWithWhereUniqueWithoutLine_itemInput
      | LineItemQuoteUpsertWithWhereUniqueWithoutLine_itemInput[];
    createMany?: LineItemQuoteCreateManyLine_itemInputEnvelope;
    set?: LineItemQuoteWhereUniqueInput | LineItemQuoteWhereUniqueInput[];
    disconnect?:
      | LineItemQuoteWhereUniqueInput
      | LineItemQuoteWhereUniqueInput[];
    delete?: LineItemQuoteWhereUniqueInput | LineItemQuoteWhereUniqueInput[];
    connect?: LineItemQuoteWhereUniqueInput | LineItemQuoteWhereUniqueInput[];
    update?:
      | LineItemQuoteUpdateWithWhereUniqueWithoutLine_itemInput
      | LineItemQuoteUpdateWithWhereUniqueWithoutLine_itemInput[];
    updateMany?:
      | LineItemQuoteUpdateManyWithWhereWithoutLine_itemInput
      | LineItemQuoteUpdateManyWithWhereWithoutLine_itemInput[];
    deleteMany?:
      | LineItemQuoteScalarWhereInput
      | LineItemQuoteScalarWhereInput[];
  };

  export type LineItemInvoiceUncheckedUpdateManyWithoutLine_itemNestedInput = {
    create?:
      | XOR<
          LineItemInvoiceCreateWithoutLine_itemInput,
          LineItemInvoiceUncheckedCreateWithoutLine_itemInput
        >
      | LineItemInvoiceCreateWithoutLine_itemInput[]
      | LineItemInvoiceUncheckedCreateWithoutLine_itemInput[];
    connectOrCreate?:
      | LineItemInvoiceCreateOrConnectWithoutLine_itemInput
      | LineItemInvoiceCreateOrConnectWithoutLine_itemInput[];
    upsert?:
      | LineItemInvoiceUpsertWithWhereUniqueWithoutLine_itemInput
      | LineItemInvoiceUpsertWithWhereUniqueWithoutLine_itemInput[];
    createMany?: LineItemInvoiceCreateManyLine_itemInputEnvelope;
    set?: LineItemInvoiceWhereUniqueInput | LineItemInvoiceWhereUniqueInput[];
    disconnect?:
      | LineItemInvoiceWhereUniqueInput
      | LineItemInvoiceWhereUniqueInput[];
    delete?:
      | LineItemInvoiceWhereUniqueInput
      | LineItemInvoiceWhereUniqueInput[];
    connect?:
      | LineItemInvoiceWhereUniqueInput
      | LineItemInvoiceWhereUniqueInput[];
    update?:
      | LineItemInvoiceUpdateWithWhereUniqueWithoutLine_itemInput
      | LineItemInvoiceUpdateWithWhereUniqueWithoutLine_itemInput[];
    updateMany?:
      | LineItemInvoiceUpdateManyWithWhereWithoutLine_itemInput
      | LineItemInvoiceUpdateManyWithWhereWithoutLine_itemInput[];
    deleteMany?:
      | LineItemInvoiceScalarWhereInput
      | LineItemInvoiceScalarWhereInput[];
  };

  export type LineItemJobUncheckedUpdateManyWithoutLine_itemNestedInput = {
    create?:
      | XOR<
          LineItemJobCreateWithoutLine_itemInput,
          LineItemJobUncheckedCreateWithoutLine_itemInput
        >
      | LineItemJobCreateWithoutLine_itemInput[]
      | LineItemJobUncheckedCreateWithoutLine_itemInput[];
    connectOrCreate?:
      | LineItemJobCreateOrConnectWithoutLine_itemInput
      | LineItemJobCreateOrConnectWithoutLine_itemInput[];
    upsert?:
      | LineItemJobUpsertWithWhereUniqueWithoutLine_itemInput
      | LineItemJobUpsertWithWhereUniqueWithoutLine_itemInput[];
    createMany?: LineItemJobCreateManyLine_itemInputEnvelope;
    set?: LineItemJobWhereUniqueInput | LineItemJobWhereUniqueInput[];
    disconnect?: LineItemJobWhereUniqueInput | LineItemJobWhereUniqueInput[];
    delete?: LineItemJobWhereUniqueInput | LineItemJobWhereUniqueInput[];
    connect?: LineItemJobWhereUniqueInput | LineItemJobWhereUniqueInput[];
    update?:
      | LineItemJobUpdateWithWhereUniqueWithoutLine_itemInput
      | LineItemJobUpdateWithWhereUniqueWithoutLine_itemInput[];
    updateMany?:
      | LineItemJobUpdateManyWithWhereWithoutLine_itemInput
      | LineItemJobUpdateManyWithWhereWithoutLine_itemInput[];
    deleteMany?: LineItemJobScalarWhereInput | LineItemJobScalarWhereInput[];
  };

  export type ClientsCreateNestedOneWithoutQuotesInput = {
    create?: XOR<
      ClientsCreateWithoutQuotesInput,
      ClientsUncheckedCreateWithoutQuotesInput
    >;
    connectOrCreate?: ClientsCreateOrConnectWithoutQuotesInput;
    connect?: ClientsWhereUniqueInput;
  };

  export type LineItemQuoteCreateNestedManyWithoutQuoteInput = {
    create?:
      | XOR<
          LineItemQuoteCreateWithoutQuoteInput,
          LineItemQuoteUncheckedCreateWithoutQuoteInput
        >
      | LineItemQuoteCreateWithoutQuoteInput[]
      | LineItemQuoteUncheckedCreateWithoutQuoteInput[];
    connectOrCreate?:
      | LineItemQuoteCreateOrConnectWithoutQuoteInput
      | LineItemQuoteCreateOrConnectWithoutQuoteInput[];
    createMany?: LineItemQuoteCreateManyQuoteInputEnvelope;
    connect?: LineItemQuoteWhereUniqueInput | LineItemQuoteWhereUniqueInput[];
  };

  export type TaxesCreateNestedOneWithoutQuotesInput = {
    create?: XOR<
      TaxesCreateWithoutQuotesInput,
      TaxesUncheckedCreateWithoutQuotesInput
    >;
    connectOrCreate?: TaxesCreateOrConnectWithoutQuotesInput;
    connect?: TaxesWhereUniqueInput;
  };

  export type QuoteRequestCreateNestedManyWithoutQuoteInput = {
    create?:
      | XOR<
          QuoteRequestCreateWithoutQuoteInput,
          QuoteRequestUncheckedCreateWithoutQuoteInput
        >
      | QuoteRequestCreateWithoutQuoteInput[]
      | QuoteRequestUncheckedCreateWithoutQuoteInput[];
    connectOrCreate?:
      | QuoteRequestCreateOrConnectWithoutQuoteInput
      | QuoteRequestCreateOrConnectWithoutQuoteInput[];
    createMany?: QuoteRequestCreateManyQuoteInputEnvelope;
    connect?: QuoteRequestWhereUniqueInput | QuoteRequestWhereUniqueInput[];
  };

  export type JobQuoteCreateNestedManyWithoutQuoteInput = {
    create?:
      | XOR<
          JobQuoteCreateWithoutQuoteInput,
          JobQuoteUncheckedCreateWithoutQuoteInput
        >
      | JobQuoteCreateWithoutQuoteInput[]
      | JobQuoteUncheckedCreateWithoutQuoteInput[];
    connectOrCreate?:
      | JobQuoteCreateOrConnectWithoutQuoteInput
      | JobQuoteCreateOrConnectWithoutQuoteInput[];
    createMany?: JobQuoteCreateManyQuoteInputEnvelope;
    connect?: JobQuoteWhereUniqueInput | JobQuoteWhereUniqueInput[];
  };

  export type UsersCreateNestedOneWithoutQuotesInput = {
    create?: XOR<
      UsersCreateWithoutQuotesInput,
      UsersUncheckedCreateWithoutQuotesInput
    >;
    connectOrCreate?: UsersCreateOrConnectWithoutQuotesInput;
    connect?: UsersWhereUniqueInput;
  };

  export type LineItemQuoteUncheckedCreateNestedManyWithoutQuoteInput = {
    create?:
      | XOR<
          LineItemQuoteCreateWithoutQuoteInput,
          LineItemQuoteUncheckedCreateWithoutQuoteInput
        >
      | LineItemQuoteCreateWithoutQuoteInput[]
      | LineItemQuoteUncheckedCreateWithoutQuoteInput[];
    connectOrCreate?:
      | LineItemQuoteCreateOrConnectWithoutQuoteInput
      | LineItemQuoteCreateOrConnectWithoutQuoteInput[];
    createMany?: LineItemQuoteCreateManyQuoteInputEnvelope;
    connect?: LineItemQuoteWhereUniqueInput | LineItemQuoteWhereUniqueInput[];
  };

  export type QuoteRequestUncheckedCreateNestedManyWithoutQuoteInput = {
    create?:
      | XOR<
          QuoteRequestCreateWithoutQuoteInput,
          QuoteRequestUncheckedCreateWithoutQuoteInput
        >
      | QuoteRequestCreateWithoutQuoteInput[]
      | QuoteRequestUncheckedCreateWithoutQuoteInput[];
    connectOrCreate?:
      | QuoteRequestCreateOrConnectWithoutQuoteInput
      | QuoteRequestCreateOrConnectWithoutQuoteInput[];
    createMany?: QuoteRequestCreateManyQuoteInputEnvelope;
    connect?: QuoteRequestWhereUniqueInput | QuoteRequestWhereUniqueInput[];
  };

  export type JobQuoteUncheckedCreateNestedManyWithoutQuoteInput = {
    create?:
      | XOR<
          JobQuoteCreateWithoutQuoteInput,
          JobQuoteUncheckedCreateWithoutQuoteInput
        >
      | JobQuoteCreateWithoutQuoteInput[]
      | JobQuoteUncheckedCreateWithoutQuoteInput[];
    connectOrCreate?:
      | JobQuoteCreateOrConnectWithoutQuoteInput
      | JobQuoteCreateOrConnectWithoutQuoteInput[];
    createMany?: JobQuoteCreateManyQuoteInputEnvelope;
    connect?: JobQuoteWhereUniqueInput | JobQuoteWhereUniqueInput[];
  };

  export type ClientsUpdateOneRequiredWithoutQuotesNestedInput = {
    create?: XOR<
      ClientsCreateWithoutQuotesInput,
      ClientsUncheckedCreateWithoutQuotesInput
    >;
    connectOrCreate?: ClientsCreateOrConnectWithoutQuotesInput;
    upsert?: ClientsUpsertWithoutQuotesInput;
    connect?: ClientsWhereUniqueInput;
    update?: XOR<
      XOR<
        ClientsUpdateToOneWithWhereWithoutQuotesInput,
        ClientsUpdateWithoutQuotesInput
      >,
      ClientsUncheckedUpdateWithoutQuotesInput
    >;
  };

  export type LineItemQuoteUpdateManyWithoutQuoteNestedInput = {
    create?:
      | XOR<
          LineItemQuoteCreateWithoutQuoteInput,
          LineItemQuoteUncheckedCreateWithoutQuoteInput
        >
      | LineItemQuoteCreateWithoutQuoteInput[]
      | LineItemQuoteUncheckedCreateWithoutQuoteInput[];
    connectOrCreate?:
      | LineItemQuoteCreateOrConnectWithoutQuoteInput
      | LineItemQuoteCreateOrConnectWithoutQuoteInput[];
    upsert?:
      | LineItemQuoteUpsertWithWhereUniqueWithoutQuoteInput
      | LineItemQuoteUpsertWithWhereUniqueWithoutQuoteInput[];
    createMany?: LineItemQuoteCreateManyQuoteInputEnvelope;
    set?: LineItemQuoteWhereUniqueInput | LineItemQuoteWhereUniqueInput[];
    disconnect?:
      | LineItemQuoteWhereUniqueInput
      | LineItemQuoteWhereUniqueInput[];
    delete?: LineItemQuoteWhereUniqueInput | LineItemQuoteWhereUniqueInput[];
    connect?: LineItemQuoteWhereUniqueInput | LineItemQuoteWhereUniqueInput[];
    update?:
      | LineItemQuoteUpdateWithWhereUniqueWithoutQuoteInput
      | LineItemQuoteUpdateWithWhereUniqueWithoutQuoteInput[];
    updateMany?:
      | LineItemQuoteUpdateManyWithWhereWithoutQuoteInput
      | LineItemQuoteUpdateManyWithWhereWithoutQuoteInput[];
    deleteMany?:
      | LineItemQuoteScalarWhereInput
      | LineItemQuoteScalarWhereInput[];
  };

  export type TaxesUpdateOneWithoutQuotesNestedInput = {
    create?: XOR<
      TaxesCreateWithoutQuotesInput,
      TaxesUncheckedCreateWithoutQuotesInput
    >;
    connectOrCreate?: TaxesCreateOrConnectWithoutQuotesInput;
    upsert?: TaxesUpsertWithoutQuotesInput;
    disconnect?: TaxesWhereInput | boolean;
    delete?: TaxesWhereInput | boolean;
    connect?: TaxesWhereUniqueInput;
    update?: XOR<
      XOR<
        TaxesUpdateToOneWithWhereWithoutQuotesInput,
        TaxesUpdateWithoutQuotesInput
      >,
      TaxesUncheckedUpdateWithoutQuotesInput
    >;
  };

  export type QuoteRequestUpdateManyWithoutQuoteNestedInput = {
    create?:
      | XOR<
          QuoteRequestCreateWithoutQuoteInput,
          QuoteRequestUncheckedCreateWithoutQuoteInput
        >
      | QuoteRequestCreateWithoutQuoteInput[]
      | QuoteRequestUncheckedCreateWithoutQuoteInput[];
    connectOrCreate?:
      | QuoteRequestCreateOrConnectWithoutQuoteInput
      | QuoteRequestCreateOrConnectWithoutQuoteInput[];
    upsert?:
      | QuoteRequestUpsertWithWhereUniqueWithoutQuoteInput
      | QuoteRequestUpsertWithWhereUniqueWithoutQuoteInput[];
    createMany?: QuoteRequestCreateManyQuoteInputEnvelope;
    set?: QuoteRequestWhereUniqueInput | QuoteRequestWhereUniqueInput[];
    disconnect?: QuoteRequestWhereUniqueInput | QuoteRequestWhereUniqueInput[];
    delete?: QuoteRequestWhereUniqueInput | QuoteRequestWhereUniqueInput[];
    connect?: QuoteRequestWhereUniqueInput | QuoteRequestWhereUniqueInput[];
    update?:
      | QuoteRequestUpdateWithWhereUniqueWithoutQuoteInput
      | QuoteRequestUpdateWithWhereUniqueWithoutQuoteInput[];
    updateMany?:
      | QuoteRequestUpdateManyWithWhereWithoutQuoteInput
      | QuoteRequestUpdateManyWithWhereWithoutQuoteInput[];
    deleteMany?: QuoteRequestScalarWhereInput | QuoteRequestScalarWhereInput[];
  };

  export type JobQuoteUpdateManyWithoutQuoteNestedInput = {
    create?:
      | XOR<
          JobQuoteCreateWithoutQuoteInput,
          JobQuoteUncheckedCreateWithoutQuoteInput
        >
      | JobQuoteCreateWithoutQuoteInput[]
      | JobQuoteUncheckedCreateWithoutQuoteInput[];
    connectOrCreate?:
      | JobQuoteCreateOrConnectWithoutQuoteInput
      | JobQuoteCreateOrConnectWithoutQuoteInput[];
    upsert?:
      | JobQuoteUpsertWithWhereUniqueWithoutQuoteInput
      | JobQuoteUpsertWithWhereUniqueWithoutQuoteInput[];
    createMany?: JobQuoteCreateManyQuoteInputEnvelope;
    set?: JobQuoteWhereUniqueInput | JobQuoteWhereUniqueInput[];
    disconnect?: JobQuoteWhereUniqueInput | JobQuoteWhereUniqueInput[];
    delete?: JobQuoteWhereUniqueInput | JobQuoteWhereUniqueInput[];
    connect?: JobQuoteWhereUniqueInput | JobQuoteWhereUniqueInput[];
    update?:
      | JobQuoteUpdateWithWhereUniqueWithoutQuoteInput
      | JobQuoteUpdateWithWhereUniqueWithoutQuoteInput[];
    updateMany?:
      | JobQuoteUpdateManyWithWhereWithoutQuoteInput
      | JobQuoteUpdateManyWithWhereWithoutQuoteInput[];
    deleteMany?: JobQuoteScalarWhereInput | JobQuoteScalarWhereInput[];
  };

  export type UsersUpdateOneRequiredWithoutQuotesNestedInput = {
    create?: XOR<
      UsersCreateWithoutQuotesInput,
      UsersUncheckedCreateWithoutQuotesInput
    >;
    connectOrCreate?: UsersCreateOrConnectWithoutQuotesInput;
    upsert?: UsersUpsertWithoutQuotesInput;
    connect?: UsersWhereUniqueInput;
    update?: XOR<
      XOR<
        UsersUpdateToOneWithWhereWithoutQuotesInput,
        UsersUpdateWithoutQuotesInput
      >,
      UsersUncheckedUpdateWithoutQuotesInput
    >;
  };

  export type LineItemQuoteUncheckedUpdateManyWithoutQuoteNestedInput = {
    create?:
      | XOR<
          LineItemQuoteCreateWithoutQuoteInput,
          LineItemQuoteUncheckedCreateWithoutQuoteInput
        >
      | LineItemQuoteCreateWithoutQuoteInput[]
      | LineItemQuoteUncheckedCreateWithoutQuoteInput[];
    connectOrCreate?:
      | LineItemQuoteCreateOrConnectWithoutQuoteInput
      | LineItemQuoteCreateOrConnectWithoutQuoteInput[];
    upsert?:
      | LineItemQuoteUpsertWithWhereUniqueWithoutQuoteInput
      | LineItemQuoteUpsertWithWhereUniqueWithoutQuoteInput[];
    createMany?: LineItemQuoteCreateManyQuoteInputEnvelope;
    set?: LineItemQuoteWhereUniqueInput | LineItemQuoteWhereUniqueInput[];
    disconnect?:
      | LineItemQuoteWhereUniqueInput
      | LineItemQuoteWhereUniqueInput[];
    delete?: LineItemQuoteWhereUniqueInput | LineItemQuoteWhereUniqueInput[];
    connect?: LineItemQuoteWhereUniqueInput | LineItemQuoteWhereUniqueInput[];
    update?:
      | LineItemQuoteUpdateWithWhereUniqueWithoutQuoteInput
      | LineItemQuoteUpdateWithWhereUniqueWithoutQuoteInput[];
    updateMany?:
      | LineItemQuoteUpdateManyWithWhereWithoutQuoteInput
      | LineItemQuoteUpdateManyWithWhereWithoutQuoteInput[];
    deleteMany?:
      | LineItemQuoteScalarWhereInput
      | LineItemQuoteScalarWhereInput[];
  };

  export type QuoteRequestUncheckedUpdateManyWithoutQuoteNestedInput = {
    create?:
      | XOR<
          QuoteRequestCreateWithoutQuoteInput,
          QuoteRequestUncheckedCreateWithoutQuoteInput
        >
      | QuoteRequestCreateWithoutQuoteInput[]
      | QuoteRequestUncheckedCreateWithoutQuoteInput[];
    connectOrCreate?:
      | QuoteRequestCreateOrConnectWithoutQuoteInput
      | QuoteRequestCreateOrConnectWithoutQuoteInput[];
    upsert?:
      | QuoteRequestUpsertWithWhereUniqueWithoutQuoteInput
      | QuoteRequestUpsertWithWhereUniqueWithoutQuoteInput[];
    createMany?: QuoteRequestCreateManyQuoteInputEnvelope;
    set?: QuoteRequestWhereUniqueInput | QuoteRequestWhereUniqueInput[];
    disconnect?: QuoteRequestWhereUniqueInput | QuoteRequestWhereUniqueInput[];
    delete?: QuoteRequestWhereUniqueInput | QuoteRequestWhereUniqueInput[];
    connect?: QuoteRequestWhereUniqueInput | QuoteRequestWhereUniqueInput[];
    update?:
      | QuoteRequestUpdateWithWhereUniqueWithoutQuoteInput
      | QuoteRequestUpdateWithWhereUniqueWithoutQuoteInput[];
    updateMany?:
      | QuoteRequestUpdateManyWithWhereWithoutQuoteInput
      | QuoteRequestUpdateManyWithWhereWithoutQuoteInput[];
    deleteMany?: QuoteRequestScalarWhereInput | QuoteRequestScalarWhereInput[];
  };

  export type JobQuoteUncheckedUpdateManyWithoutQuoteNestedInput = {
    create?:
      | XOR<
          JobQuoteCreateWithoutQuoteInput,
          JobQuoteUncheckedCreateWithoutQuoteInput
        >
      | JobQuoteCreateWithoutQuoteInput[]
      | JobQuoteUncheckedCreateWithoutQuoteInput[];
    connectOrCreate?:
      | JobQuoteCreateOrConnectWithoutQuoteInput
      | JobQuoteCreateOrConnectWithoutQuoteInput[];
    upsert?:
      | JobQuoteUpsertWithWhereUniqueWithoutQuoteInput
      | JobQuoteUpsertWithWhereUniqueWithoutQuoteInput[];
    createMany?: JobQuoteCreateManyQuoteInputEnvelope;
    set?: JobQuoteWhereUniqueInput | JobQuoteWhereUniqueInput[];
    disconnect?: JobQuoteWhereUniqueInput | JobQuoteWhereUniqueInput[];
    delete?: JobQuoteWhereUniqueInput | JobQuoteWhereUniqueInput[];
    connect?: JobQuoteWhereUniqueInput | JobQuoteWhereUniqueInput[];
    update?:
      | JobQuoteUpdateWithWhereUniqueWithoutQuoteInput
      | JobQuoteUpdateWithWhereUniqueWithoutQuoteInput[];
    updateMany?:
      | JobQuoteUpdateManyWithWhereWithoutQuoteInput
      | JobQuoteUpdateManyWithWhereWithoutQuoteInput[];
    deleteMany?: JobQuoteScalarWhereInput | JobQuoteScalarWhereInput[];
  };

  export type QuotesCreateNestedOneWithoutLine_itemsInput = {
    create?: XOR<
      QuotesCreateWithoutLine_itemsInput,
      QuotesUncheckedCreateWithoutLine_itemsInput
    >;
    connectOrCreate?: QuotesCreateOrConnectWithoutLine_itemsInput;
    connect?: QuotesWhereUniqueInput;
  };

  export type LineItemsCreateNestedOneWithoutQuotesInput = {
    create?: XOR<
      LineItemsCreateWithoutQuotesInput,
      LineItemsUncheckedCreateWithoutQuotesInput
    >;
    connectOrCreate?: LineItemsCreateOrConnectWithoutQuotesInput;
    connect?: LineItemsWhereUniqueInput;
  };

  export type QuotesUpdateOneRequiredWithoutLine_itemsNestedInput = {
    create?: XOR<
      QuotesCreateWithoutLine_itemsInput,
      QuotesUncheckedCreateWithoutLine_itemsInput
    >;
    connectOrCreate?: QuotesCreateOrConnectWithoutLine_itemsInput;
    upsert?: QuotesUpsertWithoutLine_itemsInput;
    connect?: QuotesWhereUniqueInput;
    update?: XOR<
      XOR<
        QuotesUpdateToOneWithWhereWithoutLine_itemsInput,
        QuotesUpdateWithoutLine_itemsInput
      >,
      QuotesUncheckedUpdateWithoutLine_itemsInput
    >;
  };

  export type LineItemsUpdateOneRequiredWithoutQuotesNestedInput = {
    create?: XOR<
      LineItemsCreateWithoutQuotesInput,
      LineItemsUncheckedCreateWithoutQuotesInput
    >;
    connectOrCreate?: LineItemsCreateOrConnectWithoutQuotesInput;
    upsert?: LineItemsUpsertWithoutQuotesInput;
    connect?: LineItemsWhereUniqueInput;
    update?: XOR<
      XOR<
        LineItemsUpdateToOneWithWhereWithoutQuotesInput,
        LineItemsUpdateWithoutQuotesInput
      >,
      LineItemsUncheckedUpdateWithoutQuotesInput
    >;
  };

  export type QuotesCreateNestedOneWithoutRequestsInput = {
    create?: XOR<
      QuotesCreateWithoutRequestsInput,
      QuotesUncheckedCreateWithoutRequestsInput
    >;
    connectOrCreate?: QuotesCreateOrConnectWithoutRequestsInput;
    connect?: QuotesWhereUniqueInput;
  };

  export type RequestsCreateNestedOneWithoutQuotesInput = {
    create?: XOR<
      RequestsCreateWithoutQuotesInput,
      RequestsUncheckedCreateWithoutQuotesInput
    >;
    connectOrCreate?: RequestsCreateOrConnectWithoutQuotesInput;
    connect?: RequestsWhereUniqueInput;
  };

  export type QuotesUpdateOneRequiredWithoutRequestsNestedInput = {
    create?: XOR<
      QuotesCreateWithoutRequestsInput,
      QuotesUncheckedCreateWithoutRequestsInput
    >;
    connectOrCreate?: QuotesCreateOrConnectWithoutRequestsInput;
    upsert?: QuotesUpsertWithoutRequestsInput;
    connect?: QuotesWhereUniqueInput;
    update?: XOR<
      XOR<
        QuotesUpdateToOneWithWhereWithoutRequestsInput,
        QuotesUpdateWithoutRequestsInput
      >,
      QuotesUncheckedUpdateWithoutRequestsInput
    >;
  };

  export type RequestsUpdateOneRequiredWithoutQuotesNestedInput = {
    create?: XOR<
      RequestsCreateWithoutQuotesInput,
      RequestsUncheckedCreateWithoutQuotesInput
    >;
    connectOrCreate?: RequestsCreateOrConnectWithoutQuotesInput;
    upsert?: RequestsUpsertWithoutQuotesInput;
    connect?: RequestsWhereUniqueInput;
    update?: XOR<
      XOR<
        RequestsUpdateToOneWithWhereWithoutQuotesInput,
        RequestsUpdateWithoutQuotesInput
      >,
      RequestsUncheckedUpdateWithoutQuotesInput
    >;
  };

  export type ClientsCreateNestedOneWithoutJobsInput = {
    create?: XOR<
      ClientsCreateWithoutJobsInput,
      ClientsUncheckedCreateWithoutJobsInput
    >;
    connectOrCreate?: ClientsCreateOrConnectWithoutJobsInput;
    connect?: ClientsWhereUniqueInput;
  };

  export type LineItemJobCreateNestedManyWithoutJobInput = {
    create?:
      | XOR<
          LineItemJobCreateWithoutJobInput,
          LineItemJobUncheckedCreateWithoutJobInput
        >
      | LineItemJobCreateWithoutJobInput[]
      | LineItemJobUncheckedCreateWithoutJobInput[];
    connectOrCreate?:
      | LineItemJobCreateOrConnectWithoutJobInput
      | LineItemJobCreateOrConnectWithoutJobInput[];
    createMany?: LineItemJobCreateManyJobInputEnvelope;
    connect?: LineItemJobWhereUniqueInput | LineItemJobWhereUniqueInput[];
  };

  export type JobRequestCreateNestedManyWithoutJobInput = {
    create?:
      | XOR<
          JobRequestCreateWithoutJobInput,
          JobRequestUncheckedCreateWithoutJobInput
        >
      | JobRequestCreateWithoutJobInput[]
      | JobRequestUncheckedCreateWithoutJobInput[];
    connectOrCreate?:
      | JobRequestCreateOrConnectWithoutJobInput
      | JobRequestCreateOrConnectWithoutJobInput[];
    createMany?: JobRequestCreateManyJobInputEnvelope;
    connect?: JobRequestWhereUniqueInput | JobRequestWhereUniqueInput[];
  };

  export type JobQuoteCreateNestedManyWithoutJobInput = {
    create?:
      | XOR<
          JobQuoteCreateWithoutJobInput,
          JobQuoteUncheckedCreateWithoutJobInput
        >
      | JobQuoteCreateWithoutJobInput[]
      | JobQuoteUncheckedCreateWithoutJobInput[];
    connectOrCreate?:
      | JobQuoteCreateOrConnectWithoutJobInput
      | JobQuoteCreateOrConnectWithoutJobInput[];
    createMany?: JobQuoteCreateManyJobInputEnvelope;
    connect?: JobQuoteWhereUniqueInput | JobQuoteWhereUniqueInput[];
  };

  export type InvoicesCreateNestedManyWithoutJobInput = {
    create?:
      | XOR<
          InvoicesCreateWithoutJobInput,
          InvoicesUncheckedCreateWithoutJobInput
        >
      | InvoicesCreateWithoutJobInput[]
      | InvoicesUncheckedCreateWithoutJobInput[];
    connectOrCreate?:
      | InvoicesCreateOrConnectWithoutJobInput
      | InvoicesCreateOrConnectWithoutJobInput[];
    createMany?: InvoicesCreateManyJobInputEnvelope;
    connect?: InvoicesWhereUniqueInput | InvoicesWhereUniqueInput[];
  };

  export type UsersCreateNestedOneWithoutJobsInput = {
    create?: XOR<
      UsersCreateWithoutJobsInput,
      UsersUncheckedCreateWithoutJobsInput
    >;
    connectOrCreate?: UsersCreateOrConnectWithoutJobsInput;
    connect?: UsersWhereUniqueInput;
  };

  export type LineItemJobUncheckedCreateNestedManyWithoutJobInput = {
    create?:
      | XOR<
          LineItemJobCreateWithoutJobInput,
          LineItemJobUncheckedCreateWithoutJobInput
        >
      | LineItemJobCreateWithoutJobInput[]
      | LineItemJobUncheckedCreateWithoutJobInput[];
    connectOrCreate?:
      | LineItemJobCreateOrConnectWithoutJobInput
      | LineItemJobCreateOrConnectWithoutJobInput[];
    createMany?: LineItemJobCreateManyJobInputEnvelope;
    connect?: LineItemJobWhereUniqueInput | LineItemJobWhereUniqueInput[];
  };

  export type JobRequestUncheckedCreateNestedManyWithoutJobInput = {
    create?:
      | XOR<
          JobRequestCreateWithoutJobInput,
          JobRequestUncheckedCreateWithoutJobInput
        >
      | JobRequestCreateWithoutJobInput[]
      | JobRequestUncheckedCreateWithoutJobInput[];
    connectOrCreate?:
      | JobRequestCreateOrConnectWithoutJobInput
      | JobRequestCreateOrConnectWithoutJobInput[];
    createMany?: JobRequestCreateManyJobInputEnvelope;
    connect?: JobRequestWhereUniqueInput | JobRequestWhereUniqueInput[];
  };

  export type JobQuoteUncheckedCreateNestedManyWithoutJobInput = {
    create?:
      | XOR<
          JobQuoteCreateWithoutJobInput,
          JobQuoteUncheckedCreateWithoutJobInput
        >
      | JobQuoteCreateWithoutJobInput[]
      | JobQuoteUncheckedCreateWithoutJobInput[];
    connectOrCreate?:
      | JobQuoteCreateOrConnectWithoutJobInput
      | JobQuoteCreateOrConnectWithoutJobInput[];
    createMany?: JobQuoteCreateManyJobInputEnvelope;
    connect?: JobQuoteWhereUniqueInput | JobQuoteWhereUniqueInput[];
  };

  export type InvoicesUncheckedCreateNestedManyWithoutJobInput = {
    create?:
      | XOR<
          InvoicesCreateWithoutJobInput,
          InvoicesUncheckedCreateWithoutJobInput
        >
      | InvoicesCreateWithoutJobInput[]
      | InvoicesUncheckedCreateWithoutJobInput[];
    connectOrCreate?:
      | InvoicesCreateOrConnectWithoutJobInput
      | InvoicesCreateOrConnectWithoutJobInput[];
    createMany?: InvoicesCreateManyJobInputEnvelope;
    connect?: InvoicesWhereUniqueInput | InvoicesWhereUniqueInput[];
  };

  export type ClientsUpdateOneRequiredWithoutJobsNestedInput = {
    create?: XOR<
      ClientsCreateWithoutJobsInput,
      ClientsUncheckedCreateWithoutJobsInput
    >;
    connectOrCreate?: ClientsCreateOrConnectWithoutJobsInput;
    upsert?: ClientsUpsertWithoutJobsInput;
    connect?: ClientsWhereUniqueInput;
    update?: XOR<
      XOR<
        ClientsUpdateToOneWithWhereWithoutJobsInput,
        ClientsUpdateWithoutJobsInput
      >,
      ClientsUncheckedUpdateWithoutJobsInput
    >;
  };

  export type LineItemJobUpdateManyWithoutJobNestedInput = {
    create?:
      | XOR<
          LineItemJobCreateWithoutJobInput,
          LineItemJobUncheckedCreateWithoutJobInput
        >
      | LineItemJobCreateWithoutJobInput[]
      | LineItemJobUncheckedCreateWithoutJobInput[];
    connectOrCreate?:
      | LineItemJobCreateOrConnectWithoutJobInput
      | LineItemJobCreateOrConnectWithoutJobInput[];
    upsert?:
      | LineItemJobUpsertWithWhereUniqueWithoutJobInput
      | LineItemJobUpsertWithWhereUniqueWithoutJobInput[];
    createMany?: LineItemJobCreateManyJobInputEnvelope;
    set?: LineItemJobWhereUniqueInput | LineItemJobWhereUniqueInput[];
    disconnect?: LineItemJobWhereUniqueInput | LineItemJobWhereUniqueInput[];
    delete?: LineItemJobWhereUniqueInput | LineItemJobWhereUniqueInput[];
    connect?: LineItemJobWhereUniqueInput | LineItemJobWhereUniqueInput[];
    update?:
      | LineItemJobUpdateWithWhereUniqueWithoutJobInput
      | LineItemJobUpdateWithWhereUniqueWithoutJobInput[];
    updateMany?:
      | LineItemJobUpdateManyWithWhereWithoutJobInput
      | LineItemJobUpdateManyWithWhereWithoutJobInput[];
    deleteMany?: LineItemJobScalarWhereInput | LineItemJobScalarWhereInput[];
  };

  export type JobRequestUpdateManyWithoutJobNestedInput = {
    create?:
      | XOR<
          JobRequestCreateWithoutJobInput,
          JobRequestUncheckedCreateWithoutJobInput
        >
      | JobRequestCreateWithoutJobInput[]
      | JobRequestUncheckedCreateWithoutJobInput[];
    connectOrCreate?:
      | JobRequestCreateOrConnectWithoutJobInput
      | JobRequestCreateOrConnectWithoutJobInput[];
    upsert?:
      | JobRequestUpsertWithWhereUniqueWithoutJobInput
      | JobRequestUpsertWithWhereUniqueWithoutJobInput[];
    createMany?: JobRequestCreateManyJobInputEnvelope;
    set?: JobRequestWhereUniqueInput | JobRequestWhereUniqueInput[];
    disconnect?: JobRequestWhereUniqueInput | JobRequestWhereUniqueInput[];
    delete?: JobRequestWhereUniqueInput | JobRequestWhereUniqueInput[];
    connect?: JobRequestWhereUniqueInput | JobRequestWhereUniqueInput[];
    update?:
      | JobRequestUpdateWithWhereUniqueWithoutJobInput
      | JobRequestUpdateWithWhereUniqueWithoutJobInput[];
    updateMany?:
      | JobRequestUpdateManyWithWhereWithoutJobInput
      | JobRequestUpdateManyWithWhereWithoutJobInput[];
    deleteMany?: JobRequestScalarWhereInput | JobRequestScalarWhereInput[];
  };

  export type JobQuoteUpdateManyWithoutJobNestedInput = {
    create?:
      | XOR<
          JobQuoteCreateWithoutJobInput,
          JobQuoteUncheckedCreateWithoutJobInput
        >
      | JobQuoteCreateWithoutJobInput[]
      | JobQuoteUncheckedCreateWithoutJobInput[];
    connectOrCreate?:
      | JobQuoteCreateOrConnectWithoutJobInput
      | JobQuoteCreateOrConnectWithoutJobInput[];
    upsert?:
      | JobQuoteUpsertWithWhereUniqueWithoutJobInput
      | JobQuoteUpsertWithWhereUniqueWithoutJobInput[];
    createMany?: JobQuoteCreateManyJobInputEnvelope;
    set?: JobQuoteWhereUniqueInput | JobQuoteWhereUniqueInput[];
    disconnect?: JobQuoteWhereUniqueInput | JobQuoteWhereUniqueInput[];
    delete?: JobQuoteWhereUniqueInput | JobQuoteWhereUniqueInput[];
    connect?: JobQuoteWhereUniqueInput | JobQuoteWhereUniqueInput[];
    update?:
      | JobQuoteUpdateWithWhereUniqueWithoutJobInput
      | JobQuoteUpdateWithWhereUniqueWithoutJobInput[];
    updateMany?:
      | JobQuoteUpdateManyWithWhereWithoutJobInput
      | JobQuoteUpdateManyWithWhereWithoutJobInput[];
    deleteMany?: JobQuoteScalarWhereInput | JobQuoteScalarWhereInput[];
  };

  export type InvoicesUpdateManyWithoutJobNestedInput = {
    create?:
      | XOR<
          InvoicesCreateWithoutJobInput,
          InvoicesUncheckedCreateWithoutJobInput
        >
      | InvoicesCreateWithoutJobInput[]
      | InvoicesUncheckedCreateWithoutJobInput[];
    connectOrCreate?:
      | InvoicesCreateOrConnectWithoutJobInput
      | InvoicesCreateOrConnectWithoutJobInput[];
    upsert?:
      | InvoicesUpsertWithWhereUniqueWithoutJobInput
      | InvoicesUpsertWithWhereUniqueWithoutJobInput[];
    createMany?: InvoicesCreateManyJobInputEnvelope;
    set?: InvoicesWhereUniqueInput | InvoicesWhereUniqueInput[];
    disconnect?: InvoicesWhereUniqueInput | InvoicesWhereUniqueInput[];
    delete?: InvoicesWhereUniqueInput | InvoicesWhereUniqueInput[];
    connect?: InvoicesWhereUniqueInput | InvoicesWhereUniqueInput[];
    update?:
      | InvoicesUpdateWithWhereUniqueWithoutJobInput
      | InvoicesUpdateWithWhereUniqueWithoutJobInput[];
    updateMany?:
      | InvoicesUpdateManyWithWhereWithoutJobInput
      | InvoicesUpdateManyWithWhereWithoutJobInput[];
    deleteMany?: InvoicesScalarWhereInput | InvoicesScalarWhereInput[];
  };

  export type UsersUpdateOneRequiredWithoutJobsNestedInput = {
    create?: XOR<
      UsersCreateWithoutJobsInput,
      UsersUncheckedCreateWithoutJobsInput
    >;
    connectOrCreate?: UsersCreateOrConnectWithoutJobsInput;
    upsert?: UsersUpsertWithoutJobsInput;
    connect?: UsersWhereUniqueInput;
    update?: XOR<
      XOR<
        UsersUpdateToOneWithWhereWithoutJobsInput,
        UsersUpdateWithoutJobsInput
      >,
      UsersUncheckedUpdateWithoutJobsInput
    >;
  };

  export type LineItemJobUncheckedUpdateManyWithoutJobNestedInput = {
    create?:
      | XOR<
          LineItemJobCreateWithoutJobInput,
          LineItemJobUncheckedCreateWithoutJobInput
        >
      | LineItemJobCreateWithoutJobInput[]
      | LineItemJobUncheckedCreateWithoutJobInput[];
    connectOrCreate?:
      | LineItemJobCreateOrConnectWithoutJobInput
      | LineItemJobCreateOrConnectWithoutJobInput[];
    upsert?:
      | LineItemJobUpsertWithWhereUniqueWithoutJobInput
      | LineItemJobUpsertWithWhereUniqueWithoutJobInput[];
    createMany?: LineItemJobCreateManyJobInputEnvelope;
    set?: LineItemJobWhereUniqueInput | LineItemJobWhereUniqueInput[];
    disconnect?: LineItemJobWhereUniqueInput | LineItemJobWhereUniqueInput[];
    delete?: LineItemJobWhereUniqueInput | LineItemJobWhereUniqueInput[];
    connect?: LineItemJobWhereUniqueInput | LineItemJobWhereUniqueInput[];
    update?:
      | LineItemJobUpdateWithWhereUniqueWithoutJobInput
      | LineItemJobUpdateWithWhereUniqueWithoutJobInput[];
    updateMany?:
      | LineItemJobUpdateManyWithWhereWithoutJobInput
      | LineItemJobUpdateManyWithWhereWithoutJobInput[];
    deleteMany?: LineItemJobScalarWhereInput | LineItemJobScalarWhereInput[];
  };

  export type JobRequestUncheckedUpdateManyWithoutJobNestedInput = {
    create?:
      | XOR<
          JobRequestCreateWithoutJobInput,
          JobRequestUncheckedCreateWithoutJobInput
        >
      | JobRequestCreateWithoutJobInput[]
      | JobRequestUncheckedCreateWithoutJobInput[];
    connectOrCreate?:
      | JobRequestCreateOrConnectWithoutJobInput
      | JobRequestCreateOrConnectWithoutJobInput[];
    upsert?:
      | JobRequestUpsertWithWhereUniqueWithoutJobInput
      | JobRequestUpsertWithWhereUniqueWithoutJobInput[];
    createMany?: JobRequestCreateManyJobInputEnvelope;
    set?: JobRequestWhereUniqueInput | JobRequestWhereUniqueInput[];
    disconnect?: JobRequestWhereUniqueInput | JobRequestWhereUniqueInput[];
    delete?: JobRequestWhereUniqueInput | JobRequestWhereUniqueInput[];
    connect?: JobRequestWhereUniqueInput | JobRequestWhereUniqueInput[];
    update?:
      | JobRequestUpdateWithWhereUniqueWithoutJobInput
      | JobRequestUpdateWithWhereUniqueWithoutJobInput[];
    updateMany?:
      | JobRequestUpdateManyWithWhereWithoutJobInput
      | JobRequestUpdateManyWithWhereWithoutJobInput[];
    deleteMany?: JobRequestScalarWhereInput | JobRequestScalarWhereInput[];
  };

  export type JobQuoteUncheckedUpdateManyWithoutJobNestedInput = {
    create?:
      | XOR<
          JobQuoteCreateWithoutJobInput,
          JobQuoteUncheckedCreateWithoutJobInput
        >
      | JobQuoteCreateWithoutJobInput[]
      | JobQuoteUncheckedCreateWithoutJobInput[];
    connectOrCreate?:
      | JobQuoteCreateOrConnectWithoutJobInput
      | JobQuoteCreateOrConnectWithoutJobInput[];
    upsert?:
      | JobQuoteUpsertWithWhereUniqueWithoutJobInput
      | JobQuoteUpsertWithWhereUniqueWithoutJobInput[];
    createMany?: JobQuoteCreateManyJobInputEnvelope;
    set?: JobQuoteWhereUniqueInput | JobQuoteWhereUniqueInput[];
    disconnect?: JobQuoteWhereUniqueInput | JobQuoteWhereUniqueInput[];
    delete?: JobQuoteWhereUniqueInput | JobQuoteWhereUniqueInput[];
    connect?: JobQuoteWhereUniqueInput | JobQuoteWhereUniqueInput[];
    update?:
      | JobQuoteUpdateWithWhereUniqueWithoutJobInput
      | JobQuoteUpdateWithWhereUniqueWithoutJobInput[];
    updateMany?:
      | JobQuoteUpdateManyWithWhereWithoutJobInput
      | JobQuoteUpdateManyWithWhereWithoutJobInput[];
    deleteMany?: JobQuoteScalarWhereInput | JobQuoteScalarWhereInput[];
  };

  export type InvoicesUncheckedUpdateManyWithoutJobNestedInput = {
    create?:
      | XOR<
          InvoicesCreateWithoutJobInput,
          InvoicesUncheckedCreateWithoutJobInput
        >
      | InvoicesCreateWithoutJobInput[]
      | InvoicesUncheckedCreateWithoutJobInput[];
    connectOrCreate?:
      | InvoicesCreateOrConnectWithoutJobInput
      | InvoicesCreateOrConnectWithoutJobInput[];
    upsert?:
      | InvoicesUpsertWithWhereUniqueWithoutJobInput
      | InvoicesUpsertWithWhereUniqueWithoutJobInput[];
    createMany?: InvoicesCreateManyJobInputEnvelope;
    set?: InvoicesWhereUniqueInput | InvoicesWhereUniqueInput[];
    disconnect?: InvoicesWhereUniqueInput | InvoicesWhereUniqueInput[];
    delete?: InvoicesWhereUniqueInput | InvoicesWhereUniqueInput[];
    connect?: InvoicesWhereUniqueInput | InvoicesWhereUniqueInput[];
    update?:
      | InvoicesUpdateWithWhereUniqueWithoutJobInput
      | InvoicesUpdateWithWhereUniqueWithoutJobInput[];
    updateMany?:
      | InvoicesUpdateManyWithWhereWithoutJobInput
      | InvoicesUpdateManyWithWhereWithoutJobInput[];
    deleteMany?: InvoicesScalarWhereInput | InvoicesScalarWhereInput[];
  };

  export type JobsCreateNestedOneWithoutLine_itemsInput = {
    create?: XOR<
      JobsCreateWithoutLine_itemsInput,
      JobsUncheckedCreateWithoutLine_itemsInput
    >;
    connectOrCreate?: JobsCreateOrConnectWithoutLine_itemsInput;
    connect?: JobsWhereUniqueInput;
  };

  export type LineItemsCreateNestedOneWithoutJobsInput = {
    create?: XOR<
      LineItemsCreateWithoutJobsInput,
      LineItemsUncheckedCreateWithoutJobsInput
    >;
    connectOrCreate?: LineItemsCreateOrConnectWithoutJobsInput;
    connect?: LineItemsWhereUniqueInput;
  };

  export type JobsUpdateOneRequiredWithoutLine_itemsNestedInput = {
    create?: XOR<
      JobsCreateWithoutLine_itemsInput,
      JobsUncheckedCreateWithoutLine_itemsInput
    >;
    connectOrCreate?: JobsCreateOrConnectWithoutLine_itemsInput;
    upsert?: JobsUpsertWithoutLine_itemsInput;
    connect?: JobsWhereUniqueInput;
    update?: XOR<
      XOR<
        JobsUpdateToOneWithWhereWithoutLine_itemsInput,
        JobsUpdateWithoutLine_itemsInput
      >,
      JobsUncheckedUpdateWithoutLine_itemsInput
    >;
  };

  export type LineItemsUpdateOneRequiredWithoutJobsNestedInput = {
    create?: XOR<
      LineItemsCreateWithoutJobsInput,
      LineItemsUncheckedCreateWithoutJobsInput
    >;
    connectOrCreate?: LineItemsCreateOrConnectWithoutJobsInput;
    upsert?: LineItemsUpsertWithoutJobsInput;
    connect?: LineItemsWhereUniqueInput;
    update?: XOR<
      XOR<
        LineItemsUpdateToOneWithWhereWithoutJobsInput,
        LineItemsUpdateWithoutJobsInput
      >,
      LineItemsUncheckedUpdateWithoutJobsInput
    >;
  };

  export type JobsCreateNestedOneWithoutJob_requestsInput = {
    create?: XOR<
      JobsCreateWithoutJob_requestsInput,
      JobsUncheckedCreateWithoutJob_requestsInput
    >;
    connectOrCreate?: JobsCreateOrConnectWithoutJob_requestsInput;
    connect?: JobsWhereUniqueInput;
  };

  export type RequestsCreateNestedOneWithoutJob_requestsInput = {
    create?: XOR<
      RequestsCreateWithoutJob_requestsInput,
      RequestsUncheckedCreateWithoutJob_requestsInput
    >;
    connectOrCreate?: RequestsCreateOrConnectWithoutJob_requestsInput;
    connect?: RequestsWhereUniqueInput;
  };

  export type JobsUpdateOneRequiredWithoutJob_requestsNestedInput = {
    create?: XOR<
      JobsCreateWithoutJob_requestsInput,
      JobsUncheckedCreateWithoutJob_requestsInput
    >;
    connectOrCreate?: JobsCreateOrConnectWithoutJob_requestsInput;
    upsert?: JobsUpsertWithoutJob_requestsInput;
    connect?: JobsWhereUniqueInput;
    update?: XOR<
      XOR<
        JobsUpdateToOneWithWhereWithoutJob_requestsInput,
        JobsUpdateWithoutJob_requestsInput
      >,
      JobsUncheckedUpdateWithoutJob_requestsInput
    >;
  };

  export type RequestsUpdateOneRequiredWithoutJob_requestsNestedInput = {
    create?: XOR<
      RequestsCreateWithoutJob_requestsInput,
      RequestsUncheckedCreateWithoutJob_requestsInput
    >;
    connectOrCreate?: RequestsCreateOrConnectWithoutJob_requestsInput;
    upsert?: RequestsUpsertWithoutJob_requestsInput;
    connect?: RequestsWhereUniqueInput;
    update?: XOR<
      XOR<
        RequestsUpdateToOneWithWhereWithoutJob_requestsInput,
        RequestsUpdateWithoutJob_requestsInput
      >,
      RequestsUncheckedUpdateWithoutJob_requestsInput
    >;
  };

  export type JobsCreateNestedOneWithoutJob_quotesInput = {
    create?: XOR<
      JobsCreateWithoutJob_quotesInput,
      JobsUncheckedCreateWithoutJob_quotesInput
    >;
    connectOrCreate?: JobsCreateOrConnectWithoutJob_quotesInput;
    connect?: JobsWhereUniqueInput;
  };

  export type QuotesCreateNestedOneWithoutJob_quotesInput = {
    create?: XOR<
      QuotesCreateWithoutJob_quotesInput,
      QuotesUncheckedCreateWithoutJob_quotesInput
    >;
    connectOrCreate?: QuotesCreateOrConnectWithoutJob_quotesInput;
    connect?: QuotesWhereUniqueInput;
  };

  export type JobsUpdateOneRequiredWithoutJob_quotesNestedInput = {
    create?: XOR<
      JobsCreateWithoutJob_quotesInput,
      JobsUncheckedCreateWithoutJob_quotesInput
    >;
    connectOrCreate?: JobsCreateOrConnectWithoutJob_quotesInput;
    upsert?: JobsUpsertWithoutJob_quotesInput;
    connect?: JobsWhereUniqueInput;
    update?: XOR<
      XOR<
        JobsUpdateToOneWithWhereWithoutJob_quotesInput,
        JobsUpdateWithoutJob_quotesInput
      >,
      JobsUncheckedUpdateWithoutJob_quotesInput
    >;
  };

  export type QuotesUpdateOneRequiredWithoutJob_quotesNestedInput = {
    create?: XOR<
      QuotesCreateWithoutJob_quotesInput,
      QuotesUncheckedCreateWithoutJob_quotesInput
    >;
    connectOrCreate?: QuotesCreateOrConnectWithoutJob_quotesInput;
    upsert?: QuotesUpsertWithoutJob_quotesInput;
    connect?: QuotesWhereUniqueInput;
    update?: XOR<
      XOR<
        QuotesUpdateToOneWithWhereWithoutJob_quotesInput,
        QuotesUpdateWithoutJob_quotesInput
      >,
      QuotesUncheckedUpdateWithoutJob_quotesInput
    >;
  };

  export type ClientsCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<
      ClientsCreateWithoutInvoicesInput,
      ClientsUncheckedCreateWithoutInvoicesInput
    >;
    connectOrCreate?: ClientsCreateOrConnectWithoutInvoicesInput;
    connect?: ClientsWhereUniqueInput;
  };

  export type JobsCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<
      JobsCreateWithoutInvoicesInput,
      JobsUncheckedCreateWithoutInvoicesInput
    >;
    connectOrCreate?: JobsCreateOrConnectWithoutInvoicesInput;
    connect?: JobsWhereUniqueInput;
  };

  export type TaxesCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<
      TaxesCreateWithoutInvoicesInput,
      TaxesUncheckedCreateWithoutInvoicesInput
    >;
    connectOrCreate?: TaxesCreateOrConnectWithoutInvoicesInput;
    connect?: TaxesWhereUniqueInput;
  };

  export type LineItemInvoiceCreateNestedManyWithoutInvoiceInput = {
    create?:
      | XOR<
          LineItemInvoiceCreateWithoutInvoiceInput,
          LineItemInvoiceUncheckedCreateWithoutInvoiceInput
        >
      | LineItemInvoiceCreateWithoutInvoiceInput[]
      | LineItemInvoiceUncheckedCreateWithoutInvoiceInput[];
    connectOrCreate?:
      | LineItemInvoiceCreateOrConnectWithoutInvoiceInput
      | LineItemInvoiceCreateOrConnectWithoutInvoiceInput[];
    createMany?: LineItemInvoiceCreateManyInvoiceInputEnvelope;
    connect?:
      | LineItemInvoiceWhereUniqueInput
      | LineItemInvoiceWhereUniqueInput[];
  };

  export type UsersCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<
      UsersCreateWithoutInvoicesInput,
      UsersUncheckedCreateWithoutInvoicesInput
    >;
    connectOrCreate?: UsersCreateOrConnectWithoutInvoicesInput;
    connect?: UsersWhereUniqueInput;
  };

  export type LineItemInvoiceUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?:
      | XOR<
          LineItemInvoiceCreateWithoutInvoiceInput,
          LineItemInvoiceUncheckedCreateWithoutInvoiceInput
        >
      | LineItemInvoiceCreateWithoutInvoiceInput[]
      | LineItemInvoiceUncheckedCreateWithoutInvoiceInput[];
    connectOrCreate?:
      | LineItemInvoiceCreateOrConnectWithoutInvoiceInput
      | LineItemInvoiceCreateOrConnectWithoutInvoiceInput[];
    createMany?: LineItemInvoiceCreateManyInvoiceInputEnvelope;
    connect?:
      | LineItemInvoiceWhereUniqueInput
      | LineItemInvoiceWhereUniqueInput[];
  };

  export type ClientsUpdateOneRequiredWithoutInvoicesNestedInput = {
    create?: XOR<
      ClientsCreateWithoutInvoicesInput,
      ClientsUncheckedCreateWithoutInvoicesInput
    >;
    connectOrCreate?: ClientsCreateOrConnectWithoutInvoicesInput;
    upsert?: ClientsUpsertWithoutInvoicesInput;
    connect?: ClientsWhereUniqueInput;
    update?: XOR<
      XOR<
        ClientsUpdateToOneWithWhereWithoutInvoicesInput,
        ClientsUpdateWithoutInvoicesInput
      >,
      ClientsUncheckedUpdateWithoutInvoicesInput
    >;
  };

  export type JobsUpdateOneWithoutInvoicesNestedInput = {
    create?: XOR<
      JobsCreateWithoutInvoicesInput,
      JobsUncheckedCreateWithoutInvoicesInput
    >;
    connectOrCreate?: JobsCreateOrConnectWithoutInvoicesInput;
    upsert?: JobsUpsertWithoutInvoicesInput;
    disconnect?: JobsWhereInput | boolean;
    delete?: JobsWhereInput | boolean;
    connect?: JobsWhereUniqueInput;
    update?: XOR<
      XOR<
        JobsUpdateToOneWithWhereWithoutInvoicesInput,
        JobsUpdateWithoutInvoicesInput
      >,
      JobsUncheckedUpdateWithoutInvoicesInput
    >;
  };

  export type TaxesUpdateOneWithoutInvoicesNestedInput = {
    create?: XOR<
      TaxesCreateWithoutInvoicesInput,
      TaxesUncheckedCreateWithoutInvoicesInput
    >;
    connectOrCreate?: TaxesCreateOrConnectWithoutInvoicesInput;
    upsert?: TaxesUpsertWithoutInvoicesInput;
    disconnect?: TaxesWhereInput | boolean;
    delete?: TaxesWhereInput | boolean;
    connect?: TaxesWhereUniqueInput;
    update?: XOR<
      XOR<
        TaxesUpdateToOneWithWhereWithoutInvoicesInput,
        TaxesUpdateWithoutInvoicesInput
      >,
      TaxesUncheckedUpdateWithoutInvoicesInput
    >;
  };

  export type LineItemInvoiceUpdateManyWithoutInvoiceNestedInput = {
    create?:
      | XOR<
          LineItemInvoiceCreateWithoutInvoiceInput,
          LineItemInvoiceUncheckedCreateWithoutInvoiceInput
        >
      | LineItemInvoiceCreateWithoutInvoiceInput[]
      | LineItemInvoiceUncheckedCreateWithoutInvoiceInput[];
    connectOrCreate?:
      | LineItemInvoiceCreateOrConnectWithoutInvoiceInput
      | LineItemInvoiceCreateOrConnectWithoutInvoiceInput[];
    upsert?:
      | LineItemInvoiceUpsertWithWhereUniqueWithoutInvoiceInput
      | LineItemInvoiceUpsertWithWhereUniqueWithoutInvoiceInput[];
    createMany?: LineItemInvoiceCreateManyInvoiceInputEnvelope;
    set?: LineItemInvoiceWhereUniqueInput | LineItemInvoiceWhereUniqueInput[];
    disconnect?:
      | LineItemInvoiceWhereUniqueInput
      | LineItemInvoiceWhereUniqueInput[];
    delete?:
      | LineItemInvoiceWhereUniqueInput
      | LineItemInvoiceWhereUniqueInput[];
    connect?:
      | LineItemInvoiceWhereUniqueInput
      | LineItemInvoiceWhereUniqueInput[];
    update?:
      | LineItemInvoiceUpdateWithWhereUniqueWithoutInvoiceInput
      | LineItemInvoiceUpdateWithWhereUniqueWithoutInvoiceInput[];
    updateMany?:
      | LineItemInvoiceUpdateManyWithWhereWithoutInvoiceInput
      | LineItemInvoiceUpdateManyWithWhereWithoutInvoiceInput[];
    deleteMany?:
      | LineItemInvoiceScalarWhereInput
      | LineItemInvoiceScalarWhereInput[];
  };

  export type UsersUpdateOneRequiredWithoutInvoicesNestedInput = {
    create?: XOR<
      UsersCreateWithoutInvoicesInput,
      UsersUncheckedCreateWithoutInvoicesInput
    >;
    connectOrCreate?: UsersCreateOrConnectWithoutInvoicesInput;
    upsert?: UsersUpsertWithoutInvoicesInput;
    connect?: UsersWhereUniqueInput;
    update?: XOR<
      XOR<
        UsersUpdateToOneWithWhereWithoutInvoicesInput,
        UsersUpdateWithoutInvoicesInput
      >,
      UsersUncheckedUpdateWithoutInvoicesInput
    >;
  };

  export type LineItemInvoiceUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?:
      | XOR<
          LineItemInvoiceCreateWithoutInvoiceInput,
          LineItemInvoiceUncheckedCreateWithoutInvoiceInput
        >
      | LineItemInvoiceCreateWithoutInvoiceInput[]
      | LineItemInvoiceUncheckedCreateWithoutInvoiceInput[];
    connectOrCreate?:
      | LineItemInvoiceCreateOrConnectWithoutInvoiceInput
      | LineItemInvoiceCreateOrConnectWithoutInvoiceInput[];
    upsert?:
      | LineItemInvoiceUpsertWithWhereUniqueWithoutInvoiceInput
      | LineItemInvoiceUpsertWithWhereUniqueWithoutInvoiceInput[];
    createMany?: LineItemInvoiceCreateManyInvoiceInputEnvelope;
    set?: LineItemInvoiceWhereUniqueInput | LineItemInvoiceWhereUniqueInput[];
    disconnect?:
      | LineItemInvoiceWhereUniqueInput
      | LineItemInvoiceWhereUniqueInput[];
    delete?:
      | LineItemInvoiceWhereUniqueInput
      | LineItemInvoiceWhereUniqueInput[];
    connect?:
      | LineItemInvoiceWhereUniqueInput
      | LineItemInvoiceWhereUniqueInput[];
    update?:
      | LineItemInvoiceUpdateWithWhereUniqueWithoutInvoiceInput
      | LineItemInvoiceUpdateWithWhereUniqueWithoutInvoiceInput[];
    updateMany?:
      | LineItemInvoiceUpdateManyWithWhereWithoutInvoiceInput
      | LineItemInvoiceUpdateManyWithWhereWithoutInvoiceInput[];
    deleteMany?:
      | LineItemInvoiceScalarWhereInput
      | LineItemInvoiceScalarWhereInput[];
  };

  export type InvoicesCreateNestedOneWithoutAdditional_line_itemsInput = {
    create?: XOR<
      InvoicesCreateWithoutAdditional_line_itemsInput,
      InvoicesUncheckedCreateWithoutAdditional_line_itemsInput
    >;
    connectOrCreate?: InvoicesCreateOrConnectWithoutAdditional_line_itemsInput;
    connect?: InvoicesWhereUniqueInput;
  };

  export type LineItemsCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<
      LineItemsCreateWithoutInvoicesInput,
      LineItemsUncheckedCreateWithoutInvoicesInput
    >;
    connectOrCreate?: LineItemsCreateOrConnectWithoutInvoicesInput;
    connect?: LineItemsWhereUniqueInput;
  };

  export type InvoicesUpdateOneRequiredWithoutAdditional_line_itemsNestedInput =
    {
      create?: XOR<
        InvoicesCreateWithoutAdditional_line_itemsInput,
        InvoicesUncheckedCreateWithoutAdditional_line_itemsInput
      >;
      connectOrCreate?: InvoicesCreateOrConnectWithoutAdditional_line_itemsInput;
      upsert?: InvoicesUpsertWithoutAdditional_line_itemsInput;
      connect?: InvoicesWhereUniqueInput;
      update?: XOR<
        XOR<
          InvoicesUpdateToOneWithWhereWithoutAdditional_line_itemsInput,
          InvoicesUpdateWithoutAdditional_line_itemsInput
        >,
        InvoicesUncheckedUpdateWithoutAdditional_line_itemsInput
      >;
    };

  export type LineItemsUpdateOneRequiredWithoutInvoicesNestedInput = {
    create?: XOR<
      LineItemsCreateWithoutInvoicesInput,
      LineItemsUncheckedCreateWithoutInvoicesInput
    >;
    connectOrCreate?: LineItemsCreateOrConnectWithoutInvoicesInput;
    upsert?: LineItemsUpsertWithoutInvoicesInput;
    connect?: LineItemsWhereUniqueInput;
    update?: XOR<
      XOR<
        LineItemsUpdateToOneWithWhereWithoutInvoicesInput,
        LineItemsUpdateWithoutInvoicesInput
      >,
      LineItemsUncheckedUpdateWithoutInvoicesInput
    >;
  };

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntFilter<$PrismaModel> | number;
  };

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?: NestedStringFilter<$PrismaModel> | string;
  };

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatFilter<$PrismaModel> | number;
  };

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?: NestedStringNullableFilter<$PrismaModel> | string | null;
  };

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedFloatFilter<$PrismaModel>;
    _sum?: NestedIntFilter<$PrismaModel>;
    _min?: NestedIntFilter<$PrismaModel>;
    _max?: NestedIntFilter<$PrismaModel>;
  };

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedStringFilter<$PrismaModel>;
    _max?: NestedStringFilter<$PrismaModel>;
  };

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedFloatFilter<$PrismaModel>;
    _sum?: NestedFloatFilter<$PrismaModel>;
    _min?: NestedFloatFilter<$PrismaModel>;
    _max?: NestedFloatFilter<$PrismaModel>;
  };

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?:
      | NestedStringNullableWithAggregatesFilter<$PrismaModel>
      | string
      | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedStringNullableFilter<$PrismaModel>;
    _max?: NestedStringNullableFilter<$PrismaModel>;
  };

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableFilter<$PrismaModel> | number | null;
  };

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null;
  };

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> =
    {
      equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
      in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
      notIn?:
        | Date[]
        | string[]
        | ListDateTimeFieldRefInput<$PrismaModel>
        | null;
      lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      not?:
        | NestedDateTimeNullableWithAggregatesFilter<$PrismaModel>
        | Date
        | string
        | null;
      _count?: NestedIntNullableFilter<$PrismaModel>;
      _min?: NestedDateTimeNullableFilter<$PrismaModel>;
      _max?: NestedDateTimeNullableFilter<$PrismaModel>;
    };

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _avg?: NestedFloatNullableFilter<$PrismaModel>;
    _sum?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedIntNullableFilter<$PrismaModel>;
    _max?: NestedIntNullableFilter<$PrismaModel>;
  };

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null;
  };
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<NestedJsonNullableFilterBase<$PrismaModel>>,
          Exclude<
            keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>,
            "path"
          >
        >,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<
        Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, "path">
      >;

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter;
    path?: string[];
    string_contains?: string | StringFieldRefInput<$PrismaModel>;
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>;
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>;
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    not?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter;
  };

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolFilter<$PrismaModel> | boolean;
  };

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string;
  };

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedBoolFilter<$PrismaModel>;
    _max?: NestedBoolFilter<$PrismaModel>;
  };

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedDateTimeFilter<$PrismaModel>;
    _max?: NestedDateTimeFilter<$PrismaModel>;
  };

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _avg?: NestedFloatNullableFilter<$PrismaModel>;
    _sum?: NestedFloatNullableFilter<$PrismaModel>;
    _min?: NestedFloatNullableFilter<$PrismaModel>;
    _max?: NestedFloatNullableFilter<$PrismaModel>;
  };

  export type UsersCreateWithoutDefault_taxInput = {
    email?: string | null;
    password: string;
    first_name: string;
    last_name: string;
    phone_number?: string | null;
    company_name?: string | null;
    subscription_id?: string | null;
    free_trial_expiration_date?: Date | string | null;
    settings?: NullableJsonNullValueInput | InputJsonValue;
    address?: AddressesCreateNestedOneWithoutUsersInput;
    clients?: ClientsCreateNestedManyWithoutBelongs_toInput;
    requests?: RequestsCreateNestedManyWithoutBelongs_toInput;
    jobs?: JobsCreateNestedManyWithoutBelongs_toInput;
    quotes?: QuotesCreateNestedManyWithoutBelongs_toInput;
    invoices?: InvoicesCreateNestedManyWithoutBelongs_toInput;
  };

  export type UsersUncheckedCreateWithoutDefault_taxInput = {
    id?: number;
    email?: string | null;
    password: string;
    first_name: string;
    last_name: string;
    phone_number?: string | null;
    company_name?: string | null;
    subscription_id?: string | null;
    free_trial_expiration_date?: Date | string | null;
    address_id?: number | null;
    settings?: NullableJsonNullValueInput | InputJsonValue;
    clients?: ClientsUncheckedCreateNestedManyWithoutBelongs_toInput;
    requests?: RequestsUncheckedCreateNestedManyWithoutBelongs_toInput;
    jobs?: JobsUncheckedCreateNestedManyWithoutBelongs_toInput;
    quotes?: QuotesUncheckedCreateNestedManyWithoutBelongs_toInput;
    invoices?: InvoicesUncheckedCreateNestedManyWithoutBelongs_toInput;
  };

  export type UsersCreateOrConnectWithoutDefault_taxInput = {
    where: UsersWhereUniqueInput;
    create: XOR<
      UsersCreateWithoutDefault_taxInput,
      UsersUncheckedCreateWithoutDefault_taxInput
    >;
  };

  export type UsersCreateManyDefault_taxInputEnvelope = {
    data: UsersCreateManyDefault_taxInput | UsersCreateManyDefault_taxInput[];
    skipDuplicates?: boolean;
  };

  export type QuotesCreateWithoutTaxInput = {
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: boolean;
    texted_to_client?: boolean;
    status: string;
    title: string;
    quote_number: string;
    opportunity_rating?: string | null;
    client_message?: string | null;
    discount?: number | null;
    discount_unit?: string | null;
    required_deposit?: number | null;
    link_to_releated_jobs?: boolean;
    link_to_releated_invoices?: boolean;
    client: ClientsCreateNestedOneWithoutQuotesInput;
    line_items?: LineItemQuoteCreateNestedManyWithoutQuoteInput;
    requests?: QuoteRequestCreateNestedManyWithoutQuoteInput;
    job_quotes?: JobQuoteCreateNestedManyWithoutQuoteInput;
    belongs_to: UsersCreateNestedOneWithoutQuotesInput;
  };

  export type QuotesUncheckedCreateWithoutTaxInput = {
    id?: number;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: boolean;
    texted_to_client?: boolean;
    status: string;
    title: string;
    quote_number: string;
    opportunity_rating?: string | null;
    client_id: number;
    client_message?: string | null;
    discount?: number | null;
    discount_unit?: string | null;
    required_deposit?: number | null;
    link_to_releated_jobs?: boolean;
    link_to_releated_invoices?: boolean;
    belongs_to_id: number;
    line_items?: LineItemQuoteUncheckedCreateNestedManyWithoutQuoteInput;
    requests?: QuoteRequestUncheckedCreateNestedManyWithoutQuoteInput;
    job_quotes?: JobQuoteUncheckedCreateNestedManyWithoutQuoteInput;
  };

  export type QuotesCreateOrConnectWithoutTaxInput = {
    where: QuotesWhereUniqueInput;
    create: XOR<
      QuotesCreateWithoutTaxInput,
      QuotesUncheckedCreateWithoutTaxInput
    >;
  };

  export type QuotesCreateManyTaxInputEnvelope = {
    data: QuotesCreateManyTaxInput | QuotesCreateManyTaxInput[];
    skipDuplicates?: boolean;
  };

  export type InvoicesCreateWithoutTaxInput = {
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: boolean;
    texted_to_client?: boolean;
    issued_date: Date | string;
    due_date?: Date | string | null;
    status: string;
    type: string;
    subject: string;
    client_message: string;
    internal_notes: string;
    internalAttachmentUrl: string;
    client: ClientsCreateNestedOneWithoutInvoicesInput;
    job?: JobsCreateNestedOneWithoutInvoicesInput;
    additional_line_items?: LineItemInvoiceCreateNestedManyWithoutInvoiceInput;
    belongs_to: UsersCreateNestedOneWithoutInvoicesInput;
  };

  export type InvoicesUncheckedCreateWithoutTaxInput = {
    id?: number;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: boolean;
    texted_to_client?: boolean;
    issued_date: Date | string;
    due_date?: Date | string | null;
    status: string;
    type: string;
    subject: string;
    client_id: number;
    job_id?: number | null;
    client_message: string;
    internal_notes: string;
    internalAttachmentUrl: string;
    belongs_to_id: number;
    additional_line_items?: LineItemInvoiceUncheckedCreateNestedManyWithoutInvoiceInput;
  };

  export type InvoicesCreateOrConnectWithoutTaxInput = {
    where: InvoicesWhereUniqueInput;
    create: XOR<
      InvoicesCreateWithoutTaxInput,
      InvoicesUncheckedCreateWithoutTaxInput
    >;
  };

  export type InvoicesCreateManyTaxInputEnvelope = {
    data: InvoicesCreateManyTaxInput | InvoicesCreateManyTaxInput[];
    skipDuplicates?: boolean;
  };

  export type UsersUpsertWithWhereUniqueWithoutDefault_taxInput = {
    where: UsersWhereUniqueInput;
    update: XOR<
      UsersUpdateWithoutDefault_taxInput,
      UsersUncheckedUpdateWithoutDefault_taxInput
    >;
    create: XOR<
      UsersCreateWithoutDefault_taxInput,
      UsersUncheckedCreateWithoutDefault_taxInput
    >;
  };

  export type UsersUpdateWithWhereUniqueWithoutDefault_taxInput = {
    where: UsersWhereUniqueInput;
    data: XOR<
      UsersUpdateWithoutDefault_taxInput,
      UsersUncheckedUpdateWithoutDefault_taxInput
    >;
  };

  export type UsersUpdateManyWithWhereWithoutDefault_taxInput = {
    where: UsersScalarWhereInput;
    data: XOR<
      UsersUpdateManyMutationInput,
      UsersUncheckedUpdateManyWithoutDefault_taxInput
    >;
  };

  export type UsersScalarWhereInput = {
    AND?: UsersScalarWhereInput | UsersScalarWhereInput[];
    OR?: UsersScalarWhereInput[];
    NOT?: UsersScalarWhereInput | UsersScalarWhereInput[];
    id?: IntFilter<"Users"> | number;
    email?: StringNullableFilter<"Users"> | string | null;
    password?: StringFilter<"Users"> | string;
    first_name?: StringFilter<"Users"> | string;
    last_name?: StringFilter<"Users"> | string;
    phone_number?: StringNullableFilter<"Users"> | string | null;
    company_name?: StringNullableFilter<"Users"> | string | null;
    subscription_id?: StringNullableFilter<"Users"> | string | null;
    free_trial_expiration_date?:
      | DateTimeNullableFilter<"Users">
      | Date
      | string
      | null;
    default_tax_id?: IntNullableFilter<"Users"> | number | null;
    address_id?: IntNullableFilter<"Users"> | number | null;
    settings?: JsonNullableFilter<"Users">;
  };

  export type QuotesUpsertWithWhereUniqueWithoutTaxInput = {
    where: QuotesWhereUniqueInput;
    update: XOR<
      QuotesUpdateWithoutTaxInput,
      QuotesUncheckedUpdateWithoutTaxInput
    >;
    create: XOR<
      QuotesCreateWithoutTaxInput,
      QuotesUncheckedCreateWithoutTaxInput
    >;
  };

  export type QuotesUpdateWithWhereUniqueWithoutTaxInput = {
    where: QuotesWhereUniqueInput;
    data: XOR<
      QuotesUpdateWithoutTaxInput,
      QuotesUncheckedUpdateWithoutTaxInput
    >;
  };

  export type QuotesUpdateManyWithWhereWithoutTaxInput = {
    where: QuotesScalarWhereInput;
    data: XOR<
      QuotesUpdateManyMutationInput,
      QuotesUncheckedUpdateManyWithoutTaxInput
    >;
  };

  export type QuotesScalarWhereInput = {
    AND?: QuotesScalarWhereInput | QuotesScalarWhereInput[];
    OR?: QuotesScalarWhereInput[];
    NOT?: QuotesScalarWhereInput | QuotesScalarWhereInput[];
    id?: IntFilter<"Quotes"> | number;
    tags?: JsonNullableFilter<"Quotes">;
    emailed_to_client?: BoolFilter<"Quotes"> | boolean;
    texted_to_client?: BoolFilter<"Quotes"> | boolean;
    status?: StringFilter<"Quotes"> | string;
    title?: StringFilter<"Quotes"> | string;
    quote_number?: StringFilter<"Quotes"> | string;
    opportunity_rating?: StringNullableFilter<"Quotes"> | string | null;
    client_id?: IntFilter<"Quotes"> | number;
    client_message?: StringNullableFilter<"Quotes"> | string | null;
    discount?: FloatNullableFilter<"Quotes"> | number | null;
    discount_unit?: StringNullableFilter<"Quotes"> | string | null;
    tax_id?: IntFilter<"Quotes"> | number;
    required_deposit?: FloatNullableFilter<"Quotes"> | number | null;
    link_to_releated_jobs?: BoolFilter<"Quotes"> | boolean;
    link_to_releated_invoices?: BoolFilter<"Quotes"> | boolean;
    belongs_to_id?: IntFilter<"Quotes"> | number;
  };

  export type InvoicesUpsertWithWhereUniqueWithoutTaxInput = {
    where: InvoicesWhereUniqueInput;
    update: XOR<
      InvoicesUpdateWithoutTaxInput,
      InvoicesUncheckedUpdateWithoutTaxInput
    >;
    create: XOR<
      InvoicesCreateWithoutTaxInput,
      InvoicesUncheckedCreateWithoutTaxInput
    >;
  };

  export type InvoicesUpdateWithWhereUniqueWithoutTaxInput = {
    where: InvoicesWhereUniqueInput;
    data: XOR<
      InvoicesUpdateWithoutTaxInput,
      InvoicesUncheckedUpdateWithoutTaxInput
    >;
  };

  export type InvoicesUpdateManyWithWhereWithoutTaxInput = {
    where: InvoicesScalarWhereInput;
    data: XOR<
      InvoicesUpdateManyMutationInput,
      InvoicesUncheckedUpdateManyWithoutTaxInput
    >;
  };

  export type InvoicesScalarWhereInput = {
    AND?: InvoicesScalarWhereInput | InvoicesScalarWhereInput[];
    OR?: InvoicesScalarWhereInput[];
    NOT?: InvoicesScalarWhereInput | InvoicesScalarWhereInput[];
    id?: IntFilter<"Invoices"> | number;
    tags?: JsonNullableFilter<"Invoices">;
    emailed_to_client?: BoolFilter<"Invoices"> | boolean;
    texted_to_client?: BoolFilter<"Invoices"> | boolean;
    issued_date?: DateTimeFilter<"Invoices"> | Date | string;
    due_date?: DateTimeNullableFilter<"Invoices"> | Date | string | null;
    status?: StringFilter<"Invoices"> | string;
    type?: StringFilter<"Invoices"> | string;
    subject?: StringFilter<"Invoices"> | string;
    client_id?: IntFilter<"Invoices"> | number;
    job_id?: IntNullableFilter<"Invoices"> | number | null;
    tax_id?: IntNullableFilter<"Invoices"> | number | null;
    client_message?: StringFilter<"Invoices"> | string;
    internal_notes?: StringFilter<"Invoices"> | string;
    internalAttachmentUrl?: StringFilter<"Invoices"> | string;
    belongs_to_id?: IntFilter<"Invoices"> | number;
  };

  export type UsersCreateWithoutAddressInput = {
    email?: string | null;
    password: string;
    first_name: string;
    last_name: string;
    phone_number?: string | null;
    company_name?: string | null;
    subscription_id?: string | null;
    free_trial_expiration_date?: Date | string | null;
    settings?: NullableJsonNullValueInput | InputJsonValue;
    default_tax?: TaxesCreateNestedOneWithoutUsersInput;
    clients?: ClientsCreateNestedManyWithoutBelongs_toInput;
    requests?: RequestsCreateNestedManyWithoutBelongs_toInput;
    jobs?: JobsCreateNestedManyWithoutBelongs_toInput;
    quotes?: QuotesCreateNestedManyWithoutBelongs_toInput;
    invoices?: InvoicesCreateNestedManyWithoutBelongs_toInput;
  };

  export type UsersUncheckedCreateWithoutAddressInput = {
    id?: number;
    email?: string | null;
    password: string;
    first_name: string;
    last_name: string;
    phone_number?: string | null;
    company_name?: string | null;
    subscription_id?: string | null;
    free_trial_expiration_date?: Date | string | null;
    default_tax_id?: number | null;
    settings?: NullableJsonNullValueInput | InputJsonValue;
    clients?: ClientsUncheckedCreateNestedManyWithoutBelongs_toInput;
    requests?: RequestsUncheckedCreateNestedManyWithoutBelongs_toInput;
    jobs?: JobsUncheckedCreateNestedManyWithoutBelongs_toInput;
    quotes?: QuotesUncheckedCreateNestedManyWithoutBelongs_toInput;
    invoices?: InvoicesUncheckedCreateNestedManyWithoutBelongs_toInput;
  };

  export type UsersCreateOrConnectWithoutAddressInput = {
    where: UsersWhereUniqueInput;
    create: XOR<
      UsersCreateWithoutAddressInput,
      UsersUncheckedCreateWithoutAddressInput
    >;
  };

  export type UsersCreateManyAddressInputEnvelope = {
    data: UsersCreateManyAddressInput | UsersCreateManyAddressInput[];
    skipDuplicates?: boolean;
  };

  export type ClientsCreateWithoutProperty_addressInput = {
    title: string;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    first_name: string;
    last_name: string;
    company_name?: string | null;
    use_company_name_as_primary?: boolean;
    mobile_phone_number?: string | null;
    work_phone_number?: string | null;
    email?: string | null;
    quote_follow_up?: boolean;
    job_follow_up?: boolean;
    invoice_follow_up?: boolean;
    upcoming_visit_reminder?: boolean;
    referred_by?: string | null;
    billing_address_same_as_property?: boolean;
    created_date?: Date | string;
    status?: string | null;
    billing_address?: AddressesCreateNestedOneWithoutBilling_clientsInput;
    requests?: RequestsCreateNestedManyWithoutClientInput;
    quotes?: QuotesCreateNestedManyWithoutClientInput;
    jobs?: JobsCreateNestedManyWithoutClientInput;
    invoices?: InvoicesCreateNestedManyWithoutClientInput;
    belongs_to: UsersCreateNestedOneWithoutClientsInput;
  };

  export type ClientsUncheckedCreateWithoutProperty_addressInput = {
    id?: number;
    title: string;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    first_name: string;
    last_name: string;
    company_name?: string | null;
    use_company_name_as_primary?: boolean;
    mobile_phone_number?: string | null;
    work_phone_number?: string | null;
    email?: string | null;
    quote_follow_up?: boolean;
    job_follow_up?: boolean;
    invoice_follow_up?: boolean;
    upcoming_visit_reminder?: boolean;
    referred_by?: string | null;
    billing_address_same_as_property?: boolean;
    billing_address_id?: number | null;
    created_date?: Date | string;
    status?: string | null;
    belongs_to_id: number;
    requests?: RequestsUncheckedCreateNestedManyWithoutClientInput;
    quotes?: QuotesUncheckedCreateNestedManyWithoutClientInput;
    jobs?: JobsUncheckedCreateNestedManyWithoutClientInput;
    invoices?: InvoicesUncheckedCreateNestedManyWithoutClientInput;
  };

  export type ClientsCreateOrConnectWithoutProperty_addressInput = {
    where: ClientsWhereUniqueInput;
    create: XOR<
      ClientsCreateWithoutProperty_addressInput,
      ClientsUncheckedCreateWithoutProperty_addressInput
    >;
  };

  export type ClientsCreateManyProperty_addressInputEnvelope = {
    data:
      | ClientsCreateManyProperty_addressInput
      | ClientsCreateManyProperty_addressInput[];
    skipDuplicates?: boolean;
  };

  export type ClientsCreateWithoutBilling_addressInput = {
    title: string;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    first_name: string;
    last_name: string;
    company_name?: string | null;
    use_company_name_as_primary?: boolean;
    mobile_phone_number?: string | null;
    work_phone_number?: string | null;
    email?: string | null;
    quote_follow_up?: boolean;
    job_follow_up?: boolean;
    invoice_follow_up?: boolean;
    upcoming_visit_reminder?: boolean;
    referred_by?: string | null;
    billing_address_same_as_property?: boolean;
    created_date?: Date | string;
    status?: string | null;
    property_address?: AddressesCreateNestedOneWithoutProperty_clientsInput;
    requests?: RequestsCreateNestedManyWithoutClientInput;
    quotes?: QuotesCreateNestedManyWithoutClientInput;
    jobs?: JobsCreateNestedManyWithoutClientInput;
    invoices?: InvoicesCreateNestedManyWithoutClientInput;
    belongs_to: UsersCreateNestedOneWithoutClientsInput;
  };

  export type ClientsUncheckedCreateWithoutBilling_addressInput = {
    id?: number;
    title: string;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    first_name: string;
    last_name: string;
    company_name?: string | null;
    use_company_name_as_primary?: boolean;
    mobile_phone_number?: string | null;
    work_phone_number?: string | null;
    email?: string | null;
    quote_follow_up?: boolean;
    job_follow_up?: boolean;
    invoice_follow_up?: boolean;
    upcoming_visit_reminder?: boolean;
    referred_by?: string | null;
    billing_address_same_as_property?: boolean;
    property_address_id?: number | null;
    created_date?: Date | string;
    status?: string | null;
    belongs_to_id: number;
    requests?: RequestsUncheckedCreateNestedManyWithoutClientInput;
    quotes?: QuotesUncheckedCreateNestedManyWithoutClientInput;
    jobs?: JobsUncheckedCreateNestedManyWithoutClientInput;
    invoices?: InvoicesUncheckedCreateNestedManyWithoutClientInput;
  };

  export type ClientsCreateOrConnectWithoutBilling_addressInput = {
    where: ClientsWhereUniqueInput;
    create: XOR<
      ClientsCreateWithoutBilling_addressInput,
      ClientsUncheckedCreateWithoutBilling_addressInput
    >;
  };

  export type ClientsCreateManyBilling_addressInputEnvelope = {
    data:
      | ClientsCreateManyBilling_addressInput
      | ClientsCreateManyBilling_addressInput[];
    skipDuplicates?: boolean;
  };

  export type UsersUpsertWithWhereUniqueWithoutAddressInput = {
    where: UsersWhereUniqueInput;
    update: XOR<
      UsersUpdateWithoutAddressInput,
      UsersUncheckedUpdateWithoutAddressInput
    >;
    create: XOR<
      UsersCreateWithoutAddressInput,
      UsersUncheckedCreateWithoutAddressInput
    >;
  };

  export type UsersUpdateWithWhereUniqueWithoutAddressInput = {
    where: UsersWhereUniqueInput;
    data: XOR<
      UsersUpdateWithoutAddressInput,
      UsersUncheckedUpdateWithoutAddressInput
    >;
  };

  export type UsersUpdateManyWithWhereWithoutAddressInput = {
    where: UsersScalarWhereInput;
    data: XOR<
      UsersUpdateManyMutationInput,
      UsersUncheckedUpdateManyWithoutAddressInput
    >;
  };

  export type ClientsUpsertWithWhereUniqueWithoutProperty_addressInput = {
    where: ClientsWhereUniqueInput;
    update: XOR<
      ClientsUpdateWithoutProperty_addressInput,
      ClientsUncheckedUpdateWithoutProperty_addressInput
    >;
    create: XOR<
      ClientsCreateWithoutProperty_addressInput,
      ClientsUncheckedCreateWithoutProperty_addressInput
    >;
  };

  export type ClientsUpdateWithWhereUniqueWithoutProperty_addressInput = {
    where: ClientsWhereUniqueInput;
    data: XOR<
      ClientsUpdateWithoutProperty_addressInput,
      ClientsUncheckedUpdateWithoutProperty_addressInput
    >;
  };

  export type ClientsUpdateManyWithWhereWithoutProperty_addressInput = {
    where: ClientsScalarWhereInput;
    data: XOR<
      ClientsUpdateManyMutationInput,
      ClientsUncheckedUpdateManyWithoutProperty_addressInput
    >;
  };

  export type ClientsScalarWhereInput = {
    AND?: ClientsScalarWhereInput | ClientsScalarWhereInput[];
    OR?: ClientsScalarWhereInput[];
    NOT?: ClientsScalarWhereInput | ClientsScalarWhereInput[];
    id?: IntFilter<"Clients"> | number;
    title?: StringFilter<"Clients"> | string;
    tags?: JsonNullableFilter<"Clients">;
    first_name?: StringFilter<"Clients"> | string;
    last_name?: StringFilter<"Clients"> | string;
    company_name?: StringNullableFilter<"Clients"> | string | null;
    use_company_name_as_primary?: BoolFilter<"Clients"> | boolean;
    mobile_phone_number?: StringNullableFilter<"Clients"> | string | null;
    work_phone_number?: StringNullableFilter<"Clients"> | string | null;
    email?: StringNullableFilter<"Clients"> | string | null;
    quote_follow_up?: BoolFilter<"Clients"> | boolean;
    job_follow_up?: BoolFilter<"Clients"> | boolean;
    invoice_follow_up?: BoolFilter<"Clients"> | boolean;
    upcoming_visit_reminder?: BoolFilter<"Clients"> | boolean;
    referred_by?: StringNullableFilter<"Clients"> | string | null;
    billing_address_same_as_property?: BoolFilter<"Clients"> | boolean;
    property_address_id?: IntNullableFilter<"Clients"> | number | null;
    billing_address_id?: IntNullableFilter<"Clients"> | number | null;
    created_date?: DateTimeFilter<"Clients"> | Date | string;
    status?: StringNullableFilter<"Clients"> | string | null;
    belongs_to_id?: IntFilter<"Clients"> | number;
  };

  export type ClientsUpsertWithWhereUniqueWithoutBilling_addressInput = {
    where: ClientsWhereUniqueInput;
    update: XOR<
      ClientsUpdateWithoutBilling_addressInput,
      ClientsUncheckedUpdateWithoutBilling_addressInput
    >;
    create: XOR<
      ClientsCreateWithoutBilling_addressInput,
      ClientsUncheckedCreateWithoutBilling_addressInput
    >;
  };

  export type ClientsUpdateWithWhereUniqueWithoutBilling_addressInput = {
    where: ClientsWhereUniqueInput;
    data: XOR<
      ClientsUpdateWithoutBilling_addressInput,
      ClientsUncheckedUpdateWithoutBilling_addressInput
    >;
  };

  export type ClientsUpdateManyWithWhereWithoutBilling_addressInput = {
    where: ClientsScalarWhereInput;
    data: XOR<
      ClientsUpdateManyMutationInput,
      ClientsUncheckedUpdateManyWithoutBilling_addressInput
    >;
  };

  export type TaxesCreateWithoutUsersInput = {
    name: string;
    rate: number;
    description?: string | null;
    quotes?: QuotesCreateNestedManyWithoutTaxInput;
    invoices?: InvoicesCreateNestedManyWithoutTaxInput;
  };

  export type TaxesUncheckedCreateWithoutUsersInput = {
    id?: number;
    name: string;
    rate: number;
    description?: string | null;
    quotes?: QuotesUncheckedCreateNestedManyWithoutTaxInput;
    invoices?: InvoicesUncheckedCreateNestedManyWithoutTaxInput;
  };

  export type TaxesCreateOrConnectWithoutUsersInput = {
    where: TaxesWhereUniqueInput;
    create: XOR<
      TaxesCreateWithoutUsersInput,
      TaxesUncheckedCreateWithoutUsersInput
    >;
  };

  export type AddressesCreateWithoutUsersInput = {
    street1: string;
    street2?: string | null;
    city: string;
    state: string;
    zip_code: string;
    country: string;
    property_clients?: ClientsCreateNestedManyWithoutProperty_addressInput;
    billing_clients?: ClientsCreateNestedManyWithoutBilling_addressInput;
  };

  export type AddressesUncheckedCreateWithoutUsersInput = {
    id?: number;
    street1: string;
    street2?: string | null;
    city: string;
    state: string;
    zip_code: string;
    country: string;
    property_clients?: ClientsUncheckedCreateNestedManyWithoutProperty_addressInput;
    billing_clients?: ClientsUncheckedCreateNestedManyWithoutBilling_addressInput;
  };

  export type AddressesCreateOrConnectWithoutUsersInput = {
    where: AddressesWhereUniqueInput;
    create: XOR<
      AddressesCreateWithoutUsersInput,
      AddressesUncheckedCreateWithoutUsersInput
    >;
  };

  export type ClientsCreateWithoutBelongs_toInput = {
    title: string;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    first_name: string;
    last_name: string;
    company_name?: string | null;
    use_company_name_as_primary?: boolean;
    mobile_phone_number?: string | null;
    work_phone_number?: string | null;
    email?: string | null;
    quote_follow_up?: boolean;
    job_follow_up?: boolean;
    invoice_follow_up?: boolean;
    upcoming_visit_reminder?: boolean;
    referred_by?: string | null;
    billing_address_same_as_property?: boolean;
    created_date?: Date | string;
    status?: string | null;
    property_address?: AddressesCreateNestedOneWithoutProperty_clientsInput;
    billing_address?: AddressesCreateNestedOneWithoutBilling_clientsInput;
    requests?: RequestsCreateNestedManyWithoutClientInput;
    quotes?: QuotesCreateNestedManyWithoutClientInput;
    jobs?: JobsCreateNestedManyWithoutClientInput;
    invoices?: InvoicesCreateNestedManyWithoutClientInput;
  };

  export type ClientsUncheckedCreateWithoutBelongs_toInput = {
    id?: number;
    title: string;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    first_name: string;
    last_name: string;
    company_name?: string | null;
    use_company_name_as_primary?: boolean;
    mobile_phone_number?: string | null;
    work_phone_number?: string | null;
    email?: string | null;
    quote_follow_up?: boolean;
    job_follow_up?: boolean;
    invoice_follow_up?: boolean;
    upcoming_visit_reminder?: boolean;
    referred_by?: string | null;
    billing_address_same_as_property?: boolean;
    property_address_id?: number | null;
    billing_address_id?: number | null;
    created_date?: Date | string;
    status?: string | null;
    requests?: RequestsUncheckedCreateNestedManyWithoutClientInput;
    quotes?: QuotesUncheckedCreateNestedManyWithoutClientInput;
    jobs?: JobsUncheckedCreateNestedManyWithoutClientInput;
    invoices?: InvoicesUncheckedCreateNestedManyWithoutClientInput;
  };

  export type ClientsCreateOrConnectWithoutBelongs_toInput = {
    where: ClientsWhereUniqueInput;
    create: XOR<
      ClientsCreateWithoutBelongs_toInput,
      ClientsUncheckedCreateWithoutBelongs_toInput
    >;
  };

  export type ClientsCreateManyBelongs_toInputEnvelope = {
    data: ClientsCreateManyBelongs_toInput | ClientsCreateManyBelongs_toInput[];
    skipDuplicates?: boolean;
  };

  export type RequestsCreateWithoutBelongs_toInput = {
    status: string;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: boolean;
    texted_to_client?: boolean;
    title: string;
    service_details: string;
    assessment_date: Date | string;
    backup_assessment__date?: Date | string | null;
    preferred_arrival_times?: string | null;
    on_site_assesment_required?: boolean;
    internal_notes: string;
    internalAttachmentUrl: string;
    link_to_releated_quotes?: boolean;
    link_to_releated_jobs?: boolean;
    link_to_releated_invoices?: boolean;
    assessment: AssessmentsCreateNestedOneWithoutRequestsInput;
    client: ClientsCreateNestedOneWithoutRequestsInput;
    quotes?: QuoteRequestCreateNestedManyWithoutRequestInput;
    job_requests?: JobRequestCreateNestedManyWithoutRequestInput;
  };

  export type RequestsUncheckedCreateWithoutBelongs_toInput = {
    id?: number;
    status: string;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: boolean;
    texted_to_client?: boolean;
    title: string;
    service_details: string;
    assessment_date: Date | string;
    backup_assessment__date?: Date | string | null;
    preferred_arrival_times?: string | null;
    on_site_assesment_required?: boolean;
    client_id: number;
    assessment_id: number;
    internal_notes: string;
    internalAttachmentUrl: string;
    link_to_releated_quotes?: boolean;
    link_to_releated_jobs?: boolean;
    link_to_releated_invoices?: boolean;
    quotes?: QuoteRequestUncheckedCreateNestedManyWithoutRequestInput;
    job_requests?: JobRequestUncheckedCreateNestedManyWithoutRequestInput;
  };

  export type RequestsCreateOrConnectWithoutBelongs_toInput = {
    where: RequestsWhereUniqueInput;
    create: XOR<
      RequestsCreateWithoutBelongs_toInput,
      RequestsUncheckedCreateWithoutBelongs_toInput
    >;
  };

  export type RequestsCreateManyBelongs_toInputEnvelope = {
    data:
      | RequestsCreateManyBelongs_toInput
      | RequestsCreateManyBelongs_toInput[];
    skipDuplicates?: boolean;
  };

  export type JobsCreateWithoutBelongs_toInput = {
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: boolean;
    texted_to_client?: boolean;
    status: string;
    title: string;
    instructions?: string | null;
    number: string;
    schedule_type: string;
    recurring_frequency?: string | null;
    recurring_interval?: string | null;
    day_of_week?: string | null;
    day_of_year?: string | null;
    duration?: string | null;
    start_date?: Date | string | null;
    end_date?: Date | string | null;
    start_time?: Date | string | null;
    end_time?: Date | string | null;
    schedule_later?: boolean;
    team?: string | null;
    email_team?: boolean;
    invoice_reminder?: boolean;
    internal_notes?: string | null;
    internal_attachment_url?: string | null;
    link_to_related_invoices?: boolean;
    client: ClientsCreateNestedOneWithoutJobsInput;
    line_items?: LineItemJobCreateNestedManyWithoutJobInput;
    job_requests?: JobRequestCreateNestedManyWithoutJobInput;
    job_quotes?: JobQuoteCreateNestedManyWithoutJobInput;
    invoices?: InvoicesCreateNestedManyWithoutJobInput;
  };

  export type JobsUncheckedCreateWithoutBelongs_toInput = {
    id?: number;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: boolean;
    texted_to_client?: boolean;
    status: string;
    client_id: number;
    title: string;
    instructions?: string | null;
    number: string;
    schedule_type: string;
    recurring_frequency?: string | null;
    recurring_interval?: string | null;
    day_of_week?: string | null;
    day_of_year?: string | null;
    duration?: string | null;
    start_date?: Date | string | null;
    end_date?: Date | string | null;
    start_time?: Date | string | null;
    end_time?: Date | string | null;
    schedule_later?: boolean;
    team?: string | null;
    email_team?: boolean;
    invoice_reminder?: boolean;
    internal_notes?: string | null;
    internal_attachment_url?: string | null;
    link_to_related_invoices?: boolean;
    line_items?: LineItemJobUncheckedCreateNestedManyWithoutJobInput;
    job_requests?: JobRequestUncheckedCreateNestedManyWithoutJobInput;
    job_quotes?: JobQuoteUncheckedCreateNestedManyWithoutJobInput;
    invoices?: InvoicesUncheckedCreateNestedManyWithoutJobInput;
  };

  export type JobsCreateOrConnectWithoutBelongs_toInput = {
    where: JobsWhereUniqueInput;
    create: XOR<
      JobsCreateWithoutBelongs_toInput,
      JobsUncheckedCreateWithoutBelongs_toInput
    >;
  };

  export type JobsCreateManyBelongs_toInputEnvelope = {
    data: JobsCreateManyBelongs_toInput | JobsCreateManyBelongs_toInput[];
    skipDuplicates?: boolean;
  };

  export type QuotesCreateWithoutBelongs_toInput = {
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: boolean;
    texted_to_client?: boolean;
    status: string;
    title: string;
    quote_number: string;
    opportunity_rating?: string | null;
    client_message?: string | null;
    discount?: number | null;
    discount_unit?: string | null;
    required_deposit?: number | null;
    link_to_releated_jobs?: boolean;
    link_to_releated_invoices?: boolean;
    client: ClientsCreateNestedOneWithoutQuotesInput;
    line_items?: LineItemQuoteCreateNestedManyWithoutQuoteInput;
    tax?: TaxesCreateNestedOneWithoutQuotesInput;
    requests?: QuoteRequestCreateNestedManyWithoutQuoteInput;
    job_quotes?: JobQuoteCreateNestedManyWithoutQuoteInput;
  };

  export type QuotesUncheckedCreateWithoutBelongs_toInput = {
    id?: number;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: boolean;
    texted_to_client?: boolean;
    status: string;
    title: string;
    quote_number: string;
    opportunity_rating?: string | null;
    client_id: number;
    client_message?: string | null;
    discount?: number | null;
    discount_unit?: string | null;
    tax_id: number;
    required_deposit?: number | null;
    link_to_releated_jobs?: boolean;
    link_to_releated_invoices?: boolean;
    line_items?: LineItemQuoteUncheckedCreateNestedManyWithoutQuoteInput;
    requests?: QuoteRequestUncheckedCreateNestedManyWithoutQuoteInput;
    job_quotes?: JobQuoteUncheckedCreateNestedManyWithoutQuoteInput;
  };

  export type QuotesCreateOrConnectWithoutBelongs_toInput = {
    where: QuotesWhereUniqueInput;
    create: XOR<
      QuotesCreateWithoutBelongs_toInput,
      QuotesUncheckedCreateWithoutBelongs_toInput
    >;
  };

  export type QuotesCreateManyBelongs_toInputEnvelope = {
    data: QuotesCreateManyBelongs_toInput | QuotesCreateManyBelongs_toInput[];
    skipDuplicates?: boolean;
  };

  export type InvoicesCreateWithoutBelongs_toInput = {
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: boolean;
    texted_to_client?: boolean;
    issued_date: Date | string;
    due_date?: Date | string | null;
    status: string;
    type: string;
    subject: string;
    client_message: string;
    internal_notes: string;
    internalAttachmentUrl: string;
    client: ClientsCreateNestedOneWithoutInvoicesInput;
    job?: JobsCreateNestedOneWithoutInvoicesInput;
    tax?: TaxesCreateNestedOneWithoutInvoicesInput;
    additional_line_items?: LineItemInvoiceCreateNestedManyWithoutInvoiceInput;
  };

  export type InvoicesUncheckedCreateWithoutBelongs_toInput = {
    id?: number;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: boolean;
    texted_to_client?: boolean;
    issued_date: Date | string;
    due_date?: Date | string | null;
    status: string;
    type: string;
    subject: string;
    client_id: number;
    job_id?: number | null;
    tax_id?: number | null;
    client_message: string;
    internal_notes: string;
    internalAttachmentUrl: string;
    additional_line_items?: LineItemInvoiceUncheckedCreateNestedManyWithoutInvoiceInput;
  };

  export type InvoicesCreateOrConnectWithoutBelongs_toInput = {
    where: InvoicesWhereUniqueInput;
    create: XOR<
      InvoicesCreateWithoutBelongs_toInput,
      InvoicesUncheckedCreateWithoutBelongs_toInput
    >;
  };

  export type InvoicesCreateManyBelongs_toInputEnvelope = {
    data:
      | InvoicesCreateManyBelongs_toInput
      | InvoicesCreateManyBelongs_toInput[];
    skipDuplicates?: boolean;
  };

  export type TaxesUpsertWithoutUsersInput = {
    update: XOR<
      TaxesUpdateWithoutUsersInput,
      TaxesUncheckedUpdateWithoutUsersInput
    >;
    create: XOR<
      TaxesCreateWithoutUsersInput,
      TaxesUncheckedCreateWithoutUsersInput
    >;
    where?: TaxesWhereInput;
  };

  export type TaxesUpdateToOneWithWhereWithoutUsersInput = {
    where?: TaxesWhereInput;
    data: XOR<
      TaxesUpdateWithoutUsersInput,
      TaxesUncheckedUpdateWithoutUsersInput
    >;
  };

  export type TaxesUpdateWithoutUsersInput = {
    name?: StringFieldUpdateOperationsInput | string;
    rate?: FloatFieldUpdateOperationsInput | number;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    quotes?: QuotesUpdateManyWithoutTaxNestedInput;
    invoices?: InvoicesUpdateManyWithoutTaxNestedInput;
  };

  export type TaxesUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number;
    name?: StringFieldUpdateOperationsInput | string;
    rate?: FloatFieldUpdateOperationsInput | number;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    quotes?: QuotesUncheckedUpdateManyWithoutTaxNestedInput;
    invoices?: InvoicesUncheckedUpdateManyWithoutTaxNestedInput;
  };

  export type AddressesUpsertWithoutUsersInput = {
    update: XOR<
      AddressesUpdateWithoutUsersInput,
      AddressesUncheckedUpdateWithoutUsersInput
    >;
    create: XOR<
      AddressesCreateWithoutUsersInput,
      AddressesUncheckedCreateWithoutUsersInput
    >;
    where?: AddressesWhereInput;
  };

  export type AddressesUpdateToOneWithWhereWithoutUsersInput = {
    where?: AddressesWhereInput;
    data: XOR<
      AddressesUpdateWithoutUsersInput,
      AddressesUncheckedUpdateWithoutUsersInput
    >;
  };

  export type AddressesUpdateWithoutUsersInput = {
    street1?: StringFieldUpdateOperationsInput | string;
    street2?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: StringFieldUpdateOperationsInput | string;
    state?: StringFieldUpdateOperationsInput | string;
    zip_code?: StringFieldUpdateOperationsInput | string;
    country?: StringFieldUpdateOperationsInput | string;
    property_clients?: ClientsUpdateManyWithoutProperty_addressNestedInput;
    billing_clients?: ClientsUpdateManyWithoutBilling_addressNestedInput;
  };

  export type AddressesUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number;
    street1?: StringFieldUpdateOperationsInput | string;
    street2?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: StringFieldUpdateOperationsInput | string;
    state?: StringFieldUpdateOperationsInput | string;
    zip_code?: StringFieldUpdateOperationsInput | string;
    country?: StringFieldUpdateOperationsInput | string;
    property_clients?: ClientsUncheckedUpdateManyWithoutProperty_addressNestedInput;
    billing_clients?: ClientsUncheckedUpdateManyWithoutBilling_addressNestedInput;
  };

  export type ClientsUpsertWithWhereUniqueWithoutBelongs_toInput = {
    where: ClientsWhereUniqueInput;
    update: XOR<
      ClientsUpdateWithoutBelongs_toInput,
      ClientsUncheckedUpdateWithoutBelongs_toInput
    >;
    create: XOR<
      ClientsCreateWithoutBelongs_toInput,
      ClientsUncheckedCreateWithoutBelongs_toInput
    >;
  };

  export type ClientsUpdateWithWhereUniqueWithoutBelongs_toInput = {
    where: ClientsWhereUniqueInput;
    data: XOR<
      ClientsUpdateWithoutBelongs_toInput,
      ClientsUncheckedUpdateWithoutBelongs_toInput
    >;
  };

  export type ClientsUpdateManyWithWhereWithoutBelongs_toInput = {
    where: ClientsScalarWhereInput;
    data: XOR<
      ClientsUpdateManyMutationInput,
      ClientsUncheckedUpdateManyWithoutBelongs_toInput
    >;
  };

  export type RequestsUpsertWithWhereUniqueWithoutBelongs_toInput = {
    where: RequestsWhereUniqueInput;
    update: XOR<
      RequestsUpdateWithoutBelongs_toInput,
      RequestsUncheckedUpdateWithoutBelongs_toInput
    >;
    create: XOR<
      RequestsCreateWithoutBelongs_toInput,
      RequestsUncheckedCreateWithoutBelongs_toInput
    >;
  };

  export type RequestsUpdateWithWhereUniqueWithoutBelongs_toInput = {
    where: RequestsWhereUniqueInput;
    data: XOR<
      RequestsUpdateWithoutBelongs_toInput,
      RequestsUncheckedUpdateWithoutBelongs_toInput
    >;
  };

  export type RequestsUpdateManyWithWhereWithoutBelongs_toInput = {
    where: RequestsScalarWhereInput;
    data: XOR<
      RequestsUpdateManyMutationInput,
      RequestsUncheckedUpdateManyWithoutBelongs_toInput
    >;
  };

  export type RequestsScalarWhereInput = {
    AND?: RequestsScalarWhereInput | RequestsScalarWhereInput[];
    OR?: RequestsScalarWhereInput[];
    NOT?: RequestsScalarWhereInput | RequestsScalarWhereInput[];
    id?: IntFilter<"Requests"> | number;
    status?: StringFilter<"Requests"> | string;
    tags?: JsonNullableFilter<"Requests">;
    emailed_to_client?: BoolFilter<"Requests"> | boolean;
    texted_to_client?: BoolFilter<"Requests"> | boolean;
    title?: StringFilter<"Requests"> | string;
    service_details?: StringFilter<"Requests"> | string;
    assessment_date?: DateTimeFilter<"Requests"> | Date | string;
    backup_assessment__date?:
      | DateTimeNullableFilter<"Requests">
      | Date
      | string
      | null;
    preferred_arrival_times?: StringNullableFilter<"Requests"> | string | null;
    on_site_assesment_required?: BoolFilter<"Requests"> | boolean;
    client_id?: IntFilter<"Requests"> | number;
    assessment_id?: IntFilter<"Requests"> | number;
    internal_notes?: StringFilter<"Requests"> | string;
    internalAttachmentUrl?: StringFilter<"Requests"> | string;
    link_to_releated_quotes?: BoolFilter<"Requests"> | boolean;
    link_to_releated_jobs?: BoolFilter<"Requests"> | boolean;
    link_to_releated_invoices?: BoolFilter<"Requests"> | boolean;
    belongs_to_id?: IntFilter<"Requests"> | number;
  };

  export type JobsUpsertWithWhereUniqueWithoutBelongs_toInput = {
    where: JobsWhereUniqueInput;
    update: XOR<
      JobsUpdateWithoutBelongs_toInput,
      JobsUncheckedUpdateWithoutBelongs_toInput
    >;
    create: XOR<
      JobsCreateWithoutBelongs_toInput,
      JobsUncheckedCreateWithoutBelongs_toInput
    >;
  };

  export type JobsUpdateWithWhereUniqueWithoutBelongs_toInput = {
    where: JobsWhereUniqueInput;
    data: XOR<
      JobsUpdateWithoutBelongs_toInput,
      JobsUncheckedUpdateWithoutBelongs_toInput
    >;
  };

  export type JobsUpdateManyWithWhereWithoutBelongs_toInput = {
    where: JobsScalarWhereInput;
    data: XOR<
      JobsUpdateManyMutationInput,
      JobsUncheckedUpdateManyWithoutBelongs_toInput
    >;
  };

  export type JobsScalarWhereInput = {
    AND?: JobsScalarWhereInput | JobsScalarWhereInput[];
    OR?: JobsScalarWhereInput[];
    NOT?: JobsScalarWhereInput | JobsScalarWhereInput[];
    id?: IntFilter<"Jobs"> | number;
    tags?: JsonNullableFilter<"Jobs">;
    emailed_to_client?: BoolFilter<"Jobs"> | boolean;
    texted_to_client?: BoolFilter<"Jobs"> | boolean;
    status?: StringFilter<"Jobs"> | string;
    client_id?: IntFilter<"Jobs"> | number;
    title?: StringFilter<"Jobs"> | string;
    instructions?: StringNullableFilter<"Jobs"> | string | null;
    number?: StringFilter<"Jobs"> | string;
    schedule_type?: StringFilter<"Jobs"> | string;
    recurring_frequency?: StringNullableFilter<"Jobs"> | string | null;
    recurring_interval?: StringNullableFilter<"Jobs"> | string | null;
    day_of_week?: StringNullableFilter<"Jobs"> | string | null;
    day_of_year?: StringNullableFilter<"Jobs"> | string | null;
    duration?: StringNullableFilter<"Jobs"> | string | null;
    start_date?: DateTimeNullableFilter<"Jobs"> | Date | string | null;
    end_date?: DateTimeNullableFilter<"Jobs"> | Date | string | null;
    start_time?: DateTimeNullableFilter<"Jobs"> | Date | string | null;
    end_time?: DateTimeNullableFilter<"Jobs"> | Date | string | null;
    schedule_later?: BoolFilter<"Jobs"> | boolean;
    team?: StringNullableFilter<"Jobs"> | string | null;
    email_team?: BoolFilter<"Jobs"> | boolean;
    invoice_reminder?: BoolFilter<"Jobs"> | boolean;
    internal_notes?: StringNullableFilter<"Jobs"> | string | null;
    internal_attachment_url?: StringNullableFilter<"Jobs"> | string | null;
    link_to_related_invoices?: BoolFilter<"Jobs"> | boolean;
    belongs_to_id?: IntFilter<"Jobs"> | number;
  };

  export type QuotesUpsertWithWhereUniqueWithoutBelongs_toInput = {
    where: QuotesWhereUniqueInput;
    update: XOR<
      QuotesUpdateWithoutBelongs_toInput,
      QuotesUncheckedUpdateWithoutBelongs_toInput
    >;
    create: XOR<
      QuotesCreateWithoutBelongs_toInput,
      QuotesUncheckedCreateWithoutBelongs_toInput
    >;
  };

  export type QuotesUpdateWithWhereUniqueWithoutBelongs_toInput = {
    where: QuotesWhereUniqueInput;
    data: XOR<
      QuotesUpdateWithoutBelongs_toInput,
      QuotesUncheckedUpdateWithoutBelongs_toInput
    >;
  };

  export type QuotesUpdateManyWithWhereWithoutBelongs_toInput = {
    where: QuotesScalarWhereInput;
    data: XOR<
      QuotesUpdateManyMutationInput,
      QuotesUncheckedUpdateManyWithoutBelongs_toInput
    >;
  };

  export type InvoicesUpsertWithWhereUniqueWithoutBelongs_toInput = {
    where: InvoicesWhereUniqueInput;
    update: XOR<
      InvoicesUpdateWithoutBelongs_toInput,
      InvoicesUncheckedUpdateWithoutBelongs_toInput
    >;
    create: XOR<
      InvoicesCreateWithoutBelongs_toInput,
      InvoicesUncheckedCreateWithoutBelongs_toInput
    >;
  };

  export type InvoicesUpdateWithWhereUniqueWithoutBelongs_toInput = {
    where: InvoicesWhereUniqueInput;
    data: XOR<
      InvoicesUpdateWithoutBelongs_toInput,
      InvoicesUncheckedUpdateWithoutBelongs_toInput
    >;
  };

  export type InvoicesUpdateManyWithWhereWithoutBelongs_toInput = {
    where: InvoicesScalarWhereInput;
    data: XOR<
      InvoicesUpdateManyMutationInput,
      InvoicesUncheckedUpdateManyWithoutBelongs_toInput
    >;
  };

  export type AddressesCreateWithoutProperty_clientsInput = {
    street1: string;
    street2?: string | null;
    city: string;
    state: string;
    zip_code: string;
    country: string;
    users?: UsersCreateNestedManyWithoutAddressInput;
    billing_clients?: ClientsCreateNestedManyWithoutBilling_addressInput;
  };

  export type AddressesUncheckedCreateWithoutProperty_clientsInput = {
    id?: number;
    street1: string;
    street2?: string | null;
    city: string;
    state: string;
    zip_code: string;
    country: string;
    users?: UsersUncheckedCreateNestedManyWithoutAddressInput;
    billing_clients?: ClientsUncheckedCreateNestedManyWithoutBilling_addressInput;
  };

  export type AddressesCreateOrConnectWithoutProperty_clientsInput = {
    where: AddressesWhereUniqueInput;
    create: XOR<
      AddressesCreateWithoutProperty_clientsInput,
      AddressesUncheckedCreateWithoutProperty_clientsInput
    >;
  };

  export type AddressesCreateWithoutBilling_clientsInput = {
    street1: string;
    street2?: string | null;
    city: string;
    state: string;
    zip_code: string;
    country: string;
    users?: UsersCreateNestedManyWithoutAddressInput;
    property_clients?: ClientsCreateNestedManyWithoutProperty_addressInput;
  };

  export type AddressesUncheckedCreateWithoutBilling_clientsInput = {
    id?: number;
    street1: string;
    street2?: string | null;
    city: string;
    state: string;
    zip_code: string;
    country: string;
    users?: UsersUncheckedCreateNestedManyWithoutAddressInput;
    property_clients?: ClientsUncheckedCreateNestedManyWithoutProperty_addressInput;
  };

  export type AddressesCreateOrConnectWithoutBilling_clientsInput = {
    where: AddressesWhereUniqueInput;
    create: XOR<
      AddressesCreateWithoutBilling_clientsInput,
      AddressesUncheckedCreateWithoutBilling_clientsInput
    >;
  };

  export type RequestsCreateWithoutClientInput = {
    status: string;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: boolean;
    texted_to_client?: boolean;
    title: string;
    service_details: string;
    assessment_date: Date | string;
    backup_assessment__date?: Date | string | null;
    preferred_arrival_times?: string | null;
    on_site_assesment_required?: boolean;
    internal_notes: string;
    internalAttachmentUrl: string;
    link_to_releated_quotes?: boolean;
    link_to_releated_jobs?: boolean;
    link_to_releated_invoices?: boolean;
    assessment: AssessmentsCreateNestedOneWithoutRequestsInput;
    quotes?: QuoteRequestCreateNestedManyWithoutRequestInput;
    job_requests?: JobRequestCreateNestedManyWithoutRequestInput;
    belongs_to: UsersCreateNestedOneWithoutRequestsInput;
  };

  export type RequestsUncheckedCreateWithoutClientInput = {
    id?: number;
    status: string;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: boolean;
    texted_to_client?: boolean;
    title: string;
    service_details: string;
    assessment_date: Date | string;
    backup_assessment__date?: Date | string | null;
    preferred_arrival_times?: string | null;
    on_site_assesment_required?: boolean;
    assessment_id: number;
    internal_notes: string;
    internalAttachmentUrl: string;
    link_to_releated_quotes?: boolean;
    link_to_releated_jobs?: boolean;
    link_to_releated_invoices?: boolean;
    belongs_to_id: number;
    quotes?: QuoteRequestUncheckedCreateNestedManyWithoutRequestInput;
    job_requests?: JobRequestUncheckedCreateNestedManyWithoutRequestInput;
  };

  export type RequestsCreateOrConnectWithoutClientInput = {
    where: RequestsWhereUniqueInput;
    create: XOR<
      RequestsCreateWithoutClientInput,
      RequestsUncheckedCreateWithoutClientInput
    >;
  };

  export type RequestsCreateManyClientInputEnvelope = {
    data: RequestsCreateManyClientInput | RequestsCreateManyClientInput[];
    skipDuplicates?: boolean;
  };

  export type QuotesCreateWithoutClientInput = {
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: boolean;
    texted_to_client?: boolean;
    status: string;
    title: string;
    quote_number: string;
    opportunity_rating?: string | null;
    client_message?: string | null;
    discount?: number | null;
    discount_unit?: string | null;
    required_deposit?: number | null;
    link_to_releated_jobs?: boolean;
    link_to_releated_invoices?: boolean;
    line_items?: LineItemQuoteCreateNestedManyWithoutQuoteInput;
    tax?: TaxesCreateNestedOneWithoutQuotesInput;
    requests?: QuoteRequestCreateNestedManyWithoutQuoteInput;
    job_quotes?: JobQuoteCreateNestedManyWithoutQuoteInput;
    belongs_to: UsersCreateNestedOneWithoutQuotesInput;
  };

  export type QuotesUncheckedCreateWithoutClientInput = {
    id?: number;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: boolean;
    texted_to_client?: boolean;
    status: string;
    title: string;
    quote_number: string;
    opportunity_rating?: string | null;
    client_message?: string | null;
    discount?: number | null;
    discount_unit?: string | null;
    tax_id: number;
    required_deposit?: number | null;
    link_to_releated_jobs?: boolean;
    link_to_releated_invoices?: boolean;
    belongs_to_id: number;
    line_items?: LineItemQuoteUncheckedCreateNestedManyWithoutQuoteInput;
    requests?: QuoteRequestUncheckedCreateNestedManyWithoutQuoteInput;
    job_quotes?: JobQuoteUncheckedCreateNestedManyWithoutQuoteInput;
  };

  export type QuotesCreateOrConnectWithoutClientInput = {
    where: QuotesWhereUniqueInput;
    create: XOR<
      QuotesCreateWithoutClientInput,
      QuotesUncheckedCreateWithoutClientInput
    >;
  };

  export type QuotesCreateManyClientInputEnvelope = {
    data: QuotesCreateManyClientInput | QuotesCreateManyClientInput[];
    skipDuplicates?: boolean;
  };

  export type JobsCreateWithoutClientInput = {
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: boolean;
    texted_to_client?: boolean;
    status: string;
    title: string;
    instructions?: string | null;
    number: string;
    schedule_type: string;
    recurring_frequency?: string | null;
    recurring_interval?: string | null;
    day_of_week?: string | null;
    day_of_year?: string | null;
    duration?: string | null;
    start_date?: Date | string | null;
    end_date?: Date | string | null;
    start_time?: Date | string | null;
    end_time?: Date | string | null;
    schedule_later?: boolean;
    team?: string | null;
    email_team?: boolean;
    invoice_reminder?: boolean;
    internal_notes?: string | null;
    internal_attachment_url?: string | null;
    link_to_related_invoices?: boolean;
    line_items?: LineItemJobCreateNestedManyWithoutJobInput;
    job_requests?: JobRequestCreateNestedManyWithoutJobInput;
    job_quotes?: JobQuoteCreateNestedManyWithoutJobInput;
    invoices?: InvoicesCreateNestedManyWithoutJobInput;
    belongs_to: UsersCreateNestedOneWithoutJobsInput;
  };

  export type JobsUncheckedCreateWithoutClientInput = {
    id?: number;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: boolean;
    texted_to_client?: boolean;
    status: string;
    title: string;
    instructions?: string | null;
    number: string;
    schedule_type: string;
    recurring_frequency?: string | null;
    recurring_interval?: string | null;
    day_of_week?: string | null;
    day_of_year?: string | null;
    duration?: string | null;
    start_date?: Date | string | null;
    end_date?: Date | string | null;
    start_time?: Date | string | null;
    end_time?: Date | string | null;
    schedule_later?: boolean;
    team?: string | null;
    email_team?: boolean;
    invoice_reminder?: boolean;
    internal_notes?: string | null;
    internal_attachment_url?: string | null;
    link_to_related_invoices?: boolean;
    belongs_to_id: number;
    line_items?: LineItemJobUncheckedCreateNestedManyWithoutJobInput;
    job_requests?: JobRequestUncheckedCreateNestedManyWithoutJobInput;
    job_quotes?: JobQuoteUncheckedCreateNestedManyWithoutJobInput;
    invoices?: InvoicesUncheckedCreateNestedManyWithoutJobInput;
  };

  export type JobsCreateOrConnectWithoutClientInput = {
    where: JobsWhereUniqueInput;
    create: XOR<
      JobsCreateWithoutClientInput,
      JobsUncheckedCreateWithoutClientInput
    >;
  };

  export type JobsCreateManyClientInputEnvelope = {
    data: JobsCreateManyClientInput | JobsCreateManyClientInput[];
    skipDuplicates?: boolean;
  };

  export type InvoicesCreateWithoutClientInput = {
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: boolean;
    texted_to_client?: boolean;
    issued_date: Date | string;
    due_date?: Date | string | null;
    status: string;
    type: string;
    subject: string;
    client_message: string;
    internal_notes: string;
    internalAttachmentUrl: string;
    job?: JobsCreateNestedOneWithoutInvoicesInput;
    tax?: TaxesCreateNestedOneWithoutInvoicesInput;
    additional_line_items?: LineItemInvoiceCreateNestedManyWithoutInvoiceInput;
    belongs_to: UsersCreateNestedOneWithoutInvoicesInput;
  };

  export type InvoicesUncheckedCreateWithoutClientInput = {
    id?: number;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: boolean;
    texted_to_client?: boolean;
    issued_date: Date | string;
    due_date?: Date | string | null;
    status: string;
    type: string;
    subject: string;
    job_id?: number | null;
    tax_id?: number | null;
    client_message: string;
    internal_notes: string;
    internalAttachmentUrl: string;
    belongs_to_id: number;
    additional_line_items?: LineItemInvoiceUncheckedCreateNestedManyWithoutInvoiceInput;
  };

  export type InvoicesCreateOrConnectWithoutClientInput = {
    where: InvoicesWhereUniqueInput;
    create: XOR<
      InvoicesCreateWithoutClientInput,
      InvoicesUncheckedCreateWithoutClientInput
    >;
  };

  export type InvoicesCreateManyClientInputEnvelope = {
    data: InvoicesCreateManyClientInput | InvoicesCreateManyClientInput[];
    skipDuplicates?: boolean;
  };

  export type UsersCreateWithoutClientsInput = {
    email?: string | null;
    password: string;
    first_name: string;
    last_name: string;
    phone_number?: string | null;
    company_name?: string | null;
    subscription_id?: string | null;
    free_trial_expiration_date?: Date | string | null;
    settings?: NullableJsonNullValueInput | InputJsonValue;
    default_tax?: TaxesCreateNestedOneWithoutUsersInput;
    address?: AddressesCreateNestedOneWithoutUsersInput;
    requests?: RequestsCreateNestedManyWithoutBelongs_toInput;
    jobs?: JobsCreateNestedManyWithoutBelongs_toInput;
    quotes?: QuotesCreateNestedManyWithoutBelongs_toInput;
    invoices?: InvoicesCreateNestedManyWithoutBelongs_toInput;
  };

  export type UsersUncheckedCreateWithoutClientsInput = {
    id?: number;
    email?: string | null;
    password: string;
    first_name: string;
    last_name: string;
    phone_number?: string | null;
    company_name?: string | null;
    subscription_id?: string | null;
    free_trial_expiration_date?: Date | string | null;
    default_tax_id?: number | null;
    address_id?: number | null;
    settings?: NullableJsonNullValueInput | InputJsonValue;
    requests?: RequestsUncheckedCreateNestedManyWithoutBelongs_toInput;
    jobs?: JobsUncheckedCreateNestedManyWithoutBelongs_toInput;
    quotes?: QuotesUncheckedCreateNestedManyWithoutBelongs_toInput;
    invoices?: InvoicesUncheckedCreateNestedManyWithoutBelongs_toInput;
  };

  export type UsersCreateOrConnectWithoutClientsInput = {
    where: UsersWhereUniqueInput;
    create: XOR<
      UsersCreateWithoutClientsInput,
      UsersUncheckedCreateWithoutClientsInput
    >;
  };

  export type AddressesUpsertWithoutProperty_clientsInput = {
    update: XOR<
      AddressesUpdateWithoutProperty_clientsInput,
      AddressesUncheckedUpdateWithoutProperty_clientsInput
    >;
    create: XOR<
      AddressesCreateWithoutProperty_clientsInput,
      AddressesUncheckedCreateWithoutProperty_clientsInput
    >;
    where?: AddressesWhereInput;
  };

  export type AddressesUpdateToOneWithWhereWithoutProperty_clientsInput = {
    where?: AddressesWhereInput;
    data: XOR<
      AddressesUpdateWithoutProperty_clientsInput,
      AddressesUncheckedUpdateWithoutProperty_clientsInput
    >;
  };

  export type AddressesUpdateWithoutProperty_clientsInput = {
    street1?: StringFieldUpdateOperationsInput | string;
    street2?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: StringFieldUpdateOperationsInput | string;
    state?: StringFieldUpdateOperationsInput | string;
    zip_code?: StringFieldUpdateOperationsInput | string;
    country?: StringFieldUpdateOperationsInput | string;
    users?: UsersUpdateManyWithoutAddressNestedInput;
    billing_clients?: ClientsUpdateManyWithoutBilling_addressNestedInput;
  };

  export type AddressesUncheckedUpdateWithoutProperty_clientsInput = {
    id?: IntFieldUpdateOperationsInput | number;
    street1?: StringFieldUpdateOperationsInput | string;
    street2?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: StringFieldUpdateOperationsInput | string;
    state?: StringFieldUpdateOperationsInput | string;
    zip_code?: StringFieldUpdateOperationsInput | string;
    country?: StringFieldUpdateOperationsInput | string;
    users?: UsersUncheckedUpdateManyWithoutAddressNestedInput;
    billing_clients?: ClientsUncheckedUpdateManyWithoutBilling_addressNestedInput;
  };

  export type AddressesUpsertWithoutBilling_clientsInput = {
    update: XOR<
      AddressesUpdateWithoutBilling_clientsInput,
      AddressesUncheckedUpdateWithoutBilling_clientsInput
    >;
    create: XOR<
      AddressesCreateWithoutBilling_clientsInput,
      AddressesUncheckedCreateWithoutBilling_clientsInput
    >;
    where?: AddressesWhereInput;
  };

  export type AddressesUpdateToOneWithWhereWithoutBilling_clientsInput = {
    where?: AddressesWhereInput;
    data: XOR<
      AddressesUpdateWithoutBilling_clientsInput,
      AddressesUncheckedUpdateWithoutBilling_clientsInput
    >;
  };

  export type AddressesUpdateWithoutBilling_clientsInput = {
    street1?: StringFieldUpdateOperationsInput | string;
    street2?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: StringFieldUpdateOperationsInput | string;
    state?: StringFieldUpdateOperationsInput | string;
    zip_code?: StringFieldUpdateOperationsInput | string;
    country?: StringFieldUpdateOperationsInput | string;
    users?: UsersUpdateManyWithoutAddressNestedInput;
    property_clients?: ClientsUpdateManyWithoutProperty_addressNestedInput;
  };

  export type AddressesUncheckedUpdateWithoutBilling_clientsInput = {
    id?: IntFieldUpdateOperationsInput | number;
    street1?: StringFieldUpdateOperationsInput | string;
    street2?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: StringFieldUpdateOperationsInput | string;
    state?: StringFieldUpdateOperationsInput | string;
    zip_code?: StringFieldUpdateOperationsInput | string;
    country?: StringFieldUpdateOperationsInput | string;
    users?: UsersUncheckedUpdateManyWithoutAddressNestedInput;
    property_clients?: ClientsUncheckedUpdateManyWithoutProperty_addressNestedInput;
  };

  export type RequestsUpsertWithWhereUniqueWithoutClientInput = {
    where: RequestsWhereUniqueInput;
    update: XOR<
      RequestsUpdateWithoutClientInput,
      RequestsUncheckedUpdateWithoutClientInput
    >;
    create: XOR<
      RequestsCreateWithoutClientInput,
      RequestsUncheckedCreateWithoutClientInput
    >;
  };

  export type RequestsUpdateWithWhereUniqueWithoutClientInput = {
    where: RequestsWhereUniqueInput;
    data: XOR<
      RequestsUpdateWithoutClientInput,
      RequestsUncheckedUpdateWithoutClientInput
    >;
  };

  export type RequestsUpdateManyWithWhereWithoutClientInput = {
    where: RequestsScalarWhereInput;
    data: XOR<
      RequestsUpdateManyMutationInput,
      RequestsUncheckedUpdateManyWithoutClientInput
    >;
  };

  export type QuotesUpsertWithWhereUniqueWithoutClientInput = {
    where: QuotesWhereUniqueInput;
    update: XOR<
      QuotesUpdateWithoutClientInput,
      QuotesUncheckedUpdateWithoutClientInput
    >;
    create: XOR<
      QuotesCreateWithoutClientInput,
      QuotesUncheckedCreateWithoutClientInput
    >;
  };

  export type QuotesUpdateWithWhereUniqueWithoutClientInput = {
    where: QuotesWhereUniqueInput;
    data: XOR<
      QuotesUpdateWithoutClientInput,
      QuotesUncheckedUpdateWithoutClientInput
    >;
  };

  export type QuotesUpdateManyWithWhereWithoutClientInput = {
    where: QuotesScalarWhereInput;
    data: XOR<
      QuotesUpdateManyMutationInput,
      QuotesUncheckedUpdateManyWithoutClientInput
    >;
  };

  export type JobsUpsertWithWhereUniqueWithoutClientInput = {
    where: JobsWhereUniqueInput;
    update: XOR<
      JobsUpdateWithoutClientInput,
      JobsUncheckedUpdateWithoutClientInput
    >;
    create: XOR<
      JobsCreateWithoutClientInput,
      JobsUncheckedCreateWithoutClientInput
    >;
  };

  export type JobsUpdateWithWhereUniqueWithoutClientInput = {
    where: JobsWhereUniqueInput;
    data: XOR<
      JobsUpdateWithoutClientInput,
      JobsUncheckedUpdateWithoutClientInput
    >;
  };

  export type JobsUpdateManyWithWhereWithoutClientInput = {
    where: JobsScalarWhereInput;
    data: XOR<
      JobsUpdateManyMutationInput,
      JobsUncheckedUpdateManyWithoutClientInput
    >;
  };

  export type InvoicesUpsertWithWhereUniqueWithoutClientInput = {
    where: InvoicesWhereUniqueInput;
    update: XOR<
      InvoicesUpdateWithoutClientInput,
      InvoicesUncheckedUpdateWithoutClientInput
    >;
    create: XOR<
      InvoicesCreateWithoutClientInput,
      InvoicesUncheckedCreateWithoutClientInput
    >;
  };

  export type InvoicesUpdateWithWhereUniqueWithoutClientInput = {
    where: InvoicesWhereUniqueInput;
    data: XOR<
      InvoicesUpdateWithoutClientInput,
      InvoicesUncheckedUpdateWithoutClientInput
    >;
  };

  export type InvoicesUpdateManyWithWhereWithoutClientInput = {
    where: InvoicesScalarWhereInput;
    data: XOR<
      InvoicesUpdateManyMutationInput,
      InvoicesUncheckedUpdateManyWithoutClientInput
    >;
  };

  export type UsersUpsertWithoutClientsInput = {
    update: XOR<
      UsersUpdateWithoutClientsInput,
      UsersUncheckedUpdateWithoutClientsInput
    >;
    create: XOR<
      UsersCreateWithoutClientsInput,
      UsersUncheckedCreateWithoutClientsInput
    >;
    where?: UsersWhereInput;
  };

  export type UsersUpdateToOneWithWhereWithoutClientsInput = {
    where?: UsersWhereInput;
    data: XOR<
      UsersUpdateWithoutClientsInput,
      UsersUncheckedUpdateWithoutClientsInput
    >;
  };

  export type UsersUpdateWithoutClientsInput = {
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: StringFieldUpdateOperationsInput | string;
    first_name?: StringFieldUpdateOperationsInput | string;
    last_name?: StringFieldUpdateOperationsInput | string;
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null;
    company_name?: NullableStringFieldUpdateOperationsInput | string | null;
    subscription_id?: NullableStringFieldUpdateOperationsInput | string | null;
    free_trial_expiration_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    settings?: NullableJsonNullValueInput | InputJsonValue;
    default_tax?: TaxesUpdateOneWithoutUsersNestedInput;
    address?: AddressesUpdateOneWithoutUsersNestedInput;
    requests?: RequestsUpdateManyWithoutBelongs_toNestedInput;
    jobs?: JobsUpdateManyWithoutBelongs_toNestedInput;
    quotes?: QuotesUpdateManyWithoutBelongs_toNestedInput;
    invoices?: InvoicesUpdateManyWithoutBelongs_toNestedInput;
  };

  export type UsersUncheckedUpdateWithoutClientsInput = {
    id?: IntFieldUpdateOperationsInput | number;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: StringFieldUpdateOperationsInput | string;
    first_name?: StringFieldUpdateOperationsInput | string;
    last_name?: StringFieldUpdateOperationsInput | string;
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null;
    company_name?: NullableStringFieldUpdateOperationsInput | string | null;
    subscription_id?: NullableStringFieldUpdateOperationsInput | string | null;
    free_trial_expiration_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    default_tax_id?: NullableIntFieldUpdateOperationsInput | number | null;
    address_id?: NullableIntFieldUpdateOperationsInput | number | null;
    settings?: NullableJsonNullValueInput | InputJsonValue;
    requests?: RequestsUncheckedUpdateManyWithoutBelongs_toNestedInput;
    jobs?: JobsUncheckedUpdateManyWithoutBelongs_toNestedInput;
    quotes?: QuotesUncheckedUpdateManyWithoutBelongs_toNestedInput;
    invoices?: InvoicesUncheckedUpdateManyWithoutBelongs_toNestedInput;
  };

  export type RequestsCreateWithoutAssessmentInput = {
    status: string;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: boolean;
    texted_to_client?: boolean;
    title: string;
    service_details: string;
    assessment_date: Date | string;
    backup_assessment__date?: Date | string | null;
    preferred_arrival_times?: string | null;
    on_site_assesment_required?: boolean;
    internal_notes: string;
    internalAttachmentUrl: string;
    link_to_releated_quotes?: boolean;
    link_to_releated_jobs?: boolean;
    link_to_releated_invoices?: boolean;
    client: ClientsCreateNestedOneWithoutRequestsInput;
    quotes?: QuoteRequestCreateNestedManyWithoutRequestInput;
    job_requests?: JobRequestCreateNestedManyWithoutRequestInput;
    belongs_to: UsersCreateNestedOneWithoutRequestsInput;
  };

  export type RequestsUncheckedCreateWithoutAssessmentInput = {
    id?: number;
    status: string;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: boolean;
    texted_to_client?: boolean;
    title: string;
    service_details: string;
    assessment_date: Date | string;
    backup_assessment__date?: Date | string | null;
    preferred_arrival_times?: string | null;
    on_site_assesment_required?: boolean;
    client_id: number;
    internal_notes: string;
    internalAttachmentUrl: string;
    link_to_releated_quotes?: boolean;
    link_to_releated_jobs?: boolean;
    link_to_releated_invoices?: boolean;
    belongs_to_id: number;
    quotes?: QuoteRequestUncheckedCreateNestedManyWithoutRequestInput;
    job_requests?: JobRequestUncheckedCreateNestedManyWithoutRequestInput;
  };

  export type RequestsCreateOrConnectWithoutAssessmentInput = {
    where: RequestsWhereUniqueInput;
    create: XOR<
      RequestsCreateWithoutAssessmentInput,
      RequestsUncheckedCreateWithoutAssessmentInput
    >;
  };

  export type RequestsCreateManyAssessmentInputEnvelope = {
    data:
      | RequestsCreateManyAssessmentInput
      | RequestsCreateManyAssessmentInput[];
    skipDuplicates?: boolean;
  };

  export type RequestsUpsertWithWhereUniqueWithoutAssessmentInput = {
    where: RequestsWhereUniqueInput;
    update: XOR<
      RequestsUpdateWithoutAssessmentInput,
      RequestsUncheckedUpdateWithoutAssessmentInput
    >;
    create: XOR<
      RequestsCreateWithoutAssessmentInput,
      RequestsUncheckedCreateWithoutAssessmentInput
    >;
  };

  export type RequestsUpdateWithWhereUniqueWithoutAssessmentInput = {
    where: RequestsWhereUniqueInput;
    data: XOR<
      RequestsUpdateWithoutAssessmentInput,
      RequestsUncheckedUpdateWithoutAssessmentInput
    >;
  };

  export type RequestsUpdateManyWithWhereWithoutAssessmentInput = {
    where: RequestsScalarWhereInput;
    data: XOR<
      RequestsUpdateManyMutationInput,
      RequestsUncheckedUpdateManyWithoutAssessmentInput
    >;
  };

  export type AssessmentsCreateWithoutRequestsInput = {
    instructions?: string | null;
    start_date?: Date | string | null;
    end_date?: Date | string | null;
    schedule_later?: boolean;
    start_time?: Date | string | null;
    end_time?: Date | string | null;
    any_time?: boolean;
    team?: string | null;
  };

  export type AssessmentsUncheckedCreateWithoutRequestsInput = {
    id?: number;
    instructions?: string | null;
    start_date?: Date | string | null;
    end_date?: Date | string | null;
    schedule_later?: boolean;
    start_time?: Date | string | null;
    end_time?: Date | string | null;
    any_time?: boolean;
    team?: string | null;
  };

  export type AssessmentsCreateOrConnectWithoutRequestsInput = {
    where: AssessmentsWhereUniqueInput;
    create: XOR<
      AssessmentsCreateWithoutRequestsInput,
      AssessmentsUncheckedCreateWithoutRequestsInput
    >;
  };

  export type ClientsCreateWithoutRequestsInput = {
    title: string;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    first_name: string;
    last_name: string;
    company_name?: string | null;
    use_company_name_as_primary?: boolean;
    mobile_phone_number?: string | null;
    work_phone_number?: string | null;
    email?: string | null;
    quote_follow_up?: boolean;
    job_follow_up?: boolean;
    invoice_follow_up?: boolean;
    upcoming_visit_reminder?: boolean;
    referred_by?: string | null;
    billing_address_same_as_property?: boolean;
    created_date?: Date | string;
    status?: string | null;
    property_address?: AddressesCreateNestedOneWithoutProperty_clientsInput;
    billing_address?: AddressesCreateNestedOneWithoutBilling_clientsInput;
    quotes?: QuotesCreateNestedManyWithoutClientInput;
    jobs?: JobsCreateNestedManyWithoutClientInput;
    invoices?: InvoicesCreateNestedManyWithoutClientInput;
    belongs_to: UsersCreateNestedOneWithoutClientsInput;
  };

  export type ClientsUncheckedCreateWithoutRequestsInput = {
    id?: number;
    title: string;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    first_name: string;
    last_name: string;
    company_name?: string | null;
    use_company_name_as_primary?: boolean;
    mobile_phone_number?: string | null;
    work_phone_number?: string | null;
    email?: string | null;
    quote_follow_up?: boolean;
    job_follow_up?: boolean;
    invoice_follow_up?: boolean;
    upcoming_visit_reminder?: boolean;
    referred_by?: string | null;
    billing_address_same_as_property?: boolean;
    property_address_id?: number | null;
    billing_address_id?: number | null;
    created_date?: Date | string;
    status?: string | null;
    belongs_to_id: number;
    quotes?: QuotesUncheckedCreateNestedManyWithoutClientInput;
    jobs?: JobsUncheckedCreateNestedManyWithoutClientInput;
    invoices?: InvoicesUncheckedCreateNestedManyWithoutClientInput;
  };

  export type ClientsCreateOrConnectWithoutRequestsInput = {
    where: ClientsWhereUniqueInput;
    create: XOR<
      ClientsCreateWithoutRequestsInput,
      ClientsUncheckedCreateWithoutRequestsInput
    >;
  };

  export type QuoteRequestCreateWithoutRequestInput = {
    quote: QuotesCreateNestedOneWithoutRequestsInput;
  };

  export type QuoteRequestUncheckedCreateWithoutRequestInput = {
    id?: number;
    quoteId: number;
  };

  export type QuoteRequestCreateOrConnectWithoutRequestInput = {
    where: QuoteRequestWhereUniqueInput;
    create: XOR<
      QuoteRequestCreateWithoutRequestInput,
      QuoteRequestUncheckedCreateWithoutRequestInput
    >;
  };

  export type QuoteRequestCreateManyRequestInputEnvelope = {
    data:
      | QuoteRequestCreateManyRequestInput
      | QuoteRequestCreateManyRequestInput[];
    skipDuplicates?: boolean;
  };

  export type JobRequestCreateWithoutRequestInput = {
    job: JobsCreateNestedOneWithoutJob_requestsInput;
  };

  export type JobRequestUncheckedCreateWithoutRequestInput = {
    id?: number;
    job_id: number;
  };

  export type JobRequestCreateOrConnectWithoutRequestInput = {
    where: JobRequestWhereUniqueInput;
    create: XOR<
      JobRequestCreateWithoutRequestInput,
      JobRequestUncheckedCreateWithoutRequestInput
    >;
  };

  export type JobRequestCreateManyRequestInputEnvelope = {
    data: JobRequestCreateManyRequestInput | JobRequestCreateManyRequestInput[];
    skipDuplicates?: boolean;
  };

  export type UsersCreateWithoutRequestsInput = {
    email?: string | null;
    password: string;
    first_name: string;
    last_name: string;
    phone_number?: string | null;
    company_name?: string | null;
    subscription_id?: string | null;
    free_trial_expiration_date?: Date | string | null;
    settings?: NullableJsonNullValueInput | InputJsonValue;
    default_tax?: TaxesCreateNestedOneWithoutUsersInput;
    address?: AddressesCreateNestedOneWithoutUsersInput;
    clients?: ClientsCreateNestedManyWithoutBelongs_toInput;
    jobs?: JobsCreateNestedManyWithoutBelongs_toInput;
    quotes?: QuotesCreateNestedManyWithoutBelongs_toInput;
    invoices?: InvoicesCreateNestedManyWithoutBelongs_toInput;
  };

  export type UsersUncheckedCreateWithoutRequestsInput = {
    id?: number;
    email?: string | null;
    password: string;
    first_name: string;
    last_name: string;
    phone_number?: string | null;
    company_name?: string | null;
    subscription_id?: string | null;
    free_trial_expiration_date?: Date | string | null;
    default_tax_id?: number | null;
    address_id?: number | null;
    settings?: NullableJsonNullValueInput | InputJsonValue;
    clients?: ClientsUncheckedCreateNestedManyWithoutBelongs_toInput;
    jobs?: JobsUncheckedCreateNestedManyWithoutBelongs_toInput;
    quotes?: QuotesUncheckedCreateNestedManyWithoutBelongs_toInput;
    invoices?: InvoicesUncheckedCreateNestedManyWithoutBelongs_toInput;
  };

  export type UsersCreateOrConnectWithoutRequestsInput = {
    where: UsersWhereUniqueInput;
    create: XOR<
      UsersCreateWithoutRequestsInput,
      UsersUncheckedCreateWithoutRequestsInput
    >;
  };

  export type AssessmentsUpsertWithoutRequestsInput = {
    update: XOR<
      AssessmentsUpdateWithoutRequestsInput,
      AssessmentsUncheckedUpdateWithoutRequestsInput
    >;
    create: XOR<
      AssessmentsCreateWithoutRequestsInput,
      AssessmentsUncheckedCreateWithoutRequestsInput
    >;
    where?: AssessmentsWhereInput;
  };

  export type AssessmentsUpdateToOneWithWhereWithoutRequestsInput = {
    where?: AssessmentsWhereInput;
    data: XOR<
      AssessmentsUpdateWithoutRequestsInput,
      AssessmentsUncheckedUpdateWithoutRequestsInput
    >;
  };

  export type AssessmentsUpdateWithoutRequestsInput = {
    instructions?: NullableStringFieldUpdateOperationsInput | string | null;
    start_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    end_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    schedule_later?: BoolFieldUpdateOperationsInput | boolean;
    start_time?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    end_time?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    any_time?: BoolFieldUpdateOperationsInput | boolean;
    team?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type AssessmentsUncheckedUpdateWithoutRequestsInput = {
    id?: IntFieldUpdateOperationsInput | number;
    instructions?: NullableStringFieldUpdateOperationsInput | string | null;
    start_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    end_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    schedule_later?: BoolFieldUpdateOperationsInput | boolean;
    start_time?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    end_time?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    any_time?: BoolFieldUpdateOperationsInput | boolean;
    team?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type ClientsUpsertWithoutRequestsInput = {
    update: XOR<
      ClientsUpdateWithoutRequestsInput,
      ClientsUncheckedUpdateWithoutRequestsInput
    >;
    create: XOR<
      ClientsCreateWithoutRequestsInput,
      ClientsUncheckedCreateWithoutRequestsInput
    >;
    where?: ClientsWhereInput;
  };

  export type ClientsUpdateToOneWithWhereWithoutRequestsInput = {
    where?: ClientsWhereInput;
    data: XOR<
      ClientsUpdateWithoutRequestsInput,
      ClientsUncheckedUpdateWithoutRequestsInput
    >;
  };

  export type ClientsUpdateWithoutRequestsInput = {
    title?: StringFieldUpdateOperationsInput | string;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    first_name?: StringFieldUpdateOperationsInput | string;
    last_name?: StringFieldUpdateOperationsInput | string;
    company_name?: NullableStringFieldUpdateOperationsInput | string | null;
    use_company_name_as_primary?: BoolFieldUpdateOperationsInput | boolean;
    mobile_phone_number?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    work_phone_number?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    quote_follow_up?: BoolFieldUpdateOperationsInput | boolean;
    job_follow_up?: BoolFieldUpdateOperationsInput | boolean;
    invoice_follow_up?: BoolFieldUpdateOperationsInput | boolean;
    upcoming_visit_reminder?: BoolFieldUpdateOperationsInput | boolean;
    referred_by?: NullableStringFieldUpdateOperationsInput | string | null;
    billing_address_same_as_property?: BoolFieldUpdateOperationsInput | boolean;
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string;
    status?: NullableStringFieldUpdateOperationsInput | string | null;
    property_address?: AddressesUpdateOneWithoutProperty_clientsNestedInput;
    billing_address?: AddressesUpdateOneWithoutBilling_clientsNestedInput;
    quotes?: QuotesUpdateManyWithoutClientNestedInput;
    jobs?: JobsUpdateManyWithoutClientNestedInput;
    invoices?: InvoicesUpdateManyWithoutClientNestedInput;
    belongs_to?: UsersUpdateOneRequiredWithoutClientsNestedInput;
  };

  export type ClientsUncheckedUpdateWithoutRequestsInput = {
    id?: IntFieldUpdateOperationsInput | number;
    title?: StringFieldUpdateOperationsInput | string;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    first_name?: StringFieldUpdateOperationsInput | string;
    last_name?: StringFieldUpdateOperationsInput | string;
    company_name?: NullableStringFieldUpdateOperationsInput | string | null;
    use_company_name_as_primary?: BoolFieldUpdateOperationsInput | boolean;
    mobile_phone_number?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    work_phone_number?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    quote_follow_up?: BoolFieldUpdateOperationsInput | boolean;
    job_follow_up?: BoolFieldUpdateOperationsInput | boolean;
    invoice_follow_up?: BoolFieldUpdateOperationsInput | boolean;
    upcoming_visit_reminder?: BoolFieldUpdateOperationsInput | boolean;
    referred_by?: NullableStringFieldUpdateOperationsInput | string | null;
    billing_address_same_as_property?: BoolFieldUpdateOperationsInput | boolean;
    property_address_id?: NullableIntFieldUpdateOperationsInput | number | null;
    billing_address_id?: NullableIntFieldUpdateOperationsInput | number | null;
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string;
    status?: NullableStringFieldUpdateOperationsInput | string | null;
    belongs_to_id?: IntFieldUpdateOperationsInput | number;
    quotes?: QuotesUncheckedUpdateManyWithoutClientNestedInput;
    jobs?: JobsUncheckedUpdateManyWithoutClientNestedInput;
    invoices?: InvoicesUncheckedUpdateManyWithoutClientNestedInput;
  };

  export type QuoteRequestUpsertWithWhereUniqueWithoutRequestInput = {
    where: QuoteRequestWhereUniqueInput;
    update: XOR<
      QuoteRequestUpdateWithoutRequestInput,
      QuoteRequestUncheckedUpdateWithoutRequestInput
    >;
    create: XOR<
      QuoteRequestCreateWithoutRequestInput,
      QuoteRequestUncheckedCreateWithoutRequestInput
    >;
  };

  export type QuoteRequestUpdateWithWhereUniqueWithoutRequestInput = {
    where: QuoteRequestWhereUniqueInput;
    data: XOR<
      QuoteRequestUpdateWithoutRequestInput,
      QuoteRequestUncheckedUpdateWithoutRequestInput
    >;
  };

  export type QuoteRequestUpdateManyWithWhereWithoutRequestInput = {
    where: QuoteRequestScalarWhereInput;
    data: XOR<
      QuoteRequestUpdateManyMutationInput,
      QuoteRequestUncheckedUpdateManyWithoutRequestInput
    >;
  };

  export type QuoteRequestScalarWhereInput = {
    AND?: QuoteRequestScalarWhereInput | QuoteRequestScalarWhereInput[];
    OR?: QuoteRequestScalarWhereInput[];
    NOT?: QuoteRequestScalarWhereInput | QuoteRequestScalarWhereInput[];
    id?: IntFilter<"QuoteRequest"> | number;
    quoteId?: IntFilter<"QuoteRequest"> | number;
    requestId?: IntFilter<"QuoteRequest"> | number;
  };

  export type JobRequestUpsertWithWhereUniqueWithoutRequestInput = {
    where: JobRequestWhereUniqueInput;
    update: XOR<
      JobRequestUpdateWithoutRequestInput,
      JobRequestUncheckedUpdateWithoutRequestInput
    >;
    create: XOR<
      JobRequestCreateWithoutRequestInput,
      JobRequestUncheckedCreateWithoutRequestInput
    >;
  };

  export type JobRequestUpdateWithWhereUniqueWithoutRequestInput = {
    where: JobRequestWhereUniqueInput;
    data: XOR<
      JobRequestUpdateWithoutRequestInput,
      JobRequestUncheckedUpdateWithoutRequestInput
    >;
  };

  export type JobRequestUpdateManyWithWhereWithoutRequestInput = {
    where: JobRequestScalarWhereInput;
    data: XOR<
      JobRequestUpdateManyMutationInput,
      JobRequestUncheckedUpdateManyWithoutRequestInput
    >;
  };

  export type JobRequestScalarWhereInput = {
    AND?: JobRequestScalarWhereInput | JobRequestScalarWhereInput[];
    OR?: JobRequestScalarWhereInput[];
    NOT?: JobRequestScalarWhereInput | JobRequestScalarWhereInput[];
    id?: IntFilter<"JobRequest"> | number;
    job_id?: IntFilter<"JobRequest"> | number;
    request_id?: IntFilter<"JobRequest"> | number;
  };

  export type UsersUpsertWithoutRequestsInput = {
    update: XOR<
      UsersUpdateWithoutRequestsInput,
      UsersUncheckedUpdateWithoutRequestsInput
    >;
    create: XOR<
      UsersCreateWithoutRequestsInput,
      UsersUncheckedCreateWithoutRequestsInput
    >;
    where?: UsersWhereInput;
  };

  export type UsersUpdateToOneWithWhereWithoutRequestsInput = {
    where?: UsersWhereInput;
    data: XOR<
      UsersUpdateWithoutRequestsInput,
      UsersUncheckedUpdateWithoutRequestsInput
    >;
  };

  export type UsersUpdateWithoutRequestsInput = {
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: StringFieldUpdateOperationsInput | string;
    first_name?: StringFieldUpdateOperationsInput | string;
    last_name?: StringFieldUpdateOperationsInput | string;
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null;
    company_name?: NullableStringFieldUpdateOperationsInput | string | null;
    subscription_id?: NullableStringFieldUpdateOperationsInput | string | null;
    free_trial_expiration_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    settings?: NullableJsonNullValueInput | InputJsonValue;
    default_tax?: TaxesUpdateOneWithoutUsersNestedInput;
    address?: AddressesUpdateOneWithoutUsersNestedInput;
    clients?: ClientsUpdateManyWithoutBelongs_toNestedInput;
    jobs?: JobsUpdateManyWithoutBelongs_toNestedInput;
    quotes?: QuotesUpdateManyWithoutBelongs_toNestedInput;
    invoices?: InvoicesUpdateManyWithoutBelongs_toNestedInput;
  };

  export type UsersUncheckedUpdateWithoutRequestsInput = {
    id?: IntFieldUpdateOperationsInput | number;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: StringFieldUpdateOperationsInput | string;
    first_name?: StringFieldUpdateOperationsInput | string;
    last_name?: StringFieldUpdateOperationsInput | string;
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null;
    company_name?: NullableStringFieldUpdateOperationsInput | string | null;
    subscription_id?: NullableStringFieldUpdateOperationsInput | string | null;
    free_trial_expiration_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    default_tax_id?: NullableIntFieldUpdateOperationsInput | number | null;
    address_id?: NullableIntFieldUpdateOperationsInput | number | null;
    settings?: NullableJsonNullValueInput | InputJsonValue;
    clients?: ClientsUncheckedUpdateManyWithoutBelongs_toNestedInput;
    jobs?: JobsUncheckedUpdateManyWithoutBelongs_toNestedInput;
    quotes?: QuotesUncheckedUpdateManyWithoutBelongs_toNestedInput;
    invoices?: InvoicesUncheckedUpdateManyWithoutBelongs_toNestedInput;
  };

  export type LineItemQuoteCreateWithoutLine_itemInput = {
    quote: QuotesCreateNestedOneWithoutLine_itemsInput;
  };

  export type LineItemQuoteUncheckedCreateWithoutLine_itemInput = {
    id?: number;
    quote_id: number;
  };

  export type LineItemQuoteCreateOrConnectWithoutLine_itemInput = {
    where: LineItemQuoteWhereUniqueInput;
    create: XOR<
      LineItemQuoteCreateWithoutLine_itemInput,
      LineItemQuoteUncheckedCreateWithoutLine_itemInput
    >;
  };

  export type LineItemQuoteCreateManyLine_itemInputEnvelope = {
    data:
      | LineItemQuoteCreateManyLine_itemInput
      | LineItemQuoteCreateManyLine_itemInput[];
    skipDuplicates?: boolean;
  };

  export type LineItemInvoiceCreateWithoutLine_itemInput = {
    invoice: InvoicesCreateNestedOneWithoutAdditional_line_itemsInput;
  };

  export type LineItemInvoiceUncheckedCreateWithoutLine_itemInput = {
    id?: number;
    invoice_id: number;
  };

  export type LineItemInvoiceCreateOrConnectWithoutLine_itemInput = {
    where: LineItemInvoiceWhereUniqueInput;
    create: XOR<
      LineItemInvoiceCreateWithoutLine_itemInput,
      LineItemInvoiceUncheckedCreateWithoutLine_itemInput
    >;
  };

  export type LineItemInvoiceCreateManyLine_itemInputEnvelope = {
    data:
      | LineItemInvoiceCreateManyLine_itemInput
      | LineItemInvoiceCreateManyLine_itemInput[];
    skipDuplicates?: boolean;
  };

  export type LineItemJobCreateWithoutLine_itemInput = {
    job: JobsCreateNestedOneWithoutLine_itemsInput;
  };

  export type LineItemJobUncheckedCreateWithoutLine_itemInput = {
    id?: number;
    job_id: number;
  };

  export type LineItemJobCreateOrConnectWithoutLine_itemInput = {
    where: LineItemJobWhereUniqueInput;
    create: XOR<
      LineItemJobCreateWithoutLine_itemInput,
      LineItemJobUncheckedCreateWithoutLine_itemInput
    >;
  };

  export type LineItemJobCreateManyLine_itemInputEnvelope = {
    data:
      | LineItemJobCreateManyLine_itemInput
      | LineItemJobCreateManyLine_itemInput[];
    skipDuplicates?: boolean;
  };

  export type LineItemQuoteUpsertWithWhereUniqueWithoutLine_itemInput = {
    where: LineItemQuoteWhereUniqueInput;
    update: XOR<
      LineItemQuoteUpdateWithoutLine_itemInput,
      LineItemQuoteUncheckedUpdateWithoutLine_itemInput
    >;
    create: XOR<
      LineItemQuoteCreateWithoutLine_itemInput,
      LineItemQuoteUncheckedCreateWithoutLine_itemInput
    >;
  };

  export type LineItemQuoteUpdateWithWhereUniqueWithoutLine_itemInput = {
    where: LineItemQuoteWhereUniqueInput;
    data: XOR<
      LineItemQuoteUpdateWithoutLine_itemInput,
      LineItemQuoteUncheckedUpdateWithoutLine_itemInput
    >;
  };

  export type LineItemQuoteUpdateManyWithWhereWithoutLine_itemInput = {
    where: LineItemQuoteScalarWhereInput;
    data: XOR<
      LineItemQuoteUpdateManyMutationInput,
      LineItemQuoteUncheckedUpdateManyWithoutLine_itemInput
    >;
  };

  export type LineItemQuoteScalarWhereInput = {
    AND?: LineItemQuoteScalarWhereInput | LineItemQuoteScalarWhereInput[];
    OR?: LineItemQuoteScalarWhereInput[];
    NOT?: LineItemQuoteScalarWhereInput | LineItemQuoteScalarWhereInput[];
    id?: IntFilter<"LineItemQuote"> | number;
    quote_id?: IntFilter<"LineItemQuote"> | number;
    line_item_id?: IntFilter<"LineItemQuote"> | number;
  };

  export type LineItemInvoiceUpsertWithWhereUniqueWithoutLine_itemInput = {
    where: LineItemInvoiceWhereUniqueInput;
    update: XOR<
      LineItemInvoiceUpdateWithoutLine_itemInput,
      LineItemInvoiceUncheckedUpdateWithoutLine_itemInput
    >;
    create: XOR<
      LineItemInvoiceCreateWithoutLine_itemInput,
      LineItemInvoiceUncheckedCreateWithoutLine_itemInput
    >;
  };

  export type LineItemInvoiceUpdateWithWhereUniqueWithoutLine_itemInput = {
    where: LineItemInvoiceWhereUniqueInput;
    data: XOR<
      LineItemInvoiceUpdateWithoutLine_itemInput,
      LineItemInvoiceUncheckedUpdateWithoutLine_itemInput
    >;
  };

  export type LineItemInvoiceUpdateManyWithWhereWithoutLine_itemInput = {
    where: LineItemInvoiceScalarWhereInput;
    data: XOR<
      LineItemInvoiceUpdateManyMutationInput,
      LineItemInvoiceUncheckedUpdateManyWithoutLine_itemInput
    >;
  };

  export type LineItemInvoiceScalarWhereInput = {
    AND?: LineItemInvoiceScalarWhereInput | LineItemInvoiceScalarWhereInput[];
    OR?: LineItemInvoiceScalarWhereInput[];
    NOT?: LineItemInvoiceScalarWhereInput | LineItemInvoiceScalarWhereInput[];
    id?: IntFilter<"LineItemInvoice"> | number;
    invoice_id?: IntFilter<"LineItemInvoice"> | number;
    line_item_id?: IntFilter<"LineItemInvoice"> | number;
  };

  export type LineItemJobUpsertWithWhereUniqueWithoutLine_itemInput = {
    where: LineItemJobWhereUniqueInput;
    update: XOR<
      LineItemJobUpdateWithoutLine_itemInput,
      LineItemJobUncheckedUpdateWithoutLine_itemInput
    >;
    create: XOR<
      LineItemJobCreateWithoutLine_itemInput,
      LineItemJobUncheckedCreateWithoutLine_itemInput
    >;
  };

  export type LineItemJobUpdateWithWhereUniqueWithoutLine_itemInput = {
    where: LineItemJobWhereUniqueInput;
    data: XOR<
      LineItemJobUpdateWithoutLine_itemInput,
      LineItemJobUncheckedUpdateWithoutLine_itemInput
    >;
  };

  export type LineItemJobUpdateManyWithWhereWithoutLine_itemInput = {
    where: LineItemJobScalarWhereInput;
    data: XOR<
      LineItemJobUpdateManyMutationInput,
      LineItemJobUncheckedUpdateManyWithoutLine_itemInput
    >;
  };

  export type LineItemJobScalarWhereInput = {
    AND?: LineItemJobScalarWhereInput | LineItemJobScalarWhereInput[];
    OR?: LineItemJobScalarWhereInput[];
    NOT?: LineItemJobScalarWhereInput | LineItemJobScalarWhereInput[];
    id?: IntFilter<"LineItemJob"> | number;
    job_id?: IntFilter<"LineItemJob"> | number;
    line_item_id?: IntFilter<"LineItemJob"> | number;
  };

  export type ClientsCreateWithoutQuotesInput = {
    title: string;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    first_name: string;
    last_name: string;
    company_name?: string | null;
    use_company_name_as_primary?: boolean;
    mobile_phone_number?: string | null;
    work_phone_number?: string | null;
    email?: string | null;
    quote_follow_up?: boolean;
    job_follow_up?: boolean;
    invoice_follow_up?: boolean;
    upcoming_visit_reminder?: boolean;
    referred_by?: string | null;
    billing_address_same_as_property?: boolean;
    created_date?: Date | string;
    status?: string | null;
    property_address?: AddressesCreateNestedOneWithoutProperty_clientsInput;
    billing_address?: AddressesCreateNestedOneWithoutBilling_clientsInput;
    requests?: RequestsCreateNestedManyWithoutClientInput;
    jobs?: JobsCreateNestedManyWithoutClientInput;
    invoices?: InvoicesCreateNestedManyWithoutClientInput;
    belongs_to: UsersCreateNestedOneWithoutClientsInput;
  };

  export type ClientsUncheckedCreateWithoutQuotesInput = {
    id?: number;
    title: string;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    first_name: string;
    last_name: string;
    company_name?: string | null;
    use_company_name_as_primary?: boolean;
    mobile_phone_number?: string | null;
    work_phone_number?: string | null;
    email?: string | null;
    quote_follow_up?: boolean;
    job_follow_up?: boolean;
    invoice_follow_up?: boolean;
    upcoming_visit_reminder?: boolean;
    referred_by?: string | null;
    billing_address_same_as_property?: boolean;
    property_address_id?: number | null;
    billing_address_id?: number | null;
    created_date?: Date | string;
    status?: string | null;
    belongs_to_id: number;
    requests?: RequestsUncheckedCreateNestedManyWithoutClientInput;
    jobs?: JobsUncheckedCreateNestedManyWithoutClientInput;
    invoices?: InvoicesUncheckedCreateNestedManyWithoutClientInput;
  };

  export type ClientsCreateOrConnectWithoutQuotesInput = {
    where: ClientsWhereUniqueInput;
    create: XOR<
      ClientsCreateWithoutQuotesInput,
      ClientsUncheckedCreateWithoutQuotesInput
    >;
  };

  export type LineItemQuoteCreateWithoutQuoteInput = {
    line_item: LineItemsCreateNestedOneWithoutQuotesInput;
  };

  export type LineItemQuoteUncheckedCreateWithoutQuoteInput = {
    id?: number;
    line_item_id: number;
  };

  export type LineItemQuoteCreateOrConnectWithoutQuoteInput = {
    where: LineItemQuoteWhereUniqueInput;
    create: XOR<
      LineItemQuoteCreateWithoutQuoteInput,
      LineItemQuoteUncheckedCreateWithoutQuoteInput
    >;
  };

  export type LineItemQuoteCreateManyQuoteInputEnvelope = {
    data:
      | LineItemQuoteCreateManyQuoteInput
      | LineItemQuoteCreateManyQuoteInput[];
    skipDuplicates?: boolean;
  };

  export type TaxesCreateWithoutQuotesInput = {
    name: string;
    rate: number;
    description?: string | null;
    users?: UsersCreateNestedManyWithoutDefault_taxInput;
    invoices?: InvoicesCreateNestedManyWithoutTaxInput;
  };

  export type TaxesUncheckedCreateWithoutQuotesInput = {
    id?: number;
    name: string;
    rate: number;
    description?: string | null;
    users?: UsersUncheckedCreateNestedManyWithoutDefault_taxInput;
    invoices?: InvoicesUncheckedCreateNestedManyWithoutTaxInput;
  };

  export type TaxesCreateOrConnectWithoutQuotesInput = {
    where: TaxesWhereUniqueInput;
    create: XOR<
      TaxesCreateWithoutQuotesInput,
      TaxesUncheckedCreateWithoutQuotesInput
    >;
  };

  export type QuoteRequestCreateWithoutQuoteInput = {
    request: RequestsCreateNestedOneWithoutQuotesInput;
  };

  export type QuoteRequestUncheckedCreateWithoutQuoteInput = {
    id?: number;
    requestId: number;
  };

  export type QuoteRequestCreateOrConnectWithoutQuoteInput = {
    where: QuoteRequestWhereUniqueInput;
    create: XOR<
      QuoteRequestCreateWithoutQuoteInput,
      QuoteRequestUncheckedCreateWithoutQuoteInput
    >;
  };

  export type QuoteRequestCreateManyQuoteInputEnvelope = {
    data: QuoteRequestCreateManyQuoteInput | QuoteRequestCreateManyQuoteInput[];
    skipDuplicates?: boolean;
  };

  export type JobQuoteCreateWithoutQuoteInput = {
    job: JobsCreateNestedOneWithoutJob_quotesInput;
  };

  export type JobQuoteUncheckedCreateWithoutQuoteInput = {
    id?: number;
    job_id: number;
  };

  export type JobQuoteCreateOrConnectWithoutQuoteInput = {
    where: JobQuoteWhereUniqueInput;
    create: XOR<
      JobQuoteCreateWithoutQuoteInput,
      JobQuoteUncheckedCreateWithoutQuoteInput
    >;
  };

  export type JobQuoteCreateManyQuoteInputEnvelope = {
    data: JobQuoteCreateManyQuoteInput | JobQuoteCreateManyQuoteInput[];
    skipDuplicates?: boolean;
  };

  export type UsersCreateWithoutQuotesInput = {
    email?: string | null;
    password: string;
    first_name: string;
    last_name: string;
    phone_number?: string | null;
    company_name?: string | null;
    subscription_id?: string | null;
    free_trial_expiration_date?: Date | string | null;
    settings?: NullableJsonNullValueInput | InputJsonValue;
    default_tax?: TaxesCreateNestedOneWithoutUsersInput;
    address?: AddressesCreateNestedOneWithoutUsersInput;
    clients?: ClientsCreateNestedManyWithoutBelongs_toInput;
    requests?: RequestsCreateNestedManyWithoutBelongs_toInput;
    jobs?: JobsCreateNestedManyWithoutBelongs_toInput;
    invoices?: InvoicesCreateNestedManyWithoutBelongs_toInput;
  };

  export type UsersUncheckedCreateWithoutQuotesInput = {
    id?: number;
    email?: string | null;
    password: string;
    first_name: string;
    last_name: string;
    phone_number?: string | null;
    company_name?: string | null;
    subscription_id?: string | null;
    free_trial_expiration_date?: Date | string | null;
    default_tax_id?: number | null;
    address_id?: number | null;
    settings?: NullableJsonNullValueInput | InputJsonValue;
    clients?: ClientsUncheckedCreateNestedManyWithoutBelongs_toInput;
    requests?: RequestsUncheckedCreateNestedManyWithoutBelongs_toInput;
    jobs?: JobsUncheckedCreateNestedManyWithoutBelongs_toInput;
    invoices?: InvoicesUncheckedCreateNestedManyWithoutBelongs_toInput;
  };

  export type UsersCreateOrConnectWithoutQuotesInput = {
    where: UsersWhereUniqueInput;
    create: XOR<
      UsersCreateWithoutQuotesInput,
      UsersUncheckedCreateWithoutQuotesInput
    >;
  };

  export type ClientsUpsertWithoutQuotesInput = {
    update: XOR<
      ClientsUpdateWithoutQuotesInput,
      ClientsUncheckedUpdateWithoutQuotesInput
    >;
    create: XOR<
      ClientsCreateWithoutQuotesInput,
      ClientsUncheckedCreateWithoutQuotesInput
    >;
    where?: ClientsWhereInput;
  };

  export type ClientsUpdateToOneWithWhereWithoutQuotesInput = {
    where?: ClientsWhereInput;
    data: XOR<
      ClientsUpdateWithoutQuotesInput,
      ClientsUncheckedUpdateWithoutQuotesInput
    >;
  };

  export type ClientsUpdateWithoutQuotesInput = {
    title?: StringFieldUpdateOperationsInput | string;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    first_name?: StringFieldUpdateOperationsInput | string;
    last_name?: StringFieldUpdateOperationsInput | string;
    company_name?: NullableStringFieldUpdateOperationsInput | string | null;
    use_company_name_as_primary?: BoolFieldUpdateOperationsInput | boolean;
    mobile_phone_number?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    work_phone_number?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    quote_follow_up?: BoolFieldUpdateOperationsInput | boolean;
    job_follow_up?: BoolFieldUpdateOperationsInput | boolean;
    invoice_follow_up?: BoolFieldUpdateOperationsInput | boolean;
    upcoming_visit_reminder?: BoolFieldUpdateOperationsInput | boolean;
    referred_by?: NullableStringFieldUpdateOperationsInput | string | null;
    billing_address_same_as_property?: BoolFieldUpdateOperationsInput | boolean;
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string;
    status?: NullableStringFieldUpdateOperationsInput | string | null;
    property_address?: AddressesUpdateOneWithoutProperty_clientsNestedInput;
    billing_address?: AddressesUpdateOneWithoutBilling_clientsNestedInput;
    requests?: RequestsUpdateManyWithoutClientNestedInput;
    jobs?: JobsUpdateManyWithoutClientNestedInput;
    invoices?: InvoicesUpdateManyWithoutClientNestedInput;
    belongs_to?: UsersUpdateOneRequiredWithoutClientsNestedInput;
  };

  export type ClientsUncheckedUpdateWithoutQuotesInput = {
    id?: IntFieldUpdateOperationsInput | number;
    title?: StringFieldUpdateOperationsInput | string;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    first_name?: StringFieldUpdateOperationsInput | string;
    last_name?: StringFieldUpdateOperationsInput | string;
    company_name?: NullableStringFieldUpdateOperationsInput | string | null;
    use_company_name_as_primary?: BoolFieldUpdateOperationsInput | boolean;
    mobile_phone_number?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    work_phone_number?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    quote_follow_up?: BoolFieldUpdateOperationsInput | boolean;
    job_follow_up?: BoolFieldUpdateOperationsInput | boolean;
    invoice_follow_up?: BoolFieldUpdateOperationsInput | boolean;
    upcoming_visit_reminder?: BoolFieldUpdateOperationsInput | boolean;
    referred_by?: NullableStringFieldUpdateOperationsInput | string | null;
    billing_address_same_as_property?: BoolFieldUpdateOperationsInput | boolean;
    property_address_id?: NullableIntFieldUpdateOperationsInput | number | null;
    billing_address_id?: NullableIntFieldUpdateOperationsInput | number | null;
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string;
    status?: NullableStringFieldUpdateOperationsInput | string | null;
    belongs_to_id?: IntFieldUpdateOperationsInput | number;
    requests?: RequestsUncheckedUpdateManyWithoutClientNestedInput;
    jobs?: JobsUncheckedUpdateManyWithoutClientNestedInput;
    invoices?: InvoicesUncheckedUpdateManyWithoutClientNestedInput;
  };

  export type LineItemQuoteUpsertWithWhereUniqueWithoutQuoteInput = {
    where: LineItemQuoteWhereUniqueInput;
    update: XOR<
      LineItemQuoteUpdateWithoutQuoteInput,
      LineItemQuoteUncheckedUpdateWithoutQuoteInput
    >;
    create: XOR<
      LineItemQuoteCreateWithoutQuoteInput,
      LineItemQuoteUncheckedCreateWithoutQuoteInput
    >;
  };

  export type LineItemQuoteUpdateWithWhereUniqueWithoutQuoteInput = {
    where: LineItemQuoteWhereUniqueInput;
    data: XOR<
      LineItemQuoteUpdateWithoutQuoteInput,
      LineItemQuoteUncheckedUpdateWithoutQuoteInput
    >;
  };

  export type LineItemQuoteUpdateManyWithWhereWithoutQuoteInput = {
    where: LineItemQuoteScalarWhereInput;
    data: XOR<
      LineItemQuoteUpdateManyMutationInput,
      LineItemQuoteUncheckedUpdateManyWithoutQuoteInput
    >;
  };

  export type TaxesUpsertWithoutQuotesInput = {
    update: XOR<
      TaxesUpdateWithoutQuotesInput,
      TaxesUncheckedUpdateWithoutQuotesInput
    >;
    create: XOR<
      TaxesCreateWithoutQuotesInput,
      TaxesUncheckedCreateWithoutQuotesInput
    >;
    where?: TaxesWhereInput;
  };

  export type TaxesUpdateToOneWithWhereWithoutQuotesInput = {
    where?: TaxesWhereInput;
    data: XOR<
      TaxesUpdateWithoutQuotesInput,
      TaxesUncheckedUpdateWithoutQuotesInput
    >;
  };

  export type TaxesUpdateWithoutQuotesInput = {
    name?: StringFieldUpdateOperationsInput | string;
    rate?: FloatFieldUpdateOperationsInput | number;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    users?: UsersUpdateManyWithoutDefault_taxNestedInput;
    invoices?: InvoicesUpdateManyWithoutTaxNestedInput;
  };

  export type TaxesUncheckedUpdateWithoutQuotesInput = {
    id?: IntFieldUpdateOperationsInput | number;
    name?: StringFieldUpdateOperationsInput | string;
    rate?: FloatFieldUpdateOperationsInput | number;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    users?: UsersUncheckedUpdateManyWithoutDefault_taxNestedInput;
    invoices?: InvoicesUncheckedUpdateManyWithoutTaxNestedInput;
  };

  export type QuoteRequestUpsertWithWhereUniqueWithoutQuoteInput = {
    where: QuoteRequestWhereUniqueInput;
    update: XOR<
      QuoteRequestUpdateWithoutQuoteInput,
      QuoteRequestUncheckedUpdateWithoutQuoteInput
    >;
    create: XOR<
      QuoteRequestCreateWithoutQuoteInput,
      QuoteRequestUncheckedCreateWithoutQuoteInput
    >;
  };

  export type QuoteRequestUpdateWithWhereUniqueWithoutQuoteInput = {
    where: QuoteRequestWhereUniqueInput;
    data: XOR<
      QuoteRequestUpdateWithoutQuoteInput,
      QuoteRequestUncheckedUpdateWithoutQuoteInput
    >;
  };

  export type QuoteRequestUpdateManyWithWhereWithoutQuoteInput = {
    where: QuoteRequestScalarWhereInput;
    data: XOR<
      QuoteRequestUpdateManyMutationInput,
      QuoteRequestUncheckedUpdateManyWithoutQuoteInput
    >;
  };

  export type JobQuoteUpsertWithWhereUniqueWithoutQuoteInput = {
    where: JobQuoteWhereUniqueInput;
    update: XOR<
      JobQuoteUpdateWithoutQuoteInput,
      JobQuoteUncheckedUpdateWithoutQuoteInput
    >;
    create: XOR<
      JobQuoteCreateWithoutQuoteInput,
      JobQuoteUncheckedCreateWithoutQuoteInput
    >;
  };

  export type JobQuoteUpdateWithWhereUniqueWithoutQuoteInput = {
    where: JobQuoteWhereUniqueInput;
    data: XOR<
      JobQuoteUpdateWithoutQuoteInput,
      JobQuoteUncheckedUpdateWithoutQuoteInput
    >;
  };

  export type JobQuoteUpdateManyWithWhereWithoutQuoteInput = {
    where: JobQuoteScalarWhereInput;
    data: XOR<
      JobQuoteUpdateManyMutationInput,
      JobQuoteUncheckedUpdateManyWithoutQuoteInput
    >;
  };

  export type JobQuoteScalarWhereInput = {
    AND?: JobQuoteScalarWhereInput | JobQuoteScalarWhereInput[];
    OR?: JobQuoteScalarWhereInput[];
    NOT?: JobQuoteScalarWhereInput | JobQuoteScalarWhereInput[];
    id?: IntFilter<"JobQuote"> | number;
    job_id?: IntFilter<"JobQuote"> | number;
    quote_id?: IntFilter<"JobQuote"> | number;
  };

  export type UsersUpsertWithoutQuotesInput = {
    update: XOR<
      UsersUpdateWithoutQuotesInput,
      UsersUncheckedUpdateWithoutQuotesInput
    >;
    create: XOR<
      UsersCreateWithoutQuotesInput,
      UsersUncheckedCreateWithoutQuotesInput
    >;
    where?: UsersWhereInput;
  };

  export type UsersUpdateToOneWithWhereWithoutQuotesInput = {
    where?: UsersWhereInput;
    data: XOR<
      UsersUpdateWithoutQuotesInput,
      UsersUncheckedUpdateWithoutQuotesInput
    >;
  };

  export type UsersUpdateWithoutQuotesInput = {
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: StringFieldUpdateOperationsInput | string;
    first_name?: StringFieldUpdateOperationsInput | string;
    last_name?: StringFieldUpdateOperationsInput | string;
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null;
    company_name?: NullableStringFieldUpdateOperationsInput | string | null;
    subscription_id?: NullableStringFieldUpdateOperationsInput | string | null;
    free_trial_expiration_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    settings?: NullableJsonNullValueInput | InputJsonValue;
    default_tax?: TaxesUpdateOneWithoutUsersNestedInput;
    address?: AddressesUpdateOneWithoutUsersNestedInput;
    clients?: ClientsUpdateManyWithoutBelongs_toNestedInput;
    requests?: RequestsUpdateManyWithoutBelongs_toNestedInput;
    jobs?: JobsUpdateManyWithoutBelongs_toNestedInput;
    invoices?: InvoicesUpdateManyWithoutBelongs_toNestedInput;
  };

  export type UsersUncheckedUpdateWithoutQuotesInput = {
    id?: IntFieldUpdateOperationsInput | number;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: StringFieldUpdateOperationsInput | string;
    first_name?: StringFieldUpdateOperationsInput | string;
    last_name?: StringFieldUpdateOperationsInput | string;
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null;
    company_name?: NullableStringFieldUpdateOperationsInput | string | null;
    subscription_id?: NullableStringFieldUpdateOperationsInput | string | null;
    free_trial_expiration_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    default_tax_id?: NullableIntFieldUpdateOperationsInput | number | null;
    address_id?: NullableIntFieldUpdateOperationsInput | number | null;
    settings?: NullableJsonNullValueInput | InputJsonValue;
    clients?: ClientsUncheckedUpdateManyWithoutBelongs_toNestedInput;
    requests?: RequestsUncheckedUpdateManyWithoutBelongs_toNestedInput;
    jobs?: JobsUncheckedUpdateManyWithoutBelongs_toNestedInput;
    invoices?: InvoicesUncheckedUpdateManyWithoutBelongs_toNestedInput;
  };

  export type QuotesCreateWithoutLine_itemsInput = {
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: boolean;
    texted_to_client?: boolean;
    status: string;
    title: string;
    quote_number: string;
    opportunity_rating?: string | null;
    client_message?: string | null;
    discount?: number | null;
    discount_unit?: string | null;
    required_deposit?: number | null;
    link_to_releated_jobs?: boolean;
    link_to_releated_invoices?: boolean;
    client: ClientsCreateNestedOneWithoutQuotesInput;
    tax?: TaxesCreateNestedOneWithoutQuotesInput;
    requests?: QuoteRequestCreateNestedManyWithoutQuoteInput;
    job_quotes?: JobQuoteCreateNestedManyWithoutQuoteInput;
    belongs_to: UsersCreateNestedOneWithoutQuotesInput;
  };

  export type QuotesUncheckedCreateWithoutLine_itemsInput = {
    id?: number;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: boolean;
    texted_to_client?: boolean;
    status: string;
    title: string;
    quote_number: string;
    opportunity_rating?: string | null;
    client_id: number;
    client_message?: string | null;
    discount?: number | null;
    discount_unit?: string | null;
    tax_id: number;
    required_deposit?: number | null;
    link_to_releated_jobs?: boolean;
    link_to_releated_invoices?: boolean;
    belongs_to_id: number;
    requests?: QuoteRequestUncheckedCreateNestedManyWithoutQuoteInput;
    job_quotes?: JobQuoteUncheckedCreateNestedManyWithoutQuoteInput;
  };

  export type QuotesCreateOrConnectWithoutLine_itemsInput = {
    where: QuotesWhereUniqueInput;
    create: XOR<
      QuotesCreateWithoutLine_itemsInput,
      QuotesUncheckedCreateWithoutLine_itemsInput
    >;
  };

  export type LineItemsCreateWithoutQuotesInput = {
    type: string;
    name: string;
    description?: string | null;
    quantity?: number;
    unit_price: number;
    markup?: number | null;
    img_url?: string | null;
    recommend_item?: boolean;
    invoices?: LineItemInvoiceCreateNestedManyWithoutLine_itemInput;
    jobs?: LineItemJobCreateNestedManyWithoutLine_itemInput;
  };

  export type LineItemsUncheckedCreateWithoutQuotesInput = {
    id?: number;
    type: string;
    name: string;
    description?: string | null;
    quantity?: number;
    unit_price: number;
    markup?: number | null;
    img_url?: string | null;
    recommend_item?: boolean;
    invoices?: LineItemInvoiceUncheckedCreateNestedManyWithoutLine_itemInput;
    jobs?: LineItemJobUncheckedCreateNestedManyWithoutLine_itemInput;
  };

  export type LineItemsCreateOrConnectWithoutQuotesInput = {
    where: LineItemsWhereUniqueInput;
    create: XOR<
      LineItemsCreateWithoutQuotesInput,
      LineItemsUncheckedCreateWithoutQuotesInput
    >;
  };

  export type QuotesUpsertWithoutLine_itemsInput = {
    update: XOR<
      QuotesUpdateWithoutLine_itemsInput,
      QuotesUncheckedUpdateWithoutLine_itemsInput
    >;
    create: XOR<
      QuotesCreateWithoutLine_itemsInput,
      QuotesUncheckedCreateWithoutLine_itemsInput
    >;
    where?: QuotesWhereInput;
  };

  export type QuotesUpdateToOneWithWhereWithoutLine_itemsInput = {
    where?: QuotesWhereInput;
    data: XOR<
      QuotesUpdateWithoutLine_itemsInput,
      QuotesUncheckedUpdateWithoutLine_itemsInput
    >;
  };

  export type QuotesUpdateWithoutLine_itemsInput = {
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: BoolFieldUpdateOperationsInput | boolean;
    texted_to_client?: BoolFieldUpdateOperationsInput | boolean;
    status?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    quote_number?: StringFieldUpdateOperationsInput | string;
    opportunity_rating?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    client_message?: NullableStringFieldUpdateOperationsInput | string | null;
    discount?: NullableFloatFieldUpdateOperationsInput | number | null;
    discount_unit?: NullableStringFieldUpdateOperationsInput | string | null;
    required_deposit?: NullableFloatFieldUpdateOperationsInput | number | null;
    link_to_releated_jobs?: BoolFieldUpdateOperationsInput | boolean;
    link_to_releated_invoices?: BoolFieldUpdateOperationsInput | boolean;
    client?: ClientsUpdateOneRequiredWithoutQuotesNestedInput;
    tax?: TaxesUpdateOneWithoutQuotesNestedInput;
    requests?: QuoteRequestUpdateManyWithoutQuoteNestedInput;
    job_quotes?: JobQuoteUpdateManyWithoutQuoteNestedInput;
    belongs_to?: UsersUpdateOneRequiredWithoutQuotesNestedInput;
  };

  export type QuotesUncheckedUpdateWithoutLine_itemsInput = {
    id?: IntFieldUpdateOperationsInput | number;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: BoolFieldUpdateOperationsInput | boolean;
    texted_to_client?: BoolFieldUpdateOperationsInput | boolean;
    status?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    quote_number?: StringFieldUpdateOperationsInput | string;
    opportunity_rating?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    client_id?: IntFieldUpdateOperationsInput | number;
    client_message?: NullableStringFieldUpdateOperationsInput | string | null;
    discount?: NullableFloatFieldUpdateOperationsInput | number | null;
    discount_unit?: NullableStringFieldUpdateOperationsInput | string | null;
    tax_id?: IntFieldUpdateOperationsInput | number;
    required_deposit?: NullableFloatFieldUpdateOperationsInput | number | null;
    link_to_releated_jobs?: BoolFieldUpdateOperationsInput | boolean;
    link_to_releated_invoices?: BoolFieldUpdateOperationsInput | boolean;
    belongs_to_id?: IntFieldUpdateOperationsInput | number;
    requests?: QuoteRequestUncheckedUpdateManyWithoutQuoteNestedInput;
    job_quotes?: JobQuoteUncheckedUpdateManyWithoutQuoteNestedInput;
  };

  export type LineItemsUpsertWithoutQuotesInput = {
    update: XOR<
      LineItemsUpdateWithoutQuotesInput,
      LineItemsUncheckedUpdateWithoutQuotesInput
    >;
    create: XOR<
      LineItemsCreateWithoutQuotesInput,
      LineItemsUncheckedCreateWithoutQuotesInput
    >;
    where?: LineItemsWhereInput;
  };

  export type LineItemsUpdateToOneWithWhereWithoutQuotesInput = {
    where?: LineItemsWhereInput;
    data: XOR<
      LineItemsUpdateWithoutQuotesInput,
      LineItemsUncheckedUpdateWithoutQuotesInput
    >;
  };

  export type LineItemsUpdateWithoutQuotesInput = {
    type?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    quantity?: IntFieldUpdateOperationsInput | number;
    unit_price?: FloatFieldUpdateOperationsInput | number;
    markup?: NullableFloatFieldUpdateOperationsInput | number | null;
    img_url?: NullableStringFieldUpdateOperationsInput | string | null;
    recommend_item?: BoolFieldUpdateOperationsInput | boolean;
    invoices?: LineItemInvoiceUpdateManyWithoutLine_itemNestedInput;
    jobs?: LineItemJobUpdateManyWithoutLine_itemNestedInput;
  };

  export type LineItemsUncheckedUpdateWithoutQuotesInput = {
    id?: IntFieldUpdateOperationsInput | number;
    type?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    quantity?: IntFieldUpdateOperationsInput | number;
    unit_price?: FloatFieldUpdateOperationsInput | number;
    markup?: NullableFloatFieldUpdateOperationsInput | number | null;
    img_url?: NullableStringFieldUpdateOperationsInput | string | null;
    recommend_item?: BoolFieldUpdateOperationsInput | boolean;
    invoices?: LineItemInvoiceUncheckedUpdateManyWithoutLine_itemNestedInput;
    jobs?: LineItemJobUncheckedUpdateManyWithoutLine_itemNestedInput;
  };

  export type QuotesCreateWithoutRequestsInput = {
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: boolean;
    texted_to_client?: boolean;
    status: string;
    title: string;
    quote_number: string;
    opportunity_rating?: string | null;
    client_message?: string | null;
    discount?: number | null;
    discount_unit?: string | null;
    required_deposit?: number | null;
    link_to_releated_jobs?: boolean;
    link_to_releated_invoices?: boolean;
    client: ClientsCreateNestedOneWithoutQuotesInput;
    line_items?: LineItemQuoteCreateNestedManyWithoutQuoteInput;
    tax?: TaxesCreateNestedOneWithoutQuotesInput;
    job_quotes?: JobQuoteCreateNestedManyWithoutQuoteInput;
    belongs_to: UsersCreateNestedOneWithoutQuotesInput;
  };

  export type QuotesUncheckedCreateWithoutRequestsInput = {
    id?: number;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: boolean;
    texted_to_client?: boolean;
    status: string;
    title: string;
    quote_number: string;
    opportunity_rating?: string | null;
    client_id: number;
    client_message?: string | null;
    discount?: number | null;
    discount_unit?: string | null;
    tax_id: number;
    required_deposit?: number | null;
    link_to_releated_jobs?: boolean;
    link_to_releated_invoices?: boolean;
    belongs_to_id: number;
    line_items?: LineItemQuoteUncheckedCreateNestedManyWithoutQuoteInput;
    job_quotes?: JobQuoteUncheckedCreateNestedManyWithoutQuoteInput;
  };

  export type QuotesCreateOrConnectWithoutRequestsInput = {
    where: QuotesWhereUniqueInput;
    create: XOR<
      QuotesCreateWithoutRequestsInput,
      QuotesUncheckedCreateWithoutRequestsInput
    >;
  };

  export type RequestsCreateWithoutQuotesInput = {
    status: string;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: boolean;
    texted_to_client?: boolean;
    title: string;
    service_details: string;
    assessment_date: Date | string;
    backup_assessment__date?: Date | string | null;
    preferred_arrival_times?: string | null;
    on_site_assesment_required?: boolean;
    internal_notes: string;
    internalAttachmentUrl: string;
    link_to_releated_quotes?: boolean;
    link_to_releated_jobs?: boolean;
    link_to_releated_invoices?: boolean;
    assessment: AssessmentsCreateNestedOneWithoutRequestsInput;
    client: ClientsCreateNestedOneWithoutRequestsInput;
    job_requests?: JobRequestCreateNestedManyWithoutRequestInput;
    belongs_to: UsersCreateNestedOneWithoutRequestsInput;
  };

  export type RequestsUncheckedCreateWithoutQuotesInput = {
    id?: number;
    status: string;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: boolean;
    texted_to_client?: boolean;
    title: string;
    service_details: string;
    assessment_date: Date | string;
    backup_assessment__date?: Date | string | null;
    preferred_arrival_times?: string | null;
    on_site_assesment_required?: boolean;
    client_id: number;
    assessment_id: number;
    internal_notes: string;
    internalAttachmentUrl: string;
    link_to_releated_quotes?: boolean;
    link_to_releated_jobs?: boolean;
    link_to_releated_invoices?: boolean;
    belongs_to_id: number;
    job_requests?: JobRequestUncheckedCreateNestedManyWithoutRequestInput;
  };

  export type RequestsCreateOrConnectWithoutQuotesInput = {
    where: RequestsWhereUniqueInput;
    create: XOR<
      RequestsCreateWithoutQuotesInput,
      RequestsUncheckedCreateWithoutQuotesInput
    >;
  };

  export type QuotesUpsertWithoutRequestsInput = {
    update: XOR<
      QuotesUpdateWithoutRequestsInput,
      QuotesUncheckedUpdateWithoutRequestsInput
    >;
    create: XOR<
      QuotesCreateWithoutRequestsInput,
      QuotesUncheckedCreateWithoutRequestsInput
    >;
    where?: QuotesWhereInput;
  };

  export type QuotesUpdateToOneWithWhereWithoutRequestsInput = {
    where?: QuotesWhereInput;
    data: XOR<
      QuotesUpdateWithoutRequestsInput,
      QuotesUncheckedUpdateWithoutRequestsInput
    >;
  };

  export type QuotesUpdateWithoutRequestsInput = {
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: BoolFieldUpdateOperationsInput | boolean;
    texted_to_client?: BoolFieldUpdateOperationsInput | boolean;
    status?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    quote_number?: StringFieldUpdateOperationsInput | string;
    opportunity_rating?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    client_message?: NullableStringFieldUpdateOperationsInput | string | null;
    discount?: NullableFloatFieldUpdateOperationsInput | number | null;
    discount_unit?: NullableStringFieldUpdateOperationsInput | string | null;
    required_deposit?: NullableFloatFieldUpdateOperationsInput | number | null;
    link_to_releated_jobs?: BoolFieldUpdateOperationsInput | boolean;
    link_to_releated_invoices?: BoolFieldUpdateOperationsInput | boolean;
    client?: ClientsUpdateOneRequiredWithoutQuotesNestedInput;
    line_items?: LineItemQuoteUpdateManyWithoutQuoteNestedInput;
    tax?: TaxesUpdateOneWithoutQuotesNestedInput;
    job_quotes?: JobQuoteUpdateManyWithoutQuoteNestedInput;
    belongs_to?: UsersUpdateOneRequiredWithoutQuotesNestedInput;
  };

  export type QuotesUncheckedUpdateWithoutRequestsInput = {
    id?: IntFieldUpdateOperationsInput | number;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: BoolFieldUpdateOperationsInput | boolean;
    texted_to_client?: BoolFieldUpdateOperationsInput | boolean;
    status?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    quote_number?: StringFieldUpdateOperationsInput | string;
    opportunity_rating?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    client_id?: IntFieldUpdateOperationsInput | number;
    client_message?: NullableStringFieldUpdateOperationsInput | string | null;
    discount?: NullableFloatFieldUpdateOperationsInput | number | null;
    discount_unit?: NullableStringFieldUpdateOperationsInput | string | null;
    tax_id?: IntFieldUpdateOperationsInput | number;
    required_deposit?: NullableFloatFieldUpdateOperationsInput | number | null;
    link_to_releated_jobs?: BoolFieldUpdateOperationsInput | boolean;
    link_to_releated_invoices?: BoolFieldUpdateOperationsInput | boolean;
    belongs_to_id?: IntFieldUpdateOperationsInput | number;
    line_items?: LineItemQuoteUncheckedUpdateManyWithoutQuoteNestedInput;
    job_quotes?: JobQuoteUncheckedUpdateManyWithoutQuoteNestedInput;
  };

  export type RequestsUpsertWithoutQuotesInput = {
    update: XOR<
      RequestsUpdateWithoutQuotesInput,
      RequestsUncheckedUpdateWithoutQuotesInput
    >;
    create: XOR<
      RequestsCreateWithoutQuotesInput,
      RequestsUncheckedCreateWithoutQuotesInput
    >;
    where?: RequestsWhereInput;
  };

  export type RequestsUpdateToOneWithWhereWithoutQuotesInput = {
    where?: RequestsWhereInput;
    data: XOR<
      RequestsUpdateWithoutQuotesInput,
      RequestsUncheckedUpdateWithoutQuotesInput
    >;
  };

  export type RequestsUpdateWithoutQuotesInput = {
    status?: StringFieldUpdateOperationsInput | string;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: BoolFieldUpdateOperationsInput | boolean;
    texted_to_client?: BoolFieldUpdateOperationsInput | boolean;
    title?: StringFieldUpdateOperationsInput | string;
    service_details?: StringFieldUpdateOperationsInput | string;
    assessment_date?: DateTimeFieldUpdateOperationsInput | Date | string;
    backup_assessment__date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    preferred_arrival_times?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    on_site_assesment_required?: BoolFieldUpdateOperationsInput | boolean;
    internal_notes?: StringFieldUpdateOperationsInput | string;
    internalAttachmentUrl?: StringFieldUpdateOperationsInput | string;
    link_to_releated_quotes?: BoolFieldUpdateOperationsInput | boolean;
    link_to_releated_jobs?: BoolFieldUpdateOperationsInput | boolean;
    link_to_releated_invoices?: BoolFieldUpdateOperationsInput | boolean;
    assessment?: AssessmentsUpdateOneRequiredWithoutRequestsNestedInput;
    client?: ClientsUpdateOneRequiredWithoutRequestsNestedInput;
    job_requests?: JobRequestUpdateManyWithoutRequestNestedInput;
    belongs_to?: UsersUpdateOneRequiredWithoutRequestsNestedInput;
  };

  export type RequestsUncheckedUpdateWithoutQuotesInput = {
    id?: IntFieldUpdateOperationsInput | number;
    status?: StringFieldUpdateOperationsInput | string;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: BoolFieldUpdateOperationsInput | boolean;
    texted_to_client?: BoolFieldUpdateOperationsInput | boolean;
    title?: StringFieldUpdateOperationsInput | string;
    service_details?: StringFieldUpdateOperationsInput | string;
    assessment_date?: DateTimeFieldUpdateOperationsInput | Date | string;
    backup_assessment__date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    preferred_arrival_times?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    on_site_assesment_required?: BoolFieldUpdateOperationsInput | boolean;
    client_id?: IntFieldUpdateOperationsInput | number;
    assessment_id?: IntFieldUpdateOperationsInput | number;
    internal_notes?: StringFieldUpdateOperationsInput | string;
    internalAttachmentUrl?: StringFieldUpdateOperationsInput | string;
    link_to_releated_quotes?: BoolFieldUpdateOperationsInput | boolean;
    link_to_releated_jobs?: BoolFieldUpdateOperationsInput | boolean;
    link_to_releated_invoices?: BoolFieldUpdateOperationsInput | boolean;
    belongs_to_id?: IntFieldUpdateOperationsInput | number;
    job_requests?: JobRequestUncheckedUpdateManyWithoutRequestNestedInput;
  };

  export type ClientsCreateWithoutJobsInput = {
    title: string;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    first_name: string;
    last_name: string;
    company_name?: string | null;
    use_company_name_as_primary?: boolean;
    mobile_phone_number?: string | null;
    work_phone_number?: string | null;
    email?: string | null;
    quote_follow_up?: boolean;
    job_follow_up?: boolean;
    invoice_follow_up?: boolean;
    upcoming_visit_reminder?: boolean;
    referred_by?: string | null;
    billing_address_same_as_property?: boolean;
    created_date?: Date | string;
    status?: string | null;
    property_address?: AddressesCreateNestedOneWithoutProperty_clientsInput;
    billing_address?: AddressesCreateNestedOneWithoutBilling_clientsInput;
    requests?: RequestsCreateNestedManyWithoutClientInput;
    quotes?: QuotesCreateNestedManyWithoutClientInput;
    invoices?: InvoicesCreateNestedManyWithoutClientInput;
    belongs_to: UsersCreateNestedOneWithoutClientsInput;
  };

  export type ClientsUncheckedCreateWithoutJobsInput = {
    id?: number;
    title: string;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    first_name: string;
    last_name: string;
    company_name?: string | null;
    use_company_name_as_primary?: boolean;
    mobile_phone_number?: string | null;
    work_phone_number?: string | null;
    email?: string | null;
    quote_follow_up?: boolean;
    job_follow_up?: boolean;
    invoice_follow_up?: boolean;
    upcoming_visit_reminder?: boolean;
    referred_by?: string | null;
    billing_address_same_as_property?: boolean;
    property_address_id?: number | null;
    billing_address_id?: number | null;
    created_date?: Date | string;
    status?: string | null;
    belongs_to_id: number;
    requests?: RequestsUncheckedCreateNestedManyWithoutClientInput;
    quotes?: QuotesUncheckedCreateNestedManyWithoutClientInput;
    invoices?: InvoicesUncheckedCreateNestedManyWithoutClientInput;
  };

  export type ClientsCreateOrConnectWithoutJobsInput = {
    where: ClientsWhereUniqueInput;
    create: XOR<
      ClientsCreateWithoutJobsInput,
      ClientsUncheckedCreateWithoutJobsInput
    >;
  };

  export type LineItemJobCreateWithoutJobInput = {
    line_item: LineItemsCreateNestedOneWithoutJobsInput;
  };

  export type LineItemJobUncheckedCreateWithoutJobInput = {
    id?: number;
    line_item_id: number;
  };

  export type LineItemJobCreateOrConnectWithoutJobInput = {
    where: LineItemJobWhereUniqueInput;
    create: XOR<
      LineItemJobCreateWithoutJobInput,
      LineItemJobUncheckedCreateWithoutJobInput
    >;
  };

  export type LineItemJobCreateManyJobInputEnvelope = {
    data: LineItemJobCreateManyJobInput | LineItemJobCreateManyJobInput[];
    skipDuplicates?: boolean;
  };

  export type JobRequestCreateWithoutJobInput = {
    request: RequestsCreateNestedOneWithoutJob_requestsInput;
  };

  export type JobRequestUncheckedCreateWithoutJobInput = {
    id?: number;
    request_id: number;
  };

  export type JobRequestCreateOrConnectWithoutJobInput = {
    where: JobRequestWhereUniqueInput;
    create: XOR<
      JobRequestCreateWithoutJobInput,
      JobRequestUncheckedCreateWithoutJobInput
    >;
  };

  export type JobRequestCreateManyJobInputEnvelope = {
    data: JobRequestCreateManyJobInput | JobRequestCreateManyJobInput[];
    skipDuplicates?: boolean;
  };

  export type JobQuoteCreateWithoutJobInput = {
    quote: QuotesCreateNestedOneWithoutJob_quotesInput;
  };

  export type JobQuoteUncheckedCreateWithoutJobInput = {
    id?: number;
    quote_id: number;
  };

  export type JobQuoteCreateOrConnectWithoutJobInput = {
    where: JobQuoteWhereUniqueInput;
    create: XOR<
      JobQuoteCreateWithoutJobInput,
      JobQuoteUncheckedCreateWithoutJobInput
    >;
  };

  export type JobQuoteCreateManyJobInputEnvelope = {
    data: JobQuoteCreateManyJobInput | JobQuoteCreateManyJobInput[];
    skipDuplicates?: boolean;
  };

  export type InvoicesCreateWithoutJobInput = {
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: boolean;
    texted_to_client?: boolean;
    issued_date: Date | string;
    due_date?: Date | string | null;
    status: string;
    type: string;
    subject: string;
    client_message: string;
    internal_notes: string;
    internalAttachmentUrl: string;
    client: ClientsCreateNestedOneWithoutInvoicesInput;
    tax?: TaxesCreateNestedOneWithoutInvoicesInput;
    additional_line_items?: LineItemInvoiceCreateNestedManyWithoutInvoiceInput;
    belongs_to: UsersCreateNestedOneWithoutInvoicesInput;
  };

  export type InvoicesUncheckedCreateWithoutJobInput = {
    id?: number;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: boolean;
    texted_to_client?: boolean;
    issued_date: Date | string;
    due_date?: Date | string | null;
    status: string;
    type: string;
    subject: string;
    client_id: number;
    tax_id?: number | null;
    client_message: string;
    internal_notes: string;
    internalAttachmentUrl: string;
    belongs_to_id: number;
    additional_line_items?: LineItemInvoiceUncheckedCreateNestedManyWithoutInvoiceInput;
  };

  export type InvoicesCreateOrConnectWithoutJobInput = {
    where: InvoicesWhereUniqueInput;
    create: XOR<
      InvoicesCreateWithoutJobInput,
      InvoicesUncheckedCreateWithoutJobInput
    >;
  };

  export type InvoicesCreateManyJobInputEnvelope = {
    data: InvoicesCreateManyJobInput | InvoicesCreateManyJobInput[];
    skipDuplicates?: boolean;
  };

  export type UsersCreateWithoutJobsInput = {
    email?: string | null;
    password: string;
    first_name: string;
    last_name: string;
    phone_number?: string | null;
    company_name?: string | null;
    subscription_id?: string | null;
    free_trial_expiration_date?: Date | string | null;
    settings?: NullableJsonNullValueInput | InputJsonValue;
    default_tax?: TaxesCreateNestedOneWithoutUsersInput;
    address?: AddressesCreateNestedOneWithoutUsersInput;
    clients?: ClientsCreateNestedManyWithoutBelongs_toInput;
    requests?: RequestsCreateNestedManyWithoutBelongs_toInput;
    quotes?: QuotesCreateNestedManyWithoutBelongs_toInput;
    invoices?: InvoicesCreateNestedManyWithoutBelongs_toInput;
  };

  export type UsersUncheckedCreateWithoutJobsInput = {
    id?: number;
    email?: string | null;
    password: string;
    first_name: string;
    last_name: string;
    phone_number?: string | null;
    company_name?: string | null;
    subscription_id?: string | null;
    free_trial_expiration_date?: Date | string | null;
    default_tax_id?: number | null;
    address_id?: number | null;
    settings?: NullableJsonNullValueInput | InputJsonValue;
    clients?: ClientsUncheckedCreateNestedManyWithoutBelongs_toInput;
    requests?: RequestsUncheckedCreateNestedManyWithoutBelongs_toInput;
    quotes?: QuotesUncheckedCreateNestedManyWithoutBelongs_toInput;
    invoices?: InvoicesUncheckedCreateNestedManyWithoutBelongs_toInput;
  };

  export type UsersCreateOrConnectWithoutJobsInput = {
    where: UsersWhereUniqueInput;
    create: XOR<
      UsersCreateWithoutJobsInput,
      UsersUncheckedCreateWithoutJobsInput
    >;
  };

  export type ClientsUpsertWithoutJobsInput = {
    update: XOR<
      ClientsUpdateWithoutJobsInput,
      ClientsUncheckedUpdateWithoutJobsInput
    >;
    create: XOR<
      ClientsCreateWithoutJobsInput,
      ClientsUncheckedCreateWithoutJobsInput
    >;
    where?: ClientsWhereInput;
  };

  export type ClientsUpdateToOneWithWhereWithoutJobsInput = {
    where?: ClientsWhereInput;
    data: XOR<
      ClientsUpdateWithoutJobsInput,
      ClientsUncheckedUpdateWithoutJobsInput
    >;
  };

  export type ClientsUpdateWithoutJobsInput = {
    title?: StringFieldUpdateOperationsInput | string;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    first_name?: StringFieldUpdateOperationsInput | string;
    last_name?: StringFieldUpdateOperationsInput | string;
    company_name?: NullableStringFieldUpdateOperationsInput | string | null;
    use_company_name_as_primary?: BoolFieldUpdateOperationsInput | boolean;
    mobile_phone_number?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    work_phone_number?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    quote_follow_up?: BoolFieldUpdateOperationsInput | boolean;
    job_follow_up?: BoolFieldUpdateOperationsInput | boolean;
    invoice_follow_up?: BoolFieldUpdateOperationsInput | boolean;
    upcoming_visit_reminder?: BoolFieldUpdateOperationsInput | boolean;
    referred_by?: NullableStringFieldUpdateOperationsInput | string | null;
    billing_address_same_as_property?: BoolFieldUpdateOperationsInput | boolean;
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string;
    status?: NullableStringFieldUpdateOperationsInput | string | null;
    property_address?: AddressesUpdateOneWithoutProperty_clientsNestedInput;
    billing_address?: AddressesUpdateOneWithoutBilling_clientsNestedInput;
    requests?: RequestsUpdateManyWithoutClientNestedInput;
    quotes?: QuotesUpdateManyWithoutClientNestedInput;
    invoices?: InvoicesUpdateManyWithoutClientNestedInput;
    belongs_to?: UsersUpdateOneRequiredWithoutClientsNestedInput;
  };

  export type ClientsUncheckedUpdateWithoutJobsInput = {
    id?: IntFieldUpdateOperationsInput | number;
    title?: StringFieldUpdateOperationsInput | string;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    first_name?: StringFieldUpdateOperationsInput | string;
    last_name?: StringFieldUpdateOperationsInput | string;
    company_name?: NullableStringFieldUpdateOperationsInput | string | null;
    use_company_name_as_primary?: BoolFieldUpdateOperationsInput | boolean;
    mobile_phone_number?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    work_phone_number?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    quote_follow_up?: BoolFieldUpdateOperationsInput | boolean;
    job_follow_up?: BoolFieldUpdateOperationsInput | boolean;
    invoice_follow_up?: BoolFieldUpdateOperationsInput | boolean;
    upcoming_visit_reminder?: BoolFieldUpdateOperationsInput | boolean;
    referred_by?: NullableStringFieldUpdateOperationsInput | string | null;
    billing_address_same_as_property?: BoolFieldUpdateOperationsInput | boolean;
    property_address_id?: NullableIntFieldUpdateOperationsInput | number | null;
    billing_address_id?: NullableIntFieldUpdateOperationsInput | number | null;
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string;
    status?: NullableStringFieldUpdateOperationsInput | string | null;
    belongs_to_id?: IntFieldUpdateOperationsInput | number;
    requests?: RequestsUncheckedUpdateManyWithoutClientNestedInput;
    quotes?: QuotesUncheckedUpdateManyWithoutClientNestedInput;
    invoices?: InvoicesUncheckedUpdateManyWithoutClientNestedInput;
  };

  export type LineItemJobUpsertWithWhereUniqueWithoutJobInput = {
    where: LineItemJobWhereUniqueInput;
    update: XOR<
      LineItemJobUpdateWithoutJobInput,
      LineItemJobUncheckedUpdateWithoutJobInput
    >;
    create: XOR<
      LineItemJobCreateWithoutJobInput,
      LineItemJobUncheckedCreateWithoutJobInput
    >;
  };

  export type LineItemJobUpdateWithWhereUniqueWithoutJobInput = {
    where: LineItemJobWhereUniqueInput;
    data: XOR<
      LineItemJobUpdateWithoutJobInput,
      LineItemJobUncheckedUpdateWithoutJobInput
    >;
  };

  export type LineItemJobUpdateManyWithWhereWithoutJobInput = {
    where: LineItemJobScalarWhereInput;
    data: XOR<
      LineItemJobUpdateManyMutationInput,
      LineItemJobUncheckedUpdateManyWithoutJobInput
    >;
  };

  export type JobRequestUpsertWithWhereUniqueWithoutJobInput = {
    where: JobRequestWhereUniqueInput;
    update: XOR<
      JobRequestUpdateWithoutJobInput,
      JobRequestUncheckedUpdateWithoutJobInput
    >;
    create: XOR<
      JobRequestCreateWithoutJobInput,
      JobRequestUncheckedCreateWithoutJobInput
    >;
  };

  export type JobRequestUpdateWithWhereUniqueWithoutJobInput = {
    where: JobRequestWhereUniqueInput;
    data: XOR<
      JobRequestUpdateWithoutJobInput,
      JobRequestUncheckedUpdateWithoutJobInput
    >;
  };

  export type JobRequestUpdateManyWithWhereWithoutJobInput = {
    where: JobRequestScalarWhereInput;
    data: XOR<
      JobRequestUpdateManyMutationInput,
      JobRequestUncheckedUpdateManyWithoutJobInput
    >;
  };

  export type JobQuoteUpsertWithWhereUniqueWithoutJobInput = {
    where: JobQuoteWhereUniqueInput;
    update: XOR<
      JobQuoteUpdateWithoutJobInput,
      JobQuoteUncheckedUpdateWithoutJobInput
    >;
    create: XOR<
      JobQuoteCreateWithoutJobInput,
      JobQuoteUncheckedCreateWithoutJobInput
    >;
  };

  export type JobQuoteUpdateWithWhereUniqueWithoutJobInput = {
    where: JobQuoteWhereUniqueInput;
    data: XOR<
      JobQuoteUpdateWithoutJobInput,
      JobQuoteUncheckedUpdateWithoutJobInput
    >;
  };

  export type JobQuoteUpdateManyWithWhereWithoutJobInput = {
    where: JobQuoteScalarWhereInput;
    data: XOR<
      JobQuoteUpdateManyMutationInput,
      JobQuoteUncheckedUpdateManyWithoutJobInput
    >;
  };

  export type InvoicesUpsertWithWhereUniqueWithoutJobInput = {
    where: InvoicesWhereUniqueInput;
    update: XOR<
      InvoicesUpdateWithoutJobInput,
      InvoicesUncheckedUpdateWithoutJobInput
    >;
    create: XOR<
      InvoicesCreateWithoutJobInput,
      InvoicesUncheckedCreateWithoutJobInput
    >;
  };

  export type InvoicesUpdateWithWhereUniqueWithoutJobInput = {
    where: InvoicesWhereUniqueInput;
    data: XOR<
      InvoicesUpdateWithoutJobInput,
      InvoicesUncheckedUpdateWithoutJobInput
    >;
  };

  export type InvoicesUpdateManyWithWhereWithoutJobInput = {
    where: InvoicesScalarWhereInput;
    data: XOR<
      InvoicesUpdateManyMutationInput,
      InvoicesUncheckedUpdateManyWithoutJobInput
    >;
  };

  export type UsersUpsertWithoutJobsInput = {
    update: XOR<
      UsersUpdateWithoutJobsInput,
      UsersUncheckedUpdateWithoutJobsInput
    >;
    create: XOR<
      UsersCreateWithoutJobsInput,
      UsersUncheckedCreateWithoutJobsInput
    >;
    where?: UsersWhereInput;
  };

  export type UsersUpdateToOneWithWhereWithoutJobsInput = {
    where?: UsersWhereInput;
    data: XOR<
      UsersUpdateWithoutJobsInput,
      UsersUncheckedUpdateWithoutJobsInput
    >;
  };

  export type UsersUpdateWithoutJobsInput = {
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: StringFieldUpdateOperationsInput | string;
    first_name?: StringFieldUpdateOperationsInput | string;
    last_name?: StringFieldUpdateOperationsInput | string;
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null;
    company_name?: NullableStringFieldUpdateOperationsInput | string | null;
    subscription_id?: NullableStringFieldUpdateOperationsInput | string | null;
    free_trial_expiration_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    settings?: NullableJsonNullValueInput | InputJsonValue;
    default_tax?: TaxesUpdateOneWithoutUsersNestedInput;
    address?: AddressesUpdateOneWithoutUsersNestedInput;
    clients?: ClientsUpdateManyWithoutBelongs_toNestedInput;
    requests?: RequestsUpdateManyWithoutBelongs_toNestedInput;
    quotes?: QuotesUpdateManyWithoutBelongs_toNestedInput;
    invoices?: InvoicesUpdateManyWithoutBelongs_toNestedInput;
  };

  export type UsersUncheckedUpdateWithoutJobsInput = {
    id?: IntFieldUpdateOperationsInput | number;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: StringFieldUpdateOperationsInput | string;
    first_name?: StringFieldUpdateOperationsInput | string;
    last_name?: StringFieldUpdateOperationsInput | string;
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null;
    company_name?: NullableStringFieldUpdateOperationsInput | string | null;
    subscription_id?: NullableStringFieldUpdateOperationsInput | string | null;
    free_trial_expiration_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    default_tax_id?: NullableIntFieldUpdateOperationsInput | number | null;
    address_id?: NullableIntFieldUpdateOperationsInput | number | null;
    settings?: NullableJsonNullValueInput | InputJsonValue;
    clients?: ClientsUncheckedUpdateManyWithoutBelongs_toNestedInput;
    requests?: RequestsUncheckedUpdateManyWithoutBelongs_toNestedInput;
    quotes?: QuotesUncheckedUpdateManyWithoutBelongs_toNestedInput;
    invoices?: InvoicesUncheckedUpdateManyWithoutBelongs_toNestedInput;
  };

  export type JobsCreateWithoutLine_itemsInput = {
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: boolean;
    texted_to_client?: boolean;
    status: string;
    title: string;
    instructions?: string | null;
    number: string;
    schedule_type: string;
    recurring_frequency?: string | null;
    recurring_interval?: string | null;
    day_of_week?: string | null;
    day_of_year?: string | null;
    duration?: string | null;
    start_date?: Date | string | null;
    end_date?: Date | string | null;
    start_time?: Date | string | null;
    end_time?: Date | string | null;
    schedule_later?: boolean;
    team?: string | null;
    email_team?: boolean;
    invoice_reminder?: boolean;
    internal_notes?: string | null;
    internal_attachment_url?: string | null;
    link_to_related_invoices?: boolean;
    client: ClientsCreateNestedOneWithoutJobsInput;
    job_requests?: JobRequestCreateNestedManyWithoutJobInput;
    job_quotes?: JobQuoteCreateNestedManyWithoutJobInput;
    invoices?: InvoicesCreateNestedManyWithoutJobInput;
    belongs_to: UsersCreateNestedOneWithoutJobsInput;
  };

  export type JobsUncheckedCreateWithoutLine_itemsInput = {
    id?: number;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: boolean;
    texted_to_client?: boolean;
    status: string;
    client_id: number;
    title: string;
    instructions?: string | null;
    number: string;
    schedule_type: string;
    recurring_frequency?: string | null;
    recurring_interval?: string | null;
    day_of_week?: string | null;
    day_of_year?: string | null;
    duration?: string | null;
    start_date?: Date | string | null;
    end_date?: Date | string | null;
    start_time?: Date | string | null;
    end_time?: Date | string | null;
    schedule_later?: boolean;
    team?: string | null;
    email_team?: boolean;
    invoice_reminder?: boolean;
    internal_notes?: string | null;
    internal_attachment_url?: string | null;
    link_to_related_invoices?: boolean;
    belongs_to_id: number;
    job_requests?: JobRequestUncheckedCreateNestedManyWithoutJobInput;
    job_quotes?: JobQuoteUncheckedCreateNestedManyWithoutJobInput;
    invoices?: InvoicesUncheckedCreateNestedManyWithoutJobInput;
  };

  export type JobsCreateOrConnectWithoutLine_itemsInput = {
    where: JobsWhereUniqueInput;
    create: XOR<
      JobsCreateWithoutLine_itemsInput,
      JobsUncheckedCreateWithoutLine_itemsInput
    >;
  };

  export type LineItemsCreateWithoutJobsInput = {
    type: string;
    name: string;
    description?: string | null;
    quantity?: number;
    unit_price: number;
    markup?: number | null;
    img_url?: string | null;
    recommend_item?: boolean;
    quotes?: LineItemQuoteCreateNestedManyWithoutLine_itemInput;
    invoices?: LineItemInvoiceCreateNestedManyWithoutLine_itemInput;
  };

  export type LineItemsUncheckedCreateWithoutJobsInput = {
    id?: number;
    type: string;
    name: string;
    description?: string | null;
    quantity?: number;
    unit_price: number;
    markup?: number | null;
    img_url?: string | null;
    recommend_item?: boolean;
    quotes?: LineItemQuoteUncheckedCreateNestedManyWithoutLine_itemInput;
    invoices?: LineItemInvoiceUncheckedCreateNestedManyWithoutLine_itemInput;
  };

  export type LineItemsCreateOrConnectWithoutJobsInput = {
    where: LineItemsWhereUniqueInput;
    create: XOR<
      LineItemsCreateWithoutJobsInput,
      LineItemsUncheckedCreateWithoutJobsInput
    >;
  };

  export type JobsUpsertWithoutLine_itemsInput = {
    update: XOR<
      JobsUpdateWithoutLine_itemsInput,
      JobsUncheckedUpdateWithoutLine_itemsInput
    >;
    create: XOR<
      JobsCreateWithoutLine_itemsInput,
      JobsUncheckedCreateWithoutLine_itemsInput
    >;
    where?: JobsWhereInput;
  };

  export type JobsUpdateToOneWithWhereWithoutLine_itemsInput = {
    where?: JobsWhereInput;
    data: XOR<
      JobsUpdateWithoutLine_itemsInput,
      JobsUncheckedUpdateWithoutLine_itemsInput
    >;
  };

  export type JobsUpdateWithoutLine_itemsInput = {
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: BoolFieldUpdateOperationsInput | boolean;
    texted_to_client?: BoolFieldUpdateOperationsInput | boolean;
    status?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    instructions?: NullableStringFieldUpdateOperationsInput | string | null;
    number?: StringFieldUpdateOperationsInput | string;
    schedule_type?: StringFieldUpdateOperationsInput | string;
    recurring_frequency?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    recurring_interval?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    day_of_week?: NullableStringFieldUpdateOperationsInput | string | null;
    day_of_year?: NullableStringFieldUpdateOperationsInput | string | null;
    duration?: NullableStringFieldUpdateOperationsInput | string | null;
    start_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    end_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    start_time?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    end_time?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    schedule_later?: BoolFieldUpdateOperationsInput | boolean;
    team?: NullableStringFieldUpdateOperationsInput | string | null;
    email_team?: BoolFieldUpdateOperationsInput | boolean;
    invoice_reminder?: BoolFieldUpdateOperationsInput | boolean;
    internal_notes?: NullableStringFieldUpdateOperationsInput | string | null;
    internal_attachment_url?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    link_to_related_invoices?: BoolFieldUpdateOperationsInput | boolean;
    client?: ClientsUpdateOneRequiredWithoutJobsNestedInput;
    job_requests?: JobRequestUpdateManyWithoutJobNestedInput;
    job_quotes?: JobQuoteUpdateManyWithoutJobNestedInput;
    invoices?: InvoicesUpdateManyWithoutJobNestedInput;
    belongs_to?: UsersUpdateOneRequiredWithoutJobsNestedInput;
  };

  export type JobsUncheckedUpdateWithoutLine_itemsInput = {
    id?: IntFieldUpdateOperationsInput | number;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: BoolFieldUpdateOperationsInput | boolean;
    texted_to_client?: BoolFieldUpdateOperationsInput | boolean;
    status?: StringFieldUpdateOperationsInput | string;
    client_id?: IntFieldUpdateOperationsInput | number;
    title?: StringFieldUpdateOperationsInput | string;
    instructions?: NullableStringFieldUpdateOperationsInput | string | null;
    number?: StringFieldUpdateOperationsInput | string;
    schedule_type?: StringFieldUpdateOperationsInput | string;
    recurring_frequency?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    recurring_interval?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    day_of_week?: NullableStringFieldUpdateOperationsInput | string | null;
    day_of_year?: NullableStringFieldUpdateOperationsInput | string | null;
    duration?: NullableStringFieldUpdateOperationsInput | string | null;
    start_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    end_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    start_time?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    end_time?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    schedule_later?: BoolFieldUpdateOperationsInput | boolean;
    team?: NullableStringFieldUpdateOperationsInput | string | null;
    email_team?: BoolFieldUpdateOperationsInput | boolean;
    invoice_reminder?: BoolFieldUpdateOperationsInput | boolean;
    internal_notes?: NullableStringFieldUpdateOperationsInput | string | null;
    internal_attachment_url?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    link_to_related_invoices?: BoolFieldUpdateOperationsInput | boolean;
    belongs_to_id?: IntFieldUpdateOperationsInput | number;
    job_requests?: JobRequestUncheckedUpdateManyWithoutJobNestedInput;
    job_quotes?: JobQuoteUncheckedUpdateManyWithoutJobNestedInput;
    invoices?: InvoicesUncheckedUpdateManyWithoutJobNestedInput;
  };

  export type LineItemsUpsertWithoutJobsInput = {
    update: XOR<
      LineItemsUpdateWithoutJobsInput,
      LineItemsUncheckedUpdateWithoutJobsInput
    >;
    create: XOR<
      LineItemsCreateWithoutJobsInput,
      LineItemsUncheckedCreateWithoutJobsInput
    >;
    where?: LineItemsWhereInput;
  };

  export type LineItemsUpdateToOneWithWhereWithoutJobsInput = {
    where?: LineItemsWhereInput;
    data: XOR<
      LineItemsUpdateWithoutJobsInput,
      LineItemsUncheckedUpdateWithoutJobsInput
    >;
  };

  export type LineItemsUpdateWithoutJobsInput = {
    type?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    quantity?: IntFieldUpdateOperationsInput | number;
    unit_price?: FloatFieldUpdateOperationsInput | number;
    markup?: NullableFloatFieldUpdateOperationsInput | number | null;
    img_url?: NullableStringFieldUpdateOperationsInput | string | null;
    recommend_item?: BoolFieldUpdateOperationsInput | boolean;
    quotes?: LineItemQuoteUpdateManyWithoutLine_itemNestedInput;
    invoices?: LineItemInvoiceUpdateManyWithoutLine_itemNestedInput;
  };

  export type LineItemsUncheckedUpdateWithoutJobsInput = {
    id?: IntFieldUpdateOperationsInput | number;
    type?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    quantity?: IntFieldUpdateOperationsInput | number;
    unit_price?: FloatFieldUpdateOperationsInput | number;
    markup?: NullableFloatFieldUpdateOperationsInput | number | null;
    img_url?: NullableStringFieldUpdateOperationsInput | string | null;
    recommend_item?: BoolFieldUpdateOperationsInput | boolean;
    quotes?: LineItemQuoteUncheckedUpdateManyWithoutLine_itemNestedInput;
    invoices?: LineItemInvoiceUncheckedUpdateManyWithoutLine_itemNestedInput;
  };

  export type JobsCreateWithoutJob_requestsInput = {
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: boolean;
    texted_to_client?: boolean;
    status: string;
    title: string;
    instructions?: string | null;
    number: string;
    schedule_type: string;
    recurring_frequency?: string | null;
    recurring_interval?: string | null;
    day_of_week?: string | null;
    day_of_year?: string | null;
    duration?: string | null;
    start_date?: Date | string | null;
    end_date?: Date | string | null;
    start_time?: Date | string | null;
    end_time?: Date | string | null;
    schedule_later?: boolean;
    team?: string | null;
    email_team?: boolean;
    invoice_reminder?: boolean;
    internal_notes?: string | null;
    internal_attachment_url?: string | null;
    link_to_related_invoices?: boolean;
    client: ClientsCreateNestedOneWithoutJobsInput;
    line_items?: LineItemJobCreateNestedManyWithoutJobInput;
    job_quotes?: JobQuoteCreateNestedManyWithoutJobInput;
    invoices?: InvoicesCreateNestedManyWithoutJobInput;
    belongs_to: UsersCreateNestedOneWithoutJobsInput;
  };

  export type JobsUncheckedCreateWithoutJob_requestsInput = {
    id?: number;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: boolean;
    texted_to_client?: boolean;
    status: string;
    client_id: number;
    title: string;
    instructions?: string | null;
    number: string;
    schedule_type: string;
    recurring_frequency?: string | null;
    recurring_interval?: string | null;
    day_of_week?: string | null;
    day_of_year?: string | null;
    duration?: string | null;
    start_date?: Date | string | null;
    end_date?: Date | string | null;
    start_time?: Date | string | null;
    end_time?: Date | string | null;
    schedule_later?: boolean;
    team?: string | null;
    email_team?: boolean;
    invoice_reminder?: boolean;
    internal_notes?: string | null;
    internal_attachment_url?: string | null;
    link_to_related_invoices?: boolean;
    belongs_to_id: number;
    line_items?: LineItemJobUncheckedCreateNestedManyWithoutJobInput;
    job_quotes?: JobQuoteUncheckedCreateNestedManyWithoutJobInput;
    invoices?: InvoicesUncheckedCreateNestedManyWithoutJobInput;
  };

  export type JobsCreateOrConnectWithoutJob_requestsInput = {
    where: JobsWhereUniqueInput;
    create: XOR<
      JobsCreateWithoutJob_requestsInput,
      JobsUncheckedCreateWithoutJob_requestsInput
    >;
  };

  export type RequestsCreateWithoutJob_requestsInput = {
    status: string;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: boolean;
    texted_to_client?: boolean;
    title: string;
    service_details: string;
    assessment_date: Date | string;
    backup_assessment__date?: Date | string | null;
    preferred_arrival_times?: string | null;
    on_site_assesment_required?: boolean;
    internal_notes: string;
    internalAttachmentUrl: string;
    link_to_releated_quotes?: boolean;
    link_to_releated_jobs?: boolean;
    link_to_releated_invoices?: boolean;
    assessment: AssessmentsCreateNestedOneWithoutRequestsInput;
    client: ClientsCreateNestedOneWithoutRequestsInput;
    quotes?: QuoteRequestCreateNestedManyWithoutRequestInput;
    belongs_to: UsersCreateNestedOneWithoutRequestsInput;
  };

  export type RequestsUncheckedCreateWithoutJob_requestsInput = {
    id?: number;
    status: string;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: boolean;
    texted_to_client?: boolean;
    title: string;
    service_details: string;
    assessment_date: Date | string;
    backup_assessment__date?: Date | string | null;
    preferred_arrival_times?: string | null;
    on_site_assesment_required?: boolean;
    client_id: number;
    assessment_id: number;
    internal_notes: string;
    internalAttachmentUrl: string;
    link_to_releated_quotes?: boolean;
    link_to_releated_jobs?: boolean;
    link_to_releated_invoices?: boolean;
    belongs_to_id: number;
    quotes?: QuoteRequestUncheckedCreateNestedManyWithoutRequestInput;
  };

  export type RequestsCreateOrConnectWithoutJob_requestsInput = {
    where: RequestsWhereUniqueInput;
    create: XOR<
      RequestsCreateWithoutJob_requestsInput,
      RequestsUncheckedCreateWithoutJob_requestsInput
    >;
  };

  export type JobsUpsertWithoutJob_requestsInput = {
    update: XOR<
      JobsUpdateWithoutJob_requestsInput,
      JobsUncheckedUpdateWithoutJob_requestsInput
    >;
    create: XOR<
      JobsCreateWithoutJob_requestsInput,
      JobsUncheckedCreateWithoutJob_requestsInput
    >;
    where?: JobsWhereInput;
  };

  export type JobsUpdateToOneWithWhereWithoutJob_requestsInput = {
    where?: JobsWhereInput;
    data: XOR<
      JobsUpdateWithoutJob_requestsInput,
      JobsUncheckedUpdateWithoutJob_requestsInput
    >;
  };

  export type JobsUpdateWithoutJob_requestsInput = {
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: BoolFieldUpdateOperationsInput | boolean;
    texted_to_client?: BoolFieldUpdateOperationsInput | boolean;
    status?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    instructions?: NullableStringFieldUpdateOperationsInput | string | null;
    number?: StringFieldUpdateOperationsInput | string;
    schedule_type?: StringFieldUpdateOperationsInput | string;
    recurring_frequency?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    recurring_interval?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    day_of_week?: NullableStringFieldUpdateOperationsInput | string | null;
    day_of_year?: NullableStringFieldUpdateOperationsInput | string | null;
    duration?: NullableStringFieldUpdateOperationsInput | string | null;
    start_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    end_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    start_time?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    end_time?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    schedule_later?: BoolFieldUpdateOperationsInput | boolean;
    team?: NullableStringFieldUpdateOperationsInput | string | null;
    email_team?: BoolFieldUpdateOperationsInput | boolean;
    invoice_reminder?: BoolFieldUpdateOperationsInput | boolean;
    internal_notes?: NullableStringFieldUpdateOperationsInput | string | null;
    internal_attachment_url?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    link_to_related_invoices?: BoolFieldUpdateOperationsInput | boolean;
    client?: ClientsUpdateOneRequiredWithoutJobsNestedInput;
    line_items?: LineItemJobUpdateManyWithoutJobNestedInput;
    job_quotes?: JobQuoteUpdateManyWithoutJobNestedInput;
    invoices?: InvoicesUpdateManyWithoutJobNestedInput;
    belongs_to?: UsersUpdateOneRequiredWithoutJobsNestedInput;
  };

  export type JobsUncheckedUpdateWithoutJob_requestsInput = {
    id?: IntFieldUpdateOperationsInput | number;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: BoolFieldUpdateOperationsInput | boolean;
    texted_to_client?: BoolFieldUpdateOperationsInput | boolean;
    status?: StringFieldUpdateOperationsInput | string;
    client_id?: IntFieldUpdateOperationsInput | number;
    title?: StringFieldUpdateOperationsInput | string;
    instructions?: NullableStringFieldUpdateOperationsInput | string | null;
    number?: StringFieldUpdateOperationsInput | string;
    schedule_type?: StringFieldUpdateOperationsInput | string;
    recurring_frequency?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    recurring_interval?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    day_of_week?: NullableStringFieldUpdateOperationsInput | string | null;
    day_of_year?: NullableStringFieldUpdateOperationsInput | string | null;
    duration?: NullableStringFieldUpdateOperationsInput | string | null;
    start_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    end_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    start_time?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    end_time?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    schedule_later?: BoolFieldUpdateOperationsInput | boolean;
    team?: NullableStringFieldUpdateOperationsInput | string | null;
    email_team?: BoolFieldUpdateOperationsInput | boolean;
    invoice_reminder?: BoolFieldUpdateOperationsInput | boolean;
    internal_notes?: NullableStringFieldUpdateOperationsInput | string | null;
    internal_attachment_url?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    link_to_related_invoices?: BoolFieldUpdateOperationsInput | boolean;
    belongs_to_id?: IntFieldUpdateOperationsInput | number;
    line_items?: LineItemJobUncheckedUpdateManyWithoutJobNestedInput;
    job_quotes?: JobQuoteUncheckedUpdateManyWithoutJobNestedInput;
    invoices?: InvoicesUncheckedUpdateManyWithoutJobNestedInput;
  };

  export type RequestsUpsertWithoutJob_requestsInput = {
    update: XOR<
      RequestsUpdateWithoutJob_requestsInput,
      RequestsUncheckedUpdateWithoutJob_requestsInput
    >;
    create: XOR<
      RequestsCreateWithoutJob_requestsInput,
      RequestsUncheckedCreateWithoutJob_requestsInput
    >;
    where?: RequestsWhereInput;
  };

  export type RequestsUpdateToOneWithWhereWithoutJob_requestsInput = {
    where?: RequestsWhereInput;
    data: XOR<
      RequestsUpdateWithoutJob_requestsInput,
      RequestsUncheckedUpdateWithoutJob_requestsInput
    >;
  };

  export type RequestsUpdateWithoutJob_requestsInput = {
    status?: StringFieldUpdateOperationsInput | string;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: BoolFieldUpdateOperationsInput | boolean;
    texted_to_client?: BoolFieldUpdateOperationsInput | boolean;
    title?: StringFieldUpdateOperationsInput | string;
    service_details?: StringFieldUpdateOperationsInput | string;
    assessment_date?: DateTimeFieldUpdateOperationsInput | Date | string;
    backup_assessment__date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    preferred_arrival_times?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    on_site_assesment_required?: BoolFieldUpdateOperationsInput | boolean;
    internal_notes?: StringFieldUpdateOperationsInput | string;
    internalAttachmentUrl?: StringFieldUpdateOperationsInput | string;
    link_to_releated_quotes?: BoolFieldUpdateOperationsInput | boolean;
    link_to_releated_jobs?: BoolFieldUpdateOperationsInput | boolean;
    link_to_releated_invoices?: BoolFieldUpdateOperationsInput | boolean;
    assessment?: AssessmentsUpdateOneRequiredWithoutRequestsNestedInput;
    client?: ClientsUpdateOneRequiredWithoutRequestsNestedInput;
    quotes?: QuoteRequestUpdateManyWithoutRequestNestedInput;
    belongs_to?: UsersUpdateOneRequiredWithoutRequestsNestedInput;
  };

  export type RequestsUncheckedUpdateWithoutJob_requestsInput = {
    id?: IntFieldUpdateOperationsInput | number;
    status?: StringFieldUpdateOperationsInput | string;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: BoolFieldUpdateOperationsInput | boolean;
    texted_to_client?: BoolFieldUpdateOperationsInput | boolean;
    title?: StringFieldUpdateOperationsInput | string;
    service_details?: StringFieldUpdateOperationsInput | string;
    assessment_date?: DateTimeFieldUpdateOperationsInput | Date | string;
    backup_assessment__date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    preferred_arrival_times?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    on_site_assesment_required?: BoolFieldUpdateOperationsInput | boolean;
    client_id?: IntFieldUpdateOperationsInput | number;
    assessment_id?: IntFieldUpdateOperationsInput | number;
    internal_notes?: StringFieldUpdateOperationsInput | string;
    internalAttachmentUrl?: StringFieldUpdateOperationsInput | string;
    link_to_releated_quotes?: BoolFieldUpdateOperationsInput | boolean;
    link_to_releated_jobs?: BoolFieldUpdateOperationsInput | boolean;
    link_to_releated_invoices?: BoolFieldUpdateOperationsInput | boolean;
    belongs_to_id?: IntFieldUpdateOperationsInput | number;
    quotes?: QuoteRequestUncheckedUpdateManyWithoutRequestNestedInput;
  };

  export type JobsCreateWithoutJob_quotesInput = {
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: boolean;
    texted_to_client?: boolean;
    status: string;
    title: string;
    instructions?: string | null;
    number: string;
    schedule_type: string;
    recurring_frequency?: string | null;
    recurring_interval?: string | null;
    day_of_week?: string | null;
    day_of_year?: string | null;
    duration?: string | null;
    start_date?: Date | string | null;
    end_date?: Date | string | null;
    start_time?: Date | string | null;
    end_time?: Date | string | null;
    schedule_later?: boolean;
    team?: string | null;
    email_team?: boolean;
    invoice_reminder?: boolean;
    internal_notes?: string | null;
    internal_attachment_url?: string | null;
    link_to_related_invoices?: boolean;
    client: ClientsCreateNestedOneWithoutJobsInput;
    line_items?: LineItemJobCreateNestedManyWithoutJobInput;
    job_requests?: JobRequestCreateNestedManyWithoutJobInput;
    invoices?: InvoicesCreateNestedManyWithoutJobInput;
    belongs_to: UsersCreateNestedOneWithoutJobsInput;
  };

  export type JobsUncheckedCreateWithoutJob_quotesInput = {
    id?: number;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: boolean;
    texted_to_client?: boolean;
    status: string;
    client_id: number;
    title: string;
    instructions?: string | null;
    number: string;
    schedule_type: string;
    recurring_frequency?: string | null;
    recurring_interval?: string | null;
    day_of_week?: string | null;
    day_of_year?: string | null;
    duration?: string | null;
    start_date?: Date | string | null;
    end_date?: Date | string | null;
    start_time?: Date | string | null;
    end_time?: Date | string | null;
    schedule_later?: boolean;
    team?: string | null;
    email_team?: boolean;
    invoice_reminder?: boolean;
    internal_notes?: string | null;
    internal_attachment_url?: string | null;
    link_to_related_invoices?: boolean;
    belongs_to_id: number;
    line_items?: LineItemJobUncheckedCreateNestedManyWithoutJobInput;
    job_requests?: JobRequestUncheckedCreateNestedManyWithoutJobInput;
    invoices?: InvoicesUncheckedCreateNestedManyWithoutJobInput;
  };

  export type JobsCreateOrConnectWithoutJob_quotesInput = {
    where: JobsWhereUniqueInput;
    create: XOR<
      JobsCreateWithoutJob_quotesInput,
      JobsUncheckedCreateWithoutJob_quotesInput
    >;
  };

  export type QuotesCreateWithoutJob_quotesInput = {
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: boolean;
    texted_to_client?: boolean;
    status: string;
    title: string;
    quote_number: string;
    opportunity_rating?: string | null;
    client_message?: string | null;
    discount?: number | null;
    discount_unit?: string | null;
    required_deposit?: number | null;
    link_to_releated_jobs?: boolean;
    link_to_releated_invoices?: boolean;
    client: ClientsCreateNestedOneWithoutQuotesInput;
    line_items?: LineItemQuoteCreateNestedManyWithoutQuoteInput;
    tax?: TaxesCreateNestedOneWithoutQuotesInput;
    requests?: QuoteRequestCreateNestedManyWithoutQuoteInput;
    belongs_to: UsersCreateNestedOneWithoutQuotesInput;
  };

  export type QuotesUncheckedCreateWithoutJob_quotesInput = {
    id?: number;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: boolean;
    texted_to_client?: boolean;
    status: string;
    title: string;
    quote_number: string;
    opportunity_rating?: string | null;
    client_id: number;
    client_message?: string | null;
    discount?: number | null;
    discount_unit?: string | null;
    tax_id: number;
    required_deposit?: number | null;
    link_to_releated_jobs?: boolean;
    link_to_releated_invoices?: boolean;
    belongs_to_id: number;
    line_items?: LineItemQuoteUncheckedCreateNestedManyWithoutQuoteInput;
    requests?: QuoteRequestUncheckedCreateNestedManyWithoutQuoteInput;
  };

  export type QuotesCreateOrConnectWithoutJob_quotesInput = {
    where: QuotesWhereUniqueInput;
    create: XOR<
      QuotesCreateWithoutJob_quotesInput,
      QuotesUncheckedCreateWithoutJob_quotesInput
    >;
  };

  export type JobsUpsertWithoutJob_quotesInput = {
    update: XOR<
      JobsUpdateWithoutJob_quotesInput,
      JobsUncheckedUpdateWithoutJob_quotesInput
    >;
    create: XOR<
      JobsCreateWithoutJob_quotesInput,
      JobsUncheckedCreateWithoutJob_quotesInput
    >;
    where?: JobsWhereInput;
  };

  export type JobsUpdateToOneWithWhereWithoutJob_quotesInput = {
    where?: JobsWhereInput;
    data: XOR<
      JobsUpdateWithoutJob_quotesInput,
      JobsUncheckedUpdateWithoutJob_quotesInput
    >;
  };

  export type JobsUpdateWithoutJob_quotesInput = {
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: BoolFieldUpdateOperationsInput | boolean;
    texted_to_client?: BoolFieldUpdateOperationsInput | boolean;
    status?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    instructions?: NullableStringFieldUpdateOperationsInput | string | null;
    number?: StringFieldUpdateOperationsInput | string;
    schedule_type?: StringFieldUpdateOperationsInput | string;
    recurring_frequency?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    recurring_interval?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    day_of_week?: NullableStringFieldUpdateOperationsInput | string | null;
    day_of_year?: NullableStringFieldUpdateOperationsInput | string | null;
    duration?: NullableStringFieldUpdateOperationsInput | string | null;
    start_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    end_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    start_time?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    end_time?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    schedule_later?: BoolFieldUpdateOperationsInput | boolean;
    team?: NullableStringFieldUpdateOperationsInput | string | null;
    email_team?: BoolFieldUpdateOperationsInput | boolean;
    invoice_reminder?: BoolFieldUpdateOperationsInput | boolean;
    internal_notes?: NullableStringFieldUpdateOperationsInput | string | null;
    internal_attachment_url?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    link_to_related_invoices?: BoolFieldUpdateOperationsInput | boolean;
    client?: ClientsUpdateOneRequiredWithoutJobsNestedInput;
    line_items?: LineItemJobUpdateManyWithoutJobNestedInput;
    job_requests?: JobRequestUpdateManyWithoutJobNestedInput;
    invoices?: InvoicesUpdateManyWithoutJobNestedInput;
    belongs_to?: UsersUpdateOneRequiredWithoutJobsNestedInput;
  };

  export type JobsUncheckedUpdateWithoutJob_quotesInput = {
    id?: IntFieldUpdateOperationsInput | number;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: BoolFieldUpdateOperationsInput | boolean;
    texted_to_client?: BoolFieldUpdateOperationsInput | boolean;
    status?: StringFieldUpdateOperationsInput | string;
    client_id?: IntFieldUpdateOperationsInput | number;
    title?: StringFieldUpdateOperationsInput | string;
    instructions?: NullableStringFieldUpdateOperationsInput | string | null;
    number?: StringFieldUpdateOperationsInput | string;
    schedule_type?: StringFieldUpdateOperationsInput | string;
    recurring_frequency?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    recurring_interval?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    day_of_week?: NullableStringFieldUpdateOperationsInput | string | null;
    day_of_year?: NullableStringFieldUpdateOperationsInput | string | null;
    duration?: NullableStringFieldUpdateOperationsInput | string | null;
    start_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    end_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    start_time?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    end_time?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    schedule_later?: BoolFieldUpdateOperationsInput | boolean;
    team?: NullableStringFieldUpdateOperationsInput | string | null;
    email_team?: BoolFieldUpdateOperationsInput | boolean;
    invoice_reminder?: BoolFieldUpdateOperationsInput | boolean;
    internal_notes?: NullableStringFieldUpdateOperationsInput | string | null;
    internal_attachment_url?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    link_to_related_invoices?: BoolFieldUpdateOperationsInput | boolean;
    belongs_to_id?: IntFieldUpdateOperationsInput | number;
    line_items?: LineItemJobUncheckedUpdateManyWithoutJobNestedInput;
    job_requests?: JobRequestUncheckedUpdateManyWithoutJobNestedInput;
    invoices?: InvoicesUncheckedUpdateManyWithoutJobNestedInput;
  };

  export type QuotesUpsertWithoutJob_quotesInput = {
    update: XOR<
      QuotesUpdateWithoutJob_quotesInput,
      QuotesUncheckedUpdateWithoutJob_quotesInput
    >;
    create: XOR<
      QuotesCreateWithoutJob_quotesInput,
      QuotesUncheckedCreateWithoutJob_quotesInput
    >;
    where?: QuotesWhereInput;
  };

  export type QuotesUpdateToOneWithWhereWithoutJob_quotesInput = {
    where?: QuotesWhereInput;
    data: XOR<
      QuotesUpdateWithoutJob_quotesInput,
      QuotesUncheckedUpdateWithoutJob_quotesInput
    >;
  };

  export type QuotesUpdateWithoutJob_quotesInput = {
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: BoolFieldUpdateOperationsInput | boolean;
    texted_to_client?: BoolFieldUpdateOperationsInput | boolean;
    status?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    quote_number?: StringFieldUpdateOperationsInput | string;
    opportunity_rating?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    client_message?: NullableStringFieldUpdateOperationsInput | string | null;
    discount?: NullableFloatFieldUpdateOperationsInput | number | null;
    discount_unit?: NullableStringFieldUpdateOperationsInput | string | null;
    required_deposit?: NullableFloatFieldUpdateOperationsInput | number | null;
    link_to_releated_jobs?: BoolFieldUpdateOperationsInput | boolean;
    link_to_releated_invoices?: BoolFieldUpdateOperationsInput | boolean;
    client?: ClientsUpdateOneRequiredWithoutQuotesNestedInput;
    line_items?: LineItemQuoteUpdateManyWithoutQuoteNestedInput;
    tax?: TaxesUpdateOneWithoutQuotesNestedInput;
    requests?: QuoteRequestUpdateManyWithoutQuoteNestedInput;
    belongs_to?: UsersUpdateOneRequiredWithoutQuotesNestedInput;
  };

  export type QuotesUncheckedUpdateWithoutJob_quotesInput = {
    id?: IntFieldUpdateOperationsInput | number;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: BoolFieldUpdateOperationsInput | boolean;
    texted_to_client?: BoolFieldUpdateOperationsInput | boolean;
    status?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    quote_number?: StringFieldUpdateOperationsInput | string;
    opportunity_rating?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    client_id?: IntFieldUpdateOperationsInput | number;
    client_message?: NullableStringFieldUpdateOperationsInput | string | null;
    discount?: NullableFloatFieldUpdateOperationsInput | number | null;
    discount_unit?: NullableStringFieldUpdateOperationsInput | string | null;
    tax_id?: IntFieldUpdateOperationsInput | number;
    required_deposit?: NullableFloatFieldUpdateOperationsInput | number | null;
    link_to_releated_jobs?: BoolFieldUpdateOperationsInput | boolean;
    link_to_releated_invoices?: BoolFieldUpdateOperationsInput | boolean;
    belongs_to_id?: IntFieldUpdateOperationsInput | number;
    line_items?: LineItemQuoteUncheckedUpdateManyWithoutQuoteNestedInput;
    requests?: QuoteRequestUncheckedUpdateManyWithoutQuoteNestedInput;
  };

  export type ClientsCreateWithoutInvoicesInput = {
    title: string;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    first_name: string;
    last_name: string;
    company_name?: string | null;
    use_company_name_as_primary?: boolean;
    mobile_phone_number?: string | null;
    work_phone_number?: string | null;
    email?: string | null;
    quote_follow_up?: boolean;
    job_follow_up?: boolean;
    invoice_follow_up?: boolean;
    upcoming_visit_reminder?: boolean;
    referred_by?: string | null;
    billing_address_same_as_property?: boolean;
    created_date?: Date | string;
    status?: string | null;
    property_address?: AddressesCreateNestedOneWithoutProperty_clientsInput;
    billing_address?: AddressesCreateNestedOneWithoutBilling_clientsInput;
    requests?: RequestsCreateNestedManyWithoutClientInput;
    quotes?: QuotesCreateNestedManyWithoutClientInput;
    jobs?: JobsCreateNestedManyWithoutClientInput;
    belongs_to: UsersCreateNestedOneWithoutClientsInput;
  };

  export type ClientsUncheckedCreateWithoutInvoicesInput = {
    id?: number;
    title: string;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    first_name: string;
    last_name: string;
    company_name?: string | null;
    use_company_name_as_primary?: boolean;
    mobile_phone_number?: string | null;
    work_phone_number?: string | null;
    email?: string | null;
    quote_follow_up?: boolean;
    job_follow_up?: boolean;
    invoice_follow_up?: boolean;
    upcoming_visit_reminder?: boolean;
    referred_by?: string | null;
    billing_address_same_as_property?: boolean;
    property_address_id?: number | null;
    billing_address_id?: number | null;
    created_date?: Date | string;
    status?: string | null;
    belongs_to_id: number;
    requests?: RequestsUncheckedCreateNestedManyWithoutClientInput;
    quotes?: QuotesUncheckedCreateNestedManyWithoutClientInput;
    jobs?: JobsUncheckedCreateNestedManyWithoutClientInput;
  };

  export type ClientsCreateOrConnectWithoutInvoicesInput = {
    where: ClientsWhereUniqueInput;
    create: XOR<
      ClientsCreateWithoutInvoicesInput,
      ClientsUncheckedCreateWithoutInvoicesInput
    >;
  };

  export type JobsCreateWithoutInvoicesInput = {
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: boolean;
    texted_to_client?: boolean;
    status: string;
    title: string;
    instructions?: string | null;
    number: string;
    schedule_type: string;
    recurring_frequency?: string | null;
    recurring_interval?: string | null;
    day_of_week?: string | null;
    day_of_year?: string | null;
    duration?: string | null;
    start_date?: Date | string | null;
    end_date?: Date | string | null;
    start_time?: Date | string | null;
    end_time?: Date | string | null;
    schedule_later?: boolean;
    team?: string | null;
    email_team?: boolean;
    invoice_reminder?: boolean;
    internal_notes?: string | null;
    internal_attachment_url?: string | null;
    link_to_related_invoices?: boolean;
    client: ClientsCreateNestedOneWithoutJobsInput;
    line_items?: LineItemJobCreateNestedManyWithoutJobInput;
    job_requests?: JobRequestCreateNestedManyWithoutJobInput;
    job_quotes?: JobQuoteCreateNestedManyWithoutJobInput;
    belongs_to: UsersCreateNestedOneWithoutJobsInput;
  };

  export type JobsUncheckedCreateWithoutInvoicesInput = {
    id?: number;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: boolean;
    texted_to_client?: boolean;
    status: string;
    client_id: number;
    title: string;
    instructions?: string | null;
    number: string;
    schedule_type: string;
    recurring_frequency?: string | null;
    recurring_interval?: string | null;
    day_of_week?: string | null;
    day_of_year?: string | null;
    duration?: string | null;
    start_date?: Date | string | null;
    end_date?: Date | string | null;
    start_time?: Date | string | null;
    end_time?: Date | string | null;
    schedule_later?: boolean;
    team?: string | null;
    email_team?: boolean;
    invoice_reminder?: boolean;
    internal_notes?: string | null;
    internal_attachment_url?: string | null;
    link_to_related_invoices?: boolean;
    belongs_to_id: number;
    line_items?: LineItemJobUncheckedCreateNestedManyWithoutJobInput;
    job_requests?: JobRequestUncheckedCreateNestedManyWithoutJobInput;
    job_quotes?: JobQuoteUncheckedCreateNestedManyWithoutJobInput;
  };

  export type JobsCreateOrConnectWithoutInvoicesInput = {
    where: JobsWhereUniqueInput;
    create: XOR<
      JobsCreateWithoutInvoicesInput,
      JobsUncheckedCreateWithoutInvoicesInput
    >;
  };

  export type TaxesCreateWithoutInvoicesInput = {
    name: string;
    rate: number;
    description?: string | null;
    users?: UsersCreateNestedManyWithoutDefault_taxInput;
    quotes?: QuotesCreateNestedManyWithoutTaxInput;
  };

  export type TaxesUncheckedCreateWithoutInvoicesInput = {
    id?: number;
    name: string;
    rate: number;
    description?: string | null;
    users?: UsersUncheckedCreateNestedManyWithoutDefault_taxInput;
    quotes?: QuotesUncheckedCreateNestedManyWithoutTaxInput;
  };

  export type TaxesCreateOrConnectWithoutInvoicesInput = {
    where: TaxesWhereUniqueInput;
    create: XOR<
      TaxesCreateWithoutInvoicesInput,
      TaxesUncheckedCreateWithoutInvoicesInput
    >;
  };

  export type LineItemInvoiceCreateWithoutInvoiceInput = {
    line_item: LineItemsCreateNestedOneWithoutInvoicesInput;
  };

  export type LineItemInvoiceUncheckedCreateWithoutInvoiceInput = {
    id?: number;
    line_item_id: number;
  };

  export type LineItemInvoiceCreateOrConnectWithoutInvoiceInput = {
    where: LineItemInvoiceWhereUniqueInput;
    create: XOR<
      LineItemInvoiceCreateWithoutInvoiceInput,
      LineItemInvoiceUncheckedCreateWithoutInvoiceInput
    >;
  };

  export type LineItemInvoiceCreateManyInvoiceInputEnvelope = {
    data:
      | LineItemInvoiceCreateManyInvoiceInput
      | LineItemInvoiceCreateManyInvoiceInput[];
    skipDuplicates?: boolean;
  };

  export type UsersCreateWithoutInvoicesInput = {
    email?: string | null;
    password: string;
    first_name: string;
    last_name: string;
    phone_number?: string | null;
    company_name?: string | null;
    subscription_id?: string | null;
    free_trial_expiration_date?: Date | string | null;
    settings?: NullableJsonNullValueInput | InputJsonValue;
    default_tax?: TaxesCreateNestedOneWithoutUsersInput;
    address?: AddressesCreateNestedOneWithoutUsersInput;
    clients?: ClientsCreateNestedManyWithoutBelongs_toInput;
    requests?: RequestsCreateNestedManyWithoutBelongs_toInput;
    jobs?: JobsCreateNestedManyWithoutBelongs_toInput;
    quotes?: QuotesCreateNestedManyWithoutBelongs_toInput;
  };

  export type UsersUncheckedCreateWithoutInvoicesInput = {
    id?: number;
    email?: string | null;
    password: string;
    first_name: string;
    last_name: string;
    phone_number?: string | null;
    company_name?: string | null;
    subscription_id?: string | null;
    free_trial_expiration_date?: Date | string | null;
    default_tax_id?: number | null;
    address_id?: number | null;
    settings?: NullableJsonNullValueInput | InputJsonValue;
    clients?: ClientsUncheckedCreateNestedManyWithoutBelongs_toInput;
    requests?: RequestsUncheckedCreateNestedManyWithoutBelongs_toInput;
    jobs?: JobsUncheckedCreateNestedManyWithoutBelongs_toInput;
    quotes?: QuotesUncheckedCreateNestedManyWithoutBelongs_toInput;
  };

  export type UsersCreateOrConnectWithoutInvoicesInput = {
    where: UsersWhereUniqueInput;
    create: XOR<
      UsersCreateWithoutInvoicesInput,
      UsersUncheckedCreateWithoutInvoicesInput
    >;
  };

  export type ClientsUpsertWithoutInvoicesInput = {
    update: XOR<
      ClientsUpdateWithoutInvoicesInput,
      ClientsUncheckedUpdateWithoutInvoicesInput
    >;
    create: XOR<
      ClientsCreateWithoutInvoicesInput,
      ClientsUncheckedCreateWithoutInvoicesInput
    >;
    where?: ClientsWhereInput;
  };

  export type ClientsUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: ClientsWhereInput;
    data: XOR<
      ClientsUpdateWithoutInvoicesInput,
      ClientsUncheckedUpdateWithoutInvoicesInput
    >;
  };

  export type ClientsUpdateWithoutInvoicesInput = {
    title?: StringFieldUpdateOperationsInput | string;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    first_name?: StringFieldUpdateOperationsInput | string;
    last_name?: StringFieldUpdateOperationsInput | string;
    company_name?: NullableStringFieldUpdateOperationsInput | string | null;
    use_company_name_as_primary?: BoolFieldUpdateOperationsInput | boolean;
    mobile_phone_number?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    work_phone_number?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    quote_follow_up?: BoolFieldUpdateOperationsInput | boolean;
    job_follow_up?: BoolFieldUpdateOperationsInput | boolean;
    invoice_follow_up?: BoolFieldUpdateOperationsInput | boolean;
    upcoming_visit_reminder?: BoolFieldUpdateOperationsInput | boolean;
    referred_by?: NullableStringFieldUpdateOperationsInput | string | null;
    billing_address_same_as_property?: BoolFieldUpdateOperationsInput | boolean;
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string;
    status?: NullableStringFieldUpdateOperationsInput | string | null;
    property_address?: AddressesUpdateOneWithoutProperty_clientsNestedInput;
    billing_address?: AddressesUpdateOneWithoutBilling_clientsNestedInput;
    requests?: RequestsUpdateManyWithoutClientNestedInput;
    quotes?: QuotesUpdateManyWithoutClientNestedInput;
    jobs?: JobsUpdateManyWithoutClientNestedInput;
    belongs_to?: UsersUpdateOneRequiredWithoutClientsNestedInput;
  };

  export type ClientsUncheckedUpdateWithoutInvoicesInput = {
    id?: IntFieldUpdateOperationsInput | number;
    title?: StringFieldUpdateOperationsInput | string;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    first_name?: StringFieldUpdateOperationsInput | string;
    last_name?: StringFieldUpdateOperationsInput | string;
    company_name?: NullableStringFieldUpdateOperationsInput | string | null;
    use_company_name_as_primary?: BoolFieldUpdateOperationsInput | boolean;
    mobile_phone_number?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    work_phone_number?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    quote_follow_up?: BoolFieldUpdateOperationsInput | boolean;
    job_follow_up?: BoolFieldUpdateOperationsInput | boolean;
    invoice_follow_up?: BoolFieldUpdateOperationsInput | boolean;
    upcoming_visit_reminder?: BoolFieldUpdateOperationsInput | boolean;
    referred_by?: NullableStringFieldUpdateOperationsInput | string | null;
    billing_address_same_as_property?: BoolFieldUpdateOperationsInput | boolean;
    property_address_id?: NullableIntFieldUpdateOperationsInput | number | null;
    billing_address_id?: NullableIntFieldUpdateOperationsInput | number | null;
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string;
    status?: NullableStringFieldUpdateOperationsInput | string | null;
    belongs_to_id?: IntFieldUpdateOperationsInput | number;
    requests?: RequestsUncheckedUpdateManyWithoutClientNestedInput;
    quotes?: QuotesUncheckedUpdateManyWithoutClientNestedInput;
    jobs?: JobsUncheckedUpdateManyWithoutClientNestedInput;
  };

  export type JobsUpsertWithoutInvoicesInput = {
    update: XOR<
      JobsUpdateWithoutInvoicesInput,
      JobsUncheckedUpdateWithoutInvoicesInput
    >;
    create: XOR<
      JobsCreateWithoutInvoicesInput,
      JobsUncheckedCreateWithoutInvoicesInput
    >;
    where?: JobsWhereInput;
  };

  export type JobsUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: JobsWhereInput;
    data: XOR<
      JobsUpdateWithoutInvoicesInput,
      JobsUncheckedUpdateWithoutInvoicesInput
    >;
  };

  export type JobsUpdateWithoutInvoicesInput = {
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: BoolFieldUpdateOperationsInput | boolean;
    texted_to_client?: BoolFieldUpdateOperationsInput | boolean;
    status?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    instructions?: NullableStringFieldUpdateOperationsInput | string | null;
    number?: StringFieldUpdateOperationsInput | string;
    schedule_type?: StringFieldUpdateOperationsInput | string;
    recurring_frequency?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    recurring_interval?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    day_of_week?: NullableStringFieldUpdateOperationsInput | string | null;
    day_of_year?: NullableStringFieldUpdateOperationsInput | string | null;
    duration?: NullableStringFieldUpdateOperationsInput | string | null;
    start_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    end_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    start_time?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    end_time?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    schedule_later?: BoolFieldUpdateOperationsInput | boolean;
    team?: NullableStringFieldUpdateOperationsInput | string | null;
    email_team?: BoolFieldUpdateOperationsInput | boolean;
    invoice_reminder?: BoolFieldUpdateOperationsInput | boolean;
    internal_notes?: NullableStringFieldUpdateOperationsInput | string | null;
    internal_attachment_url?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    link_to_related_invoices?: BoolFieldUpdateOperationsInput | boolean;
    client?: ClientsUpdateOneRequiredWithoutJobsNestedInput;
    line_items?: LineItemJobUpdateManyWithoutJobNestedInput;
    job_requests?: JobRequestUpdateManyWithoutJobNestedInput;
    job_quotes?: JobQuoteUpdateManyWithoutJobNestedInput;
    belongs_to?: UsersUpdateOneRequiredWithoutJobsNestedInput;
  };

  export type JobsUncheckedUpdateWithoutInvoicesInput = {
    id?: IntFieldUpdateOperationsInput | number;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: BoolFieldUpdateOperationsInput | boolean;
    texted_to_client?: BoolFieldUpdateOperationsInput | boolean;
    status?: StringFieldUpdateOperationsInput | string;
    client_id?: IntFieldUpdateOperationsInput | number;
    title?: StringFieldUpdateOperationsInput | string;
    instructions?: NullableStringFieldUpdateOperationsInput | string | null;
    number?: StringFieldUpdateOperationsInput | string;
    schedule_type?: StringFieldUpdateOperationsInput | string;
    recurring_frequency?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    recurring_interval?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    day_of_week?: NullableStringFieldUpdateOperationsInput | string | null;
    day_of_year?: NullableStringFieldUpdateOperationsInput | string | null;
    duration?: NullableStringFieldUpdateOperationsInput | string | null;
    start_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    end_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    start_time?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    end_time?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    schedule_later?: BoolFieldUpdateOperationsInput | boolean;
    team?: NullableStringFieldUpdateOperationsInput | string | null;
    email_team?: BoolFieldUpdateOperationsInput | boolean;
    invoice_reminder?: BoolFieldUpdateOperationsInput | boolean;
    internal_notes?: NullableStringFieldUpdateOperationsInput | string | null;
    internal_attachment_url?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    link_to_related_invoices?: BoolFieldUpdateOperationsInput | boolean;
    belongs_to_id?: IntFieldUpdateOperationsInput | number;
    line_items?: LineItemJobUncheckedUpdateManyWithoutJobNestedInput;
    job_requests?: JobRequestUncheckedUpdateManyWithoutJobNestedInput;
    job_quotes?: JobQuoteUncheckedUpdateManyWithoutJobNestedInput;
  };

  export type TaxesUpsertWithoutInvoicesInput = {
    update: XOR<
      TaxesUpdateWithoutInvoicesInput,
      TaxesUncheckedUpdateWithoutInvoicesInput
    >;
    create: XOR<
      TaxesCreateWithoutInvoicesInput,
      TaxesUncheckedCreateWithoutInvoicesInput
    >;
    where?: TaxesWhereInput;
  };

  export type TaxesUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: TaxesWhereInput;
    data: XOR<
      TaxesUpdateWithoutInvoicesInput,
      TaxesUncheckedUpdateWithoutInvoicesInput
    >;
  };

  export type TaxesUpdateWithoutInvoicesInput = {
    name?: StringFieldUpdateOperationsInput | string;
    rate?: FloatFieldUpdateOperationsInput | number;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    users?: UsersUpdateManyWithoutDefault_taxNestedInput;
    quotes?: QuotesUpdateManyWithoutTaxNestedInput;
  };

  export type TaxesUncheckedUpdateWithoutInvoicesInput = {
    id?: IntFieldUpdateOperationsInput | number;
    name?: StringFieldUpdateOperationsInput | string;
    rate?: FloatFieldUpdateOperationsInput | number;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    users?: UsersUncheckedUpdateManyWithoutDefault_taxNestedInput;
    quotes?: QuotesUncheckedUpdateManyWithoutTaxNestedInput;
  };

  export type LineItemInvoiceUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: LineItemInvoiceWhereUniqueInput;
    update: XOR<
      LineItemInvoiceUpdateWithoutInvoiceInput,
      LineItemInvoiceUncheckedUpdateWithoutInvoiceInput
    >;
    create: XOR<
      LineItemInvoiceCreateWithoutInvoiceInput,
      LineItemInvoiceUncheckedCreateWithoutInvoiceInput
    >;
  };

  export type LineItemInvoiceUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: LineItemInvoiceWhereUniqueInput;
    data: XOR<
      LineItemInvoiceUpdateWithoutInvoiceInput,
      LineItemInvoiceUncheckedUpdateWithoutInvoiceInput
    >;
  };

  export type LineItemInvoiceUpdateManyWithWhereWithoutInvoiceInput = {
    where: LineItemInvoiceScalarWhereInput;
    data: XOR<
      LineItemInvoiceUpdateManyMutationInput,
      LineItemInvoiceUncheckedUpdateManyWithoutInvoiceInput
    >;
  };

  export type UsersUpsertWithoutInvoicesInput = {
    update: XOR<
      UsersUpdateWithoutInvoicesInput,
      UsersUncheckedUpdateWithoutInvoicesInput
    >;
    create: XOR<
      UsersCreateWithoutInvoicesInput,
      UsersUncheckedCreateWithoutInvoicesInput
    >;
    where?: UsersWhereInput;
  };

  export type UsersUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: UsersWhereInput;
    data: XOR<
      UsersUpdateWithoutInvoicesInput,
      UsersUncheckedUpdateWithoutInvoicesInput
    >;
  };

  export type UsersUpdateWithoutInvoicesInput = {
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: StringFieldUpdateOperationsInput | string;
    first_name?: StringFieldUpdateOperationsInput | string;
    last_name?: StringFieldUpdateOperationsInput | string;
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null;
    company_name?: NullableStringFieldUpdateOperationsInput | string | null;
    subscription_id?: NullableStringFieldUpdateOperationsInput | string | null;
    free_trial_expiration_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    settings?: NullableJsonNullValueInput | InputJsonValue;
    default_tax?: TaxesUpdateOneWithoutUsersNestedInput;
    address?: AddressesUpdateOneWithoutUsersNestedInput;
    clients?: ClientsUpdateManyWithoutBelongs_toNestedInput;
    requests?: RequestsUpdateManyWithoutBelongs_toNestedInput;
    jobs?: JobsUpdateManyWithoutBelongs_toNestedInput;
    quotes?: QuotesUpdateManyWithoutBelongs_toNestedInput;
  };

  export type UsersUncheckedUpdateWithoutInvoicesInput = {
    id?: IntFieldUpdateOperationsInput | number;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: StringFieldUpdateOperationsInput | string;
    first_name?: StringFieldUpdateOperationsInput | string;
    last_name?: StringFieldUpdateOperationsInput | string;
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null;
    company_name?: NullableStringFieldUpdateOperationsInput | string | null;
    subscription_id?: NullableStringFieldUpdateOperationsInput | string | null;
    free_trial_expiration_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    default_tax_id?: NullableIntFieldUpdateOperationsInput | number | null;
    address_id?: NullableIntFieldUpdateOperationsInput | number | null;
    settings?: NullableJsonNullValueInput | InputJsonValue;
    clients?: ClientsUncheckedUpdateManyWithoutBelongs_toNestedInput;
    requests?: RequestsUncheckedUpdateManyWithoutBelongs_toNestedInput;
    jobs?: JobsUncheckedUpdateManyWithoutBelongs_toNestedInput;
    quotes?: QuotesUncheckedUpdateManyWithoutBelongs_toNestedInput;
  };

  export type InvoicesCreateWithoutAdditional_line_itemsInput = {
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: boolean;
    texted_to_client?: boolean;
    issued_date: Date | string;
    due_date?: Date | string | null;
    status: string;
    type: string;
    subject: string;
    client_message: string;
    internal_notes: string;
    internalAttachmentUrl: string;
    client: ClientsCreateNestedOneWithoutInvoicesInput;
    job?: JobsCreateNestedOneWithoutInvoicesInput;
    tax?: TaxesCreateNestedOneWithoutInvoicesInput;
    belongs_to: UsersCreateNestedOneWithoutInvoicesInput;
  };

  export type InvoicesUncheckedCreateWithoutAdditional_line_itemsInput = {
    id?: number;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: boolean;
    texted_to_client?: boolean;
    issued_date: Date | string;
    due_date?: Date | string | null;
    status: string;
    type: string;
    subject: string;
    client_id: number;
    job_id?: number | null;
    tax_id?: number | null;
    client_message: string;
    internal_notes: string;
    internalAttachmentUrl: string;
    belongs_to_id: number;
  };

  export type InvoicesCreateOrConnectWithoutAdditional_line_itemsInput = {
    where: InvoicesWhereUniqueInput;
    create: XOR<
      InvoicesCreateWithoutAdditional_line_itemsInput,
      InvoicesUncheckedCreateWithoutAdditional_line_itemsInput
    >;
  };

  export type LineItemsCreateWithoutInvoicesInput = {
    type: string;
    name: string;
    description?: string | null;
    quantity?: number;
    unit_price: number;
    markup?: number | null;
    img_url?: string | null;
    recommend_item?: boolean;
    quotes?: LineItemQuoteCreateNestedManyWithoutLine_itemInput;
    jobs?: LineItemJobCreateNestedManyWithoutLine_itemInput;
  };

  export type LineItemsUncheckedCreateWithoutInvoicesInput = {
    id?: number;
    type: string;
    name: string;
    description?: string | null;
    quantity?: number;
    unit_price: number;
    markup?: number | null;
    img_url?: string | null;
    recommend_item?: boolean;
    quotes?: LineItemQuoteUncheckedCreateNestedManyWithoutLine_itemInput;
    jobs?: LineItemJobUncheckedCreateNestedManyWithoutLine_itemInput;
  };

  export type LineItemsCreateOrConnectWithoutInvoicesInput = {
    where: LineItemsWhereUniqueInput;
    create: XOR<
      LineItemsCreateWithoutInvoicesInput,
      LineItemsUncheckedCreateWithoutInvoicesInput
    >;
  };

  export type InvoicesUpsertWithoutAdditional_line_itemsInput = {
    update: XOR<
      InvoicesUpdateWithoutAdditional_line_itemsInput,
      InvoicesUncheckedUpdateWithoutAdditional_line_itemsInput
    >;
    create: XOR<
      InvoicesCreateWithoutAdditional_line_itemsInput,
      InvoicesUncheckedCreateWithoutAdditional_line_itemsInput
    >;
    where?: InvoicesWhereInput;
  };

  export type InvoicesUpdateToOneWithWhereWithoutAdditional_line_itemsInput = {
    where?: InvoicesWhereInput;
    data: XOR<
      InvoicesUpdateWithoutAdditional_line_itemsInput,
      InvoicesUncheckedUpdateWithoutAdditional_line_itemsInput
    >;
  };

  export type InvoicesUpdateWithoutAdditional_line_itemsInput = {
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: BoolFieldUpdateOperationsInput | boolean;
    texted_to_client?: BoolFieldUpdateOperationsInput | boolean;
    issued_date?: DateTimeFieldUpdateOperationsInput | Date | string;
    due_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    status?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    subject?: StringFieldUpdateOperationsInput | string;
    client_message?: StringFieldUpdateOperationsInput | string;
    internal_notes?: StringFieldUpdateOperationsInput | string;
    internalAttachmentUrl?: StringFieldUpdateOperationsInput | string;
    client?: ClientsUpdateOneRequiredWithoutInvoicesNestedInput;
    job?: JobsUpdateOneWithoutInvoicesNestedInput;
    tax?: TaxesUpdateOneWithoutInvoicesNestedInput;
    belongs_to?: UsersUpdateOneRequiredWithoutInvoicesNestedInput;
  };

  export type InvoicesUncheckedUpdateWithoutAdditional_line_itemsInput = {
    id?: IntFieldUpdateOperationsInput | number;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: BoolFieldUpdateOperationsInput | boolean;
    texted_to_client?: BoolFieldUpdateOperationsInput | boolean;
    issued_date?: DateTimeFieldUpdateOperationsInput | Date | string;
    due_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    status?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    subject?: StringFieldUpdateOperationsInput | string;
    client_id?: IntFieldUpdateOperationsInput | number;
    job_id?: NullableIntFieldUpdateOperationsInput | number | null;
    tax_id?: NullableIntFieldUpdateOperationsInput | number | null;
    client_message?: StringFieldUpdateOperationsInput | string;
    internal_notes?: StringFieldUpdateOperationsInput | string;
    internalAttachmentUrl?: StringFieldUpdateOperationsInput | string;
    belongs_to_id?: IntFieldUpdateOperationsInput | number;
  };

  export type LineItemsUpsertWithoutInvoicesInput = {
    update: XOR<
      LineItemsUpdateWithoutInvoicesInput,
      LineItemsUncheckedUpdateWithoutInvoicesInput
    >;
    create: XOR<
      LineItemsCreateWithoutInvoicesInput,
      LineItemsUncheckedCreateWithoutInvoicesInput
    >;
    where?: LineItemsWhereInput;
  };

  export type LineItemsUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: LineItemsWhereInput;
    data: XOR<
      LineItemsUpdateWithoutInvoicesInput,
      LineItemsUncheckedUpdateWithoutInvoicesInput
    >;
  };

  export type LineItemsUpdateWithoutInvoicesInput = {
    type?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    quantity?: IntFieldUpdateOperationsInput | number;
    unit_price?: FloatFieldUpdateOperationsInput | number;
    markup?: NullableFloatFieldUpdateOperationsInput | number | null;
    img_url?: NullableStringFieldUpdateOperationsInput | string | null;
    recommend_item?: BoolFieldUpdateOperationsInput | boolean;
    quotes?: LineItemQuoteUpdateManyWithoutLine_itemNestedInput;
    jobs?: LineItemJobUpdateManyWithoutLine_itemNestedInput;
  };

  export type LineItemsUncheckedUpdateWithoutInvoicesInput = {
    id?: IntFieldUpdateOperationsInput | number;
    type?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    quantity?: IntFieldUpdateOperationsInput | number;
    unit_price?: FloatFieldUpdateOperationsInput | number;
    markup?: NullableFloatFieldUpdateOperationsInput | number | null;
    img_url?: NullableStringFieldUpdateOperationsInput | string | null;
    recommend_item?: BoolFieldUpdateOperationsInput | boolean;
    quotes?: LineItemQuoteUncheckedUpdateManyWithoutLine_itemNestedInput;
    jobs?: LineItemJobUncheckedUpdateManyWithoutLine_itemNestedInput;
  };

  export type UsersCreateManyDefault_taxInput = {
    id?: number;
    email?: string | null;
    password: string;
    first_name: string;
    last_name: string;
    phone_number?: string | null;
    company_name?: string | null;
    subscription_id?: string | null;
    free_trial_expiration_date?: Date | string | null;
    address_id?: number | null;
    settings?: NullableJsonNullValueInput | InputJsonValue;
  };

  export type QuotesCreateManyTaxInput = {
    id?: number;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: boolean;
    texted_to_client?: boolean;
    status: string;
    title: string;
    quote_number: string;
    opportunity_rating?: string | null;
    client_id: number;
    client_message?: string | null;
    discount?: number | null;
    discount_unit?: string | null;
    required_deposit?: number | null;
    link_to_releated_jobs?: boolean;
    link_to_releated_invoices?: boolean;
    belongs_to_id: number;
  };

  export type InvoicesCreateManyTaxInput = {
    id?: number;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: boolean;
    texted_to_client?: boolean;
    issued_date: Date | string;
    due_date?: Date | string | null;
    status: string;
    type: string;
    subject: string;
    client_id: number;
    job_id?: number | null;
    client_message: string;
    internal_notes: string;
    internalAttachmentUrl: string;
    belongs_to_id: number;
  };

  export type UsersUpdateWithoutDefault_taxInput = {
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: StringFieldUpdateOperationsInput | string;
    first_name?: StringFieldUpdateOperationsInput | string;
    last_name?: StringFieldUpdateOperationsInput | string;
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null;
    company_name?: NullableStringFieldUpdateOperationsInput | string | null;
    subscription_id?: NullableStringFieldUpdateOperationsInput | string | null;
    free_trial_expiration_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    settings?: NullableJsonNullValueInput | InputJsonValue;
    address?: AddressesUpdateOneWithoutUsersNestedInput;
    clients?: ClientsUpdateManyWithoutBelongs_toNestedInput;
    requests?: RequestsUpdateManyWithoutBelongs_toNestedInput;
    jobs?: JobsUpdateManyWithoutBelongs_toNestedInput;
    quotes?: QuotesUpdateManyWithoutBelongs_toNestedInput;
    invoices?: InvoicesUpdateManyWithoutBelongs_toNestedInput;
  };

  export type UsersUncheckedUpdateWithoutDefault_taxInput = {
    id?: IntFieldUpdateOperationsInput | number;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: StringFieldUpdateOperationsInput | string;
    first_name?: StringFieldUpdateOperationsInput | string;
    last_name?: StringFieldUpdateOperationsInput | string;
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null;
    company_name?: NullableStringFieldUpdateOperationsInput | string | null;
    subscription_id?: NullableStringFieldUpdateOperationsInput | string | null;
    free_trial_expiration_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    address_id?: NullableIntFieldUpdateOperationsInput | number | null;
    settings?: NullableJsonNullValueInput | InputJsonValue;
    clients?: ClientsUncheckedUpdateManyWithoutBelongs_toNestedInput;
    requests?: RequestsUncheckedUpdateManyWithoutBelongs_toNestedInput;
    jobs?: JobsUncheckedUpdateManyWithoutBelongs_toNestedInput;
    quotes?: QuotesUncheckedUpdateManyWithoutBelongs_toNestedInput;
    invoices?: InvoicesUncheckedUpdateManyWithoutBelongs_toNestedInput;
  };

  export type UsersUncheckedUpdateManyWithoutDefault_taxInput = {
    id?: IntFieldUpdateOperationsInput | number;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: StringFieldUpdateOperationsInput | string;
    first_name?: StringFieldUpdateOperationsInput | string;
    last_name?: StringFieldUpdateOperationsInput | string;
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null;
    company_name?: NullableStringFieldUpdateOperationsInput | string | null;
    subscription_id?: NullableStringFieldUpdateOperationsInput | string | null;
    free_trial_expiration_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    address_id?: NullableIntFieldUpdateOperationsInput | number | null;
    settings?: NullableJsonNullValueInput | InputJsonValue;
  };

  export type QuotesUpdateWithoutTaxInput = {
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: BoolFieldUpdateOperationsInput | boolean;
    texted_to_client?: BoolFieldUpdateOperationsInput | boolean;
    status?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    quote_number?: StringFieldUpdateOperationsInput | string;
    opportunity_rating?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    client_message?: NullableStringFieldUpdateOperationsInput | string | null;
    discount?: NullableFloatFieldUpdateOperationsInput | number | null;
    discount_unit?: NullableStringFieldUpdateOperationsInput | string | null;
    required_deposit?: NullableFloatFieldUpdateOperationsInput | number | null;
    link_to_releated_jobs?: BoolFieldUpdateOperationsInput | boolean;
    link_to_releated_invoices?: BoolFieldUpdateOperationsInput | boolean;
    client?: ClientsUpdateOneRequiredWithoutQuotesNestedInput;
    line_items?: LineItemQuoteUpdateManyWithoutQuoteNestedInput;
    requests?: QuoteRequestUpdateManyWithoutQuoteNestedInput;
    job_quotes?: JobQuoteUpdateManyWithoutQuoteNestedInput;
    belongs_to?: UsersUpdateOneRequiredWithoutQuotesNestedInput;
  };

  export type QuotesUncheckedUpdateWithoutTaxInput = {
    id?: IntFieldUpdateOperationsInput | number;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: BoolFieldUpdateOperationsInput | boolean;
    texted_to_client?: BoolFieldUpdateOperationsInput | boolean;
    status?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    quote_number?: StringFieldUpdateOperationsInput | string;
    opportunity_rating?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    client_id?: IntFieldUpdateOperationsInput | number;
    client_message?: NullableStringFieldUpdateOperationsInput | string | null;
    discount?: NullableFloatFieldUpdateOperationsInput | number | null;
    discount_unit?: NullableStringFieldUpdateOperationsInput | string | null;
    required_deposit?: NullableFloatFieldUpdateOperationsInput | number | null;
    link_to_releated_jobs?: BoolFieldUpdateOperationsInput | boolean;
    link_to_releated_invoices?: BoolFieldUpdateOperationsInput | boolean;
    belongs_to_id?: IntFieldUpdateOperationsInput | number;
    line_items?: LineItemQuoteUncheckedUpdateManyWithoutQuoteNestedInput;
    requests?: QuoteRequestUncheckedUpdateManyWithoutQuoteNestedInput;
    job_quotes?: JobQuoteUncheckedUpdateManyWithoutQuoteNestedInput;
  };

  export type QuotesUncheckedUpdateManyWithoutTaxInput = {
    id?: IntFieldUpdateOperationsInput | number;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: BoolFieldUpdateOperationsInput | boolean;
    texted_to_client?: BoolFieldUpdateOperationsInput | boolean;
    status?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    quote_number?: StringFieldUpdateOperationsInput | string;
    opportunity_rating?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    client_id?: IntFieldUpdateOperationsInput | number;
    client_message?: NullableStringFieldUpdateOperationsInput | string | null;
    discount?: NullableFloatFieldUpdateOperationsInput | number | null;
    discount_unit?: NullableStringFieldUpdateOperationsInput | string | null;
    required_deposit?: NullableFloatFieldUpdateOperationsInput | number | null;
    link_to_releated_jobs?: BoolFieldUpdateOperationsInput | boolean;
    link_to_releated_invoices?: BoolFieldUpdateOperationsInput | boolean;
    belongs_to_id?: IntFieldUpdateOperationsInput | number;
  };

  export type InvoicesUpdateWithoutTaxInput = {
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: BoolFieldUpdateOperationsInput | boolean;
    texted_to_client?: BoolFieldUpdateOperationsInput | boolean;
    issued_date?: DateTimeFieldUpdateOperationsInput | Date | string;
    due_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    status?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    subject?: StringFieldUpdateOperationsInput | string;
    client_message?: StringFieldUpdateOperationsInput | string;
    internal_notes?: StringFieldUpdateOperationsInput | string;
    internalAttachmentUrl?: StringFieldUpdateOperationsInput | string;
    client?: ClientsUpdateOneRequiredWithoutInvoicesNestedInput;
    job?: JobsUpdateOneWithoutInvoicesNestedInput;
    additional_line_items?: LineItemInvoiceUpdateManyWithoutInvoiceNestedInput;
    belongs_to?: UsersUpdateOneRequiredWithoutInvoicesNestedInput;
  };

  export type InvoicesUncheckedUpdateWithoutTaxInput = {
    id?: IntFieldUpdateOperationsInput | number;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: BoolFieldUpdateOperationsInput | boolean;
    texted_to_client?: BoolFieldUpdateOperationsInput | boolean;
    issued_date?: DateTimeFieldUpdateOperationsInput | Date | string;
    due_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    status?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    subject?: StringFieldUpdateOperationsInput | string;
    client_id?: IntFieldUpdateOperationsInput | number;
    job_id?: NullableIntFieldUpdateOperationsInput | number | null;
    client_message?: StringFieldUpdateOperationsInput | string;
    internal_notes?: StringFieldUpdateOperationsInput | string;
    internalAttachmentUrl?: StringFieldUpdateOperationsInput | string;
    belongs_to_id?: IntFieldUpdateOperationsInput | number;
    additional_line_items?: LineItemInvoiceUncheckedUpdateManyWithoutInvoiceNestedInput;
  };

  export type InvoicesUncheckedUpdateManyWithoutTaxInput = {
    id?: IntFieldUpdateOperationsInput | number;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: BoolFieldUpdateOperationsInput | boolean;
    texted_to_client?: BoolFieldUpdateOperationsInput | boolean;
    issued_date?: DateTimeFieldUpdateOperationsInput | Date | string;
    due_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    status?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    subject?: StringFieldUpdateOperationsInput | string;
    client_id?: IntFieldUpdateOperationsInput | number;
    job_id?: NullableIntFieldUpdateOperationsInput | number | null;
    client_message?: StringFieldUpdateOperationsInput | string;
    internal_notes?: StringFieldUpdateOperationsInput | string;
    internalAttachmentUrl?: StringFieldUpdateOperationsInput | string;
    belongs_to_id?: IntFieldUpdateOperationsInput | number;
  };

  export type UsersCreateManyAddressInput = {
    id?: number;
    email?: string | null;
    password: string;
    first_name: string;
    last_name: string;
    phone_number?: string | null;
    company_name?: string | null;
    subscription_id?: string | null;
    free_trial_expiration_date?: Date | string | null;
    default_tax_id?: number | null;
    settings?: NullableJsonNullValueInput | InputJsonValue;
  };

  export type ClientsCreateManyProperty_addressInput = {
    id?: number;
    title: string;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    first_name: string;
    last_name: string;
    company_name?: string | null;
    use_company_name_as_primary?: boolean;
    mobile_phone_number?: string | null;
    work_phone_number?: string | null;
    email?: string | null;
    quote_follow_up?: boolean;
    job_follow_up?: boolean;
    invoice_follow_up?: boolean;
    upcoming_visit_reminder?: boolean;
    referred_by?: string | null;
    billing_address_same_as_property?: boolean;
    billing_address_id?: number | null;
    created_date?: Date | string;
    status?: string | null;
    belongs_to_id: number;
  };

  export type ClientsCreateManyBilling_addressInput = {
    id?: number;
    title: string;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    first_name: string;
    last_name: string;
    company_name?: string | null;
    use_company_name_as_primary?: boolean;
    mobile_phone_number?: string | null;
    work_phone_number?: string | null;
    email?: string | null;
    quote_follow_up?: boolean;
    job_follow_up?: boolean;
    invoice_follow_up?: boolean;
    upcoming_visit_reminder?: boolean;
    referred_by?: string | null;
    billing_address_same_as_property?: boolean;
    property_address_id?: number | null;
    created_date?: Date | string;
    status?: string | null;
    belongs_to_id: number;
  };

  export type UsersUpdateWithoutAddressInput = {
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: StringFieldUpdateOperationsInput | string;
    first_name?: StringFieldUpdateOperationsInput | string;
    last_name?: StringFieldUpdateOperationsInput | string;
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null;
    company_name?: NullableStringFieldUpdateOperationsInput | string | null;
    subscription_id?: NullableStringFieldUpdateOperationsInput | string | null;
    free_trial_expiration_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    settings?: NullableJsonNullValueInput | InputJsonValue;
    default_tax?: TaxesUpdateOneWithoutUsersNestedInput;
    clients?: ClientsUpdateManyWithoutBelongs_toNestedInput;
    requests?: RequestsUpdateManyWithoutBelongs_toNestedInput;
    jobs?: JobsUpdateManyWithoutBelongs_toNestedInput;
    quotes?: QuotesUpdateManyWithoutBelongs_toNestedInput;
    invoices?: InvoicesUpdateManyWithoutBelongs_toNestedInput;
  };

  export type UsersUncheckedUpdateWithoutAddressInput = {
    id?: IntFieldUpdateOperationsInput | number;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: StringFieldUpdateOperationsInput | string;
    first_name?: StringFieldUpdateOperationsInput | string;
    last_name?: StringFieldUpdateOperationsInput | string;
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null;
    company_name?: NullableStringFieldUpdateOperationsInput | string | null;
    subscription_id?: NullableStringFieldUpdateOperationsInput | string | null;
    free_trial_expiration_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    default_tax_id?: NullableIntFieldUpdateOperationsInput | number | null;
    settings?: NullableJsonNullValueInput | InputJsonValue;
    clients?: ClientsUncheckedUpdateManyWithoutBelongs_toNestedInput;
    requests?: RequestsUncheckedUpdateManyWithoutBelongs_toNestedInput;
    jobs?: JobsUncheckedUpdateManyWithoutBelongs_toNestedInput;
    quotes?: QuotesUncheckedUpdateManyWithoutBelongs_toNestedInput;
    invoices?: InvoicesUncheckedUpdateManyWithoutBelongs_toNestedInput;
  };

  export type UsersUncheckedUpdateManyWithoutAddressInput = {
    id?: IntFieldUpdateOperationsInput | number;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: StringFieldUpdateOperationsInput | string;
    first_name?: StringFieldUpdateOperationsInput | string;
    last_name?: StringFieldUpdateOperationsInput | string;
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null;
    company_name?: NullableStringFieldUpdateOperationsInput | string | null;
    subscription_id?: NullableStringFieldUpdateOperationsInput | string | null;
    free_trial_expiration_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    default_tax_id?: NullableIntFieldUpdateOperationsInput | number | null;
    settings?: NullableJsonNullValueInput | InputJsonValue;
  };

  export type ClientsUpdateWithoutProperty_addressInput = {
    title?: StringFieldUpdateOperationsInput | string;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    first_name?: StringFieldUpdateOperationsInput | string;
    last_name?: StringFieldUpdateOperationsInput | string;
    company_name?: NullableStringFieldUpdateOperationsInput | string | null;
    use_company_name_as_primary?: BoolFieldUpdateOperationsInput | boolean;
    mobile_phone_number?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    work_phone_number?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    quote_follow_up?: BoolFieldUpdateOperationsInput | boolean;
    job_follow_up?: BoolFieldUpdateOperationsInput | boolean;
    invoice_follow_up?: BoolFieldUpdateOperationsInput | boolean;
    upcoming_visit_reminder?: BoolFieldUpdateOperationsInput | boolean;
    referred_by?: NullableStringFieldUpdateOperationsInput | string | null;
    billing_address_same_as_property?: BoolFieldUpdateOperationsInput | boolean;
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string;
    status?: NullableStringFieldUpdateOperationsInput | string | null;
    billing_address?: AddressesUpdateOneWithoutBilling_clientsNestedInput;
    requests?: RequestsUpdateManyWithoutClientNestedInput;
    quotes?: QuotesUpdateManyWithoutClientNestedInput;
    jobs?: JobsUpdateManyWithoutClientNestedInput;
    invoices?: InvoicesUpdateManyWithoutClientNestedInput;
    belongs_to?: UsersUpdateOneRequiredWithoutClientsNestedInput;
  };

  export type ClientsUncheckedUpdateWithoutProperty_addressInput = {
    id?: IntFieldUpdateOperationsInput | number;
    title?: StringFieldUpdateOperationsInput | string;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    first_name?: StringFieldUpdateOperationsInput | string;
    last_name?: StringFieldUpdateOperationsInput | string;
    company_name?: NullableStringFieldUpdateOperationsInput | string | null;
    use_company_name_as_primary?: BoolFieldUpdateOperationsInput | boolean;
    mobile_phone_number?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    work_phone_number?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    quote_follow_up?: BoolFieldUpdateOperationsInput | boolean;
    job_follow_up?: BoolFieldUpdateOperationsInput | boolean;
    invoice_follow_up?: BoolFieldUpdateOperationsInput | boolean;
    upcoming_visit_reminder?: BoolFieldUpdateOperationsInput | boolean;
    referred_by?: NullableStringFieldUpdateOperationsInput | string | null;
    billing_address_same_as_property?: BoolFieldUpdateOperationsInput | boolean;
    billing_address_id?: NullableIntFieldUpdateOperationsInput | number | null;
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string;
    status?: NullableStringFieldUpdateOperationsInput | string | null;
    belongs_to_id?: IntFieldUpdateOperationsInput | number;
    requests?: RequestsUncheckedUpdateManyWithoutClientNestedInput;
    quotes?: QuotesUncheckedUpdateManyWithoutClientNestedInput;
    jobs?: JobsUncheckedUpdateManyWithoutClientNestedInput;
    invoices?: InvoicesUncheckedUpdateManyWithoutClientNestedInput;
  };

  export type ClientsUncheckedUpdateManyWithoutProperty_addressInput = {
    id?: IntFieldUpdateOperationsInput | number;
    title?: StringFieldUpdateOperationsInput | string;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    first_name?: StringFieldUpdateOperationsInput | string;
    last_name?: StringFieldUpdateOperationsInput | string;
    company_name?: NullableStringFieldUpdateOperationsInput | string | null;
    use_company_name_as_primary?: BoolFieldUpdateOperationsInput | boolean;
    mobile_phone_number?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    work_phone_number?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    quote_follow_up?: BoolFieldUpdateOperationsInput | boolean;
    job_follow_up?: BoolFieldUpdateOperationsInput | boolean;
    invoice_follow_up?: BoolFieldUpdateOperationsInput | boolean;
    upcoming_visit_reminder?: BoolFieldUpdateOperationsInput | boolean;
    referred_by?: NullableStringFieldUpdateOperationsInput | string | null;
    billing_address_same_as_property?: BoolFieldUpdateOperationsInput | boolean;
    billing_address_id?: NullableIntFieldUpdateOperationsInput | number | null;
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string;
    status?: NullableStringFieldUpdateOperationsInput | string | null;
    belongs_to_id?: IntFieldUpdateOperationsInput | number;
  };

  export type ClientsUpdateWithoutBilling_addressInput = {
    title?: StringFieldUpdateOperationsInput | string;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    first_name?: StringFieldUpdateOperationsInput | string;
    last_name?: StringFieldUpdateOperationsInput | string;
    company_name?: NullableStringFieldUpdateOperationsInput | string | null;
    use_company_name_as_primary?: BoolFieldUpdateOperationsInput | boolean;
    mobile_phone_number?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    work_phone_number?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    quote_follow_up?: BoolFieldUpdateOperationsInput | boolean;
    job_follow_up?: BoolFieldUpdateOperationsInput | boolean;
    invoice_follow_up?: BoolFieldUpdateOperationsInput | boolean;
    upcoming_visit_reminder?: BoolFieldUpdateOperationsInput | boolean;
    referred_by?: NullableStringFieldUpdateOperationsInput | string | null;
    billing_address_same_as_property?: BoolFieldUpdateOperationsInput | boolean;
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string;
    status?: NullableStringFieldUpdateOperationsInput | string | null;
    property_address?: AddressesUpdateOneWithoutProperty_clientsNestedInput;
    requests?: RequestsUpdateManyWithoutClientNestedInput;
    quotes?: QuotesUpdateManyWithoutClientNestedInput;
    jobs?: JobsUpdateManyWithoutClientNestedInput;
    invoices?: InvoicesUpdateManyWithoutClientNestedInput;
    belongs_to?: UsersUpdateOneRequiredWithoutClientsNestedInput;
  };

  export type ClientsUncheckedUpdateWithoutBilling_addressInput = {
    id?: IntFieldUpdateOperationsInput | number;
    title?: StringFieldUpdateOperationsInput | string;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    first_name?: StringFieldUpdateOperationsInput | string;
    last_name?: StringFieldUpdateOperationsInput | string;
    company_name?: NullableStringFieldUpdateOperationsInput | string | null;
    use_company_name_as_primary?: BoolFieldUpdateOperationsInput | boolean;
    mobile_phone_number?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    work_phone_number?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    quote_follow_up?: BoolFieldUpdateOperationsInput | boolean;
    job_follow_up?: BoolFieldUpdateOperationsInput | boolean;
    invoice_follow_up?: BoolFieldUpdateOperationsInput | boolean;
    upcoming_visit_reminder?: BoolFieldUpdateOperationsInput | boolean;
    referred_by?: NullableStringFieldUpdateOperationsInput | string | null;
    billing_address_same_as_property?: BoolFieldUpdateOperationsInput | boolean;
    property_address_id?: NullableIntFieldUpdateOperationsInput | number | null;
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string;
    status?: NullableStringFieldUpdateOperationsInput | string | null;
    belongs_to_id?: IntFieldUpdateOperationsInput | number;
    requests?: RequestsUncheckedUpdateManyWithoutClientNestedInput;
    quotes?: QuotesUncheckedUpdateManyWithoutClientNestedInput;
    jobs?: JobsUncheckedUpdateManyWithoutClientNestedInput;
    invoices?: InvoicesUncheckedUpdateManyWithoutClientNestedInput;
  };

  export type ClientsUncheckedUpdateManyWithoutBilling_addressInput = {
    id?: IntFieldUpdateOperationsInput | number;
    title?: StringFieldUpdateOperationsInput | string;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    first_name?: StringFieldUpdateOperationsInput | string;
    last_name?: StringFieldUpdateOperationsInput | string;
    company_name?: NullableStringFieldUpdateOperationsInput | string | null;
    use_company_name_as_primary?: BoolFieldUpdateOperationsInput | boolean;
    mobile_phone_number?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    work_phone_number?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    quote_follow_up?: BoolFieldUpdateOperationsInput | boolean;
    job_follow_up?: BoolFieldUpdateOperationsInput | boolean;
    invoice_follow_up?: BoolFieldUpdateOperationsInput | boolean;
    upcoming_visit_reminder?: BoolFieldUpdateOperationsInput | boolean;
    referred_by?: NullableStringFieldUpdateOperationsInput | string | null;
    billing_address_same_as_property?: BoolFieldUpdateOperationsInput | boolean;
    property_address_id?: NullableIntFieldUpdateOperationsInput | number | null;
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string;
    status?: NullableStringFieldUpdateOperationsInput | string | null;
    belongs_to_id?: IntFieldUpdateOperationsInput | number;
  };

  export type ClientsCreateManyBelongs_toInput = {
    id?: number;
    title: string;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    first_name: string;
    last_name: string;
    company_name?: string | null;
    use_company_name_as_primary?: boolean;
    mobile_phone_number?: string | null;
    work_phone_number?: string | null;
    email?: string | null;
    quote_follow_up?: boolean;
    job_follow_up?: boolean;
    invoice_follow_up?: boolean;
    upcoming_visit_reminder?: boolean;
    referred_by?: string | null;
    billing_address_same_as_property?: boolean;
    property_address_id?: number | null;
    billing_address_id?: number | null;
    created_date?: Date | string;
    status?: string | null;
  };

  export type RequestsCreateManyBelongs_toInput = {
    id?: number;
    status: string;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: boolean;
    texted_to_client?: boolean;
    title: string;
    service_details: string;
    assessment_date: Date | string;
    backup_assessment__date?: Date | string | null;
    preferred_arrival_times?: string | null;
    on_site_assesment_required?: boolean;
    client_id: number;
    assessment_id: number;
    internal_notes: string;
    internalAttachmentUrl: string;
    link_to_releated_quotes?: boolean;
    link_to_releated_jobs?: boolean;
    link_to_releated_invoices?: boolean;
  };

  export type JobsCreateManyBelongs_toInput = {
    id?: number;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: boolean;
    texted_to_client?: boolean;
    status: string;
    client_id: number;
    title: string;
    instructions?: string | null;
    number: string;
    schedule_type: string;
    recurring_frequency?: string | null;
    recurring_interval?: string | null;
    day_of_week?: string | null;
    day_of_year?: string | null;
    duration?: string | null;
    start_date?: Date | string | null;
    end_date?: Date | string | null;
    start_time?: Date | string | null;
    end_time?: Date | string | null;
    schedule_later?: boolean;
    team?: string | null;
    email_team?: boolean;
    invoice_reminder?: boolean;
    internal_notes?: string | null;
    internal_attachment_url?: string | null;
    link_to_related_invoices?: boolean;
  };

  export type QuotesCreateManyBelongs_toInput = {
    id?: number;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: boolean;
    texted_to_client?: boolean;
    status: string;
    title: string;
    quote_number: string;
    opportunity_rating?: string | null;
    client_id: number;
    client_message?: string | null;
    discount?: number | null;
    discount_unit?: string | null;
    tax_id: number;
    required_deposit?: number | null;
    link_to_releated_jobs?: boolean;
    link_to_releated_invoices?: boolean;
  };

  export type InvoicesCreateManyBelongs_toInput = {
    id?: number;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: boolean;
    texted_to_client?: boolean;
    issued_date: Date | string;
    due_date?: Date | string | null;
    status: string;
    type: string;
    subject: string;
    client_id: number;
    job_id?: number | null;
    tax_id?: number | null;
    client_message: string;
    internal_notes: string;
    internalAttachmentUrl: string;
  };

  export type ClientsUpdateWithoutBelongs_toInput = {
    title?: StringFieldUpdateOperationsInput | string;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    first_name?: StringFieldUpdateOperationsInput | string;
    last_name?: StringFieldUpdateOperationsInput | string;
    company_name?: NullableStringFieldUpdateOperationsInput | string | null;
    use_company_name_as_primary?: BoolFieldUpdateOperationsInput | boolean;
    mobile_phone_number?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    work_phone_number?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    quote_follow_up?: BoolFieldUpdateOperationsInput | boolean;
    job_follow_up?: BoolFieldUpdateOperationsInput | boolean;
    invoice_follow_up?: BoolFieldUpdateOperationsInput | boolean;
    upcoming_visit_reminder?: BoolFieldUpdateOperationsInput | boolean;
    referred_by?: NullableStringFieldUpdateOperationsInput | string | null;
    billing_address_same_as_property?: BoolFieldUpdateOperationsInput | boolean;
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string;
    status?: NullableStringFieldUpdateOperationsInput | string | null;
    property_address?: AddressesUpdateOneWithoutProperty_clientsNestedInput;
    billing_address?: AddressesUpdateOneWithoutBilling_clientsNestedInput;
    requests?: RequestsUpdateManyWithoutClientNestedInput;
    quotes?: QuotesUpdateManyWithoutClientNestedInput;
    jobs?: JobsUpdateManyWithoutClientNestedInput;
    invoices?: InvoicesUpdateManyWithoutClientNestedInput;
  };

  export type ClientsUncheckedUpdateWithoutBelongs_toInput = {
    id?: IntFieldUpdateOperationsInput | number;
    title?: StringFieldUpdateOperationsInput | string;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    first_name?: StringFieldUpdateOperationsInput | string;
    last_name?: StringFieldUpdateOperationsInput | string;
    company_name?: NullableStringFieldUpdateOperationsInput | string | null;
    use_company_name_as_primary?: BoolFieldUpdateOperationsInput | boolean;
    mobile_phone_number?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    work_phone_number?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    quote_follow_up?: BoolFieldUpdateOperationsInput | boolean;
    job_follow_up?: BoolFieldUpdateOperationsInput | boolean;
    invoice_follow_up?: BoolFieldUpdateOperationsInput | boolean;
    upcoming_visit_reminder?: BoolFieldUpdateOperationsInput | boolean;
    referred_by?: NullableStringFieldUpdateOperationsInput | string | null;
    billing_address_same_as_property?: BoolFieldUpdateOperationsInput | boolean;
    property_address_id?: NullableIntFieldUpdateOperationsInput | number | null;
    billing_address_id?: NullableIntFieldUpdateOperationsInput | number | null;
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string;
    status?: NullableStringFieldUpdateOperationsInput | string | null;
    requests?: RequestsUncheckedUpdateManyWithoutClientNestedInput;
    quotes?: QuotesUncheckedUpdateManyWithoutClientNestedInput;
    jobs?: JobsUncheckedUpdateManyWithoutClientNestedInput;
    invoices?: InvoicesUncheckedUpdateManyWithoutClientNestedInput;
  };

  export type ClientsUncheckedUpdateManyWithoutBelongs_toInput = {
    id?: IntFieldUpdateOperationsInput | number;
    title?: StringFieldUpdateOperationsInput | string;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    first_name?: StringFieldUpdateOperationsInput | string;
    last_name?: StringFieldUpdateOperationsInput | string;
    company_name?: NullableStringFieldUpdateOperationsInput | string | null;
    use_company_name_as_primary?: BoolFieldUpdateOperationsInput | boolean;
    mobile_phone_number?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    work_phone_number?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    quote_follow_up?: BoolFieldUpdateOperationsInput | boolean;
    job_follow_up?: BoolFieldUpdateOperationsInput | boolean;
    invoice_follow_up?: BoolFieldUpdateOperationsInput | boolean;
    upcoming_visit_reminder?: BoolFieldUpdateOperationsInput | boolean;
    referred_by?: NullableStringFieldUpdateOperationsInput | string | null;
    billing_address_same_as_property?: BoolFieldUpdateOperationsInput | boolean;
    property_address_id?: NullableIntFieldUpdateOperationsInput | number | null;
    billing_address_id?: NullableIntFieldUpdateOperationsInput | number | null;
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string;
    status?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type RequestsUpdateWithoutBelongs_toInput = {
    status?: StringFieldUpdateOperationsInput | string;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: BoolFieldUpdateOperationsInput | boolean;
    texted_to_client?: BoolFieldUpdateOperationsInput | boolean;
    title?: StringFieldUpdateOperationsInput | string;
    service_details?: StringFieldUpdateOperationsInput | string;
    assessment_date?: DateTimeFieldUpdateOperationsInput | Date | string;
    backup_assessment__date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    preferred_arrival_times?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    on_site_assesment_required?: BoolFieldUpdateOperationsInput | boolean;
    internal_notes?: StringFieldUpdateOperationsInput | string;
    internalAttachmentUrl?: StringFieldUpdateOperationsInput | string;
    link_to_releated_quotes?: BoolFieldUpdateOperationsInput | boolean;
    link_to_releated_jobs?: BoolFieldUpdateOperationsInput | boolean;
    link_to_releated_invoices?: BoolFieldUpdateOperationsInput | boolean;
    assessment?: AssessmentsUpdateOneRequiredWithoutRequestsNestedInput;
    client?: ClientsUpdateOneRequiredWithoutRequestsNestedInput;
    quotes?: QuoteRequestUpdateManyWithoutRequestNestedInput;
    job_requests?: JobRequestUpdateManyWithoutRequestNestedInput;
  };

  export type RequestsUncheckedUpdateWithoutBelongs_toInput = {
    id?: IntFieldUpdateOperationsInput | number;
    status?: StringFieldUpdateOperationsInput | string;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: BoolFieldUpdateOperationsInput | boolean;
    texted_to_client?: BoolFieldUpdateOperationsInput | boolean;
    title?: StringFieldUpdateOperationsInput | string;
    service_details?: StringFieldUpdateOperationsInput | string;
    assessment_date?: DateTimeFieldUpdateOperationsInput | Date | string;
    backup_assessment__date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    preferred_arrival_times?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    on_site_assesment_required?: BoolFieldUpdateOperationsInput | boolean;
    client_id?: IntFieldUpdateOperationsInput | number;
    assessment_id?: IntFieldUpdateOperationsInput | number;
    internal_notes?: StringFieldUpdateOperationsInput | string;
    internalAttachmentUrl?: StringFieldUpdateOperationsInput | string;
    link_to_releated_quotes?: BoolFieldUpdateOperationsInput | boolean;
    link_to_releated_jobs?: BoolFieldUpdateOperationsInput | boolean;
    link_to_releated_invoices?: BoolFieldUpdateOperationsInput | boolean;
    quotes?: QuoteRequestUncheckedUpdateManyWithoutRequestNestedInput;
    job_requests?: JobRequestUncheckedUpdateManyWithoutRequestNestedInput;
  };

  export type RequestsUncheckedUpdateManyWithoutBelongs_toInput = {
    id?: IntFieldUpdateOperationsInput | number;
    status?: StringFieldUpdateOperationsInput | string;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: BoolFieldUpdateOperationsInput | boolean;
    texted_to_client?: BoolFieldUpdateOperationsInput | boolean;
    title?: StringFieldUpdateOperationsInput | string;
    service_details?: StringFieldUpdateOperationsInput | string;
    assessment_date?: DateTimeFieldUpdateOperationsInput | Date | string;
    backup_assessment__date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    preferred_arrival_times?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    on_site_assesment_required?: BoolFieldUpdateOperationsInput | boolean;
    client_id?: IntFieldUpdateOperationsInput | number;
    assessment_id?: IntFieldUpdateOperationsInput | number;
    internal_notes?: StringFieldUpdateOperationsInput | string;
    internalAttachmentUrl?: StringFieldUpdateOperationsInput | string;
    link_to_releated_quotes?: BoolFieldUpdateOperationsInput | boolean;
    link_to_releated_jobs?: BoolFieldUpdateOperationsInput | boolean;
    link_to_releated_invoices?: BoolFieldUpdateOperationsInput | boolean;
  };

  export type JobsUpdateWithoutBelongs_toInput = {
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: BoolFieldUpdateOperationsInput | boolean;
    texted_to_client?: BoolFieldUpdateOperationsInput | boolean;
    status?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    instructions?: NullableStringFieldUpdateOperationsInput | string | null;
    number?: StringFieldUpdateOperationsInput | string;
    schedule_type?: StringFieldUpdateOperationsInput | string;
    recurring_frequency?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    recurring_interval?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    day_of_week?: NullableStringFieldUpdateOperationsInput | string | null;
    day_of_year?: NullableStringFieldUpdateOperationsInput | string | null;
    duration?: NullableStringFieldUpdateOperationsInput | string | null;
    start_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    end_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    start_time?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    end_time?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    schedule_later?: BoolFieldUpdateOperationsInput | boolean;
    team?: NullableStringFieldUpdateOperationsInput | string | null;
    email_team?: BoolFieldUpdateOperationsInput | boolean;
    invoice_reminder?: BoolFieldUpdateOperationsInput | boolean;
    internal_notes?: NullableStringFieldUpdateOperationsInput | string | null;
    internal_attachment_url?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    link_to_related_invoices?: BoolFieldUpdateOperationsInput | boolean;
    client?: ClientsUpdateOneRequiredWithoutJobsNestedInput;
    line_items?: LineItemJobUpdateManyWithoutJobNestedInput;
    job_requests?: JobRequestUpdateManyWithoutJobNestedInput;
    job_quotes?: JobQuoteUpdateManyWithoutJobNestedInput;
    invoices?: InvoicesUpdateManyWithoutJobNestedInput;
  };

  export type JobsUncheckedUpdateWithoutBelongs_toInput = {
    id?: IntFieldUpdateOperationsInput | number;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: BoolFieldUpdateOperationsInput | boolean;
    texted_to_client?: BoolFieldUpdateOperationsInput | boolean;
    status?: StringFieldUpdateOperationsInput | string;
    client_id?: IntFieldUpdateOperationsInput | number;
    title?: StringFieldUpdateOperationsInput | string;
    instructions?: NullableStringFieldUpdateOperationsInput | string | null;
    number?: StringFieldUpdateOperationsInput | string;
    schedule_type?: StringFieldUpdateOperationsInput | string;
    recurring_frequency?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    recurring_interval?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    day_of_week?: NullableStringFieldUpdateOperationsInput | string | null;
    day_of_year?: NullableStringFieldUpdateOperationsInput | string | null;
    duration?: NullableStringFieldUpdateOperationsInput | string | null;
    start_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    end_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    start_time?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    end_time?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    schedule_later?: BoolFieldUpdateOperationsInput | boolean;
    team?: NullableStringFieldUpdateOperationsInput | string | null;
    email_team?: BoolFieldUpdateOperationsInput | boolean;
    invoice_reminder?: BoolFieldUpdateOperationsInput | boolean;
    internal_notes?: NullableStringFieldUpdateOperationsInput | string | null;
    internal_attachment_url?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    link_to_related_invoices?: BoolFieldUpdateOperationsInput | boolean;
    line_items?: LineItemJobUncheckedUpdateManyWithoutJobNestedInput;
    job_requests?: JobRequestUncheckedUpdateManyWithoutJobNestedInput;
    job_quotes?: JobQuoteUncheckedUpdateManyWithoutJobNestedInput;
    invoices?: InvoicesUncheckedUpdateManyWithoutJobNestedInput;
  };

  export type JobsUncheckedUpdateManyWithoutBelongs_toInput = {
    id?: IntFieldUpdateOperationsInput | number;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: BoolFieldUpdateOperationsInput | boolean;
    texted_to_client?: BoolFieldUpdateOperationsInput | boolean;
    status?: StringFieldUpdateOperationsInput | string;
    client_id?: IntFieldUpdateOperationsInput | number;
    title?: StringFieldUpdateOperationsInput | string;
    instructions?: NullableStringFieldUpdateOperationsInput | string | null;
    number?: StringFieldUpdateOperationsInput | string;
    schedule_type?: StringFieldUpdateOperationsInput | string;
    recurring_frequency?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    recurring_interval?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    day_of_week?: NullableStringFieldUpdateOperationsInput | string | null;
    day_of_year?: NullableStringFieldUpdateOperationsInput | string | null;
    duration?: NullableStringFieldUpdateOperationsInput | string | null;
    start_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    end_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    start_time?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    end_time?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    schedule_later?: BoolFieldUpdateOperationsInput | boolean;
    team?: NullableStringFieldUpdateOperationsInput | string | null;
    email_team?: BoolFieldUpdateOperationsInput | boolean;
    invoice_reminder?: BoolFieldUpdateOperationsInput | boolean;
    internal_notes?: NullableStringFieldUpdateOperationsInput | string | null;
    internal_attachment_url?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    link_to_related_invoices?: BoolFieldUpdateOperationsInput | boolean;
  };

  export type QuotesUpdateWithoutBelongs_toInput = {
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: BoolFieldUpdateOperationsInput | boolean;
    texted_to_client?: BoolFieldUpdateOperationsInput | boolean;
    status?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    quote_number?: StringFieldUpdateOperationsInput | string;
    opportunity_rating?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    client_message?: NullableStringFieldUpdateOperationsInput | string | null;
    discount?: NullableFloatFieldUpdateOperationsInput | number | null;
    discount_unit?: NullableStringFieldUpdateOperationsInput | string | null;
    required_deposit?: NullableFloatFieldUpdateOperationsInput | number | null;
    link_to_releated_jobs?: BoolFieldUpdateOperationsInput | boolean;
    link_to_releated_invoices?: BoolFieldUpdateOperationsInput | boolean;
    client?: ClientsUpdateOneRequiredWithoutQuotesNestedInput;
    line_items?: LineItemQuoteUpdateManyWithoutQuoteNestedInput;
    tax?: TaxesUpdateOneWithoutQuotesNestedInput;
    requests?: QuoteRequestUpdateManyWithoutQuoteNestedInput;
    job_quotes?: JobQuoteUpdateManyWithoutQuoteNestedInput;
  };

  export type QuotesUncheckedUpdateWithoutBelongs_toInput = {
    id?: IntFieldUpdateOperationsInput | number;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: BoolFieldUpdateOperationsInput | boolean;
    texted_to_client?: BoolFieldUpdateOperationsInput | boolean;
    status?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    quote_number?: StringFieldUpdateOperationsInput | string;
    opportunity_rating?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    client_id?: IntFieldUpdateOperationsInput | number;
    client_message?: NullableStringFieldUpdateOperationsInput | string | null;
    discount?: NullableFloatFieldUpdateOperationsInput | number | null;
    discount_unit?: NullableStringFieldUpdateOperationsInput | string | null;
    tax_id?: IntFieldUpdateOperationsInput | number;
    required_deposit?: NullableFloatFieldUpdateOperationsInput | number | null;
    link_to_releated_jobs?: BoolFieldUpdateOperationsInput | boolean;
    link_to_releated_invoices?: BoolFieldUpdateOperationsInput | boolean;
    line_items?: LineItemQuoteUncheckedUpdateManyWithoutQuoteNestedInput;
    requests?: QuoteRequestUncheckedUpdateManyWithoutQuoteNestedInput;
    job_quotes?: JobQuoteUncheckedUpdateManyWithoutQuoteNestedInput;
  };

  export type QuotesUncheckedUpdateManyWithoutBelongs_toInput = {
    id?: IntFieldUpdateOperationsInput | number;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: BoolFieldUpdateOperationsInput | boolean;
    texted_to_client?: BoolFieldUpdateOperationsInput | boolean;
    status?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    quote_number?: StringFieldUpdateOperationsInput | string;
    opportunity_rating?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    client_id?: IntFieldUpdateOperationsInput | number;
    client_message?: NullableStringFieldUpdateOperationsInput | string | null;
    discount?: NullableFloatFieldUpdateOperationsInput | number | null;
    discount_unit?: NullableStringFieldUpdateOperationsInput | string | null;
    tax_id?: IntFieldUpdateOperationsInput | number;
    required_deposit?: NullableFloatFieldUpdateOperationsInput | number | null;
    link_to_releated_jobs?: BoolFieldUpdateOperationsInput | boolean;
    link_to_releated_invoices?: BoolFieldUpdateOperationsInput | boolean;
  };

  export type InvoicesUpdateWithoutBelongs_toInput = {
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: BoolFieldUpdateOperationsInput | boolean;
    texted_to_client?: BoolFieldUpdateOperationsInput | boolean;
    issued_date?: DateTimeFieldUpdateOperationsInput | Date | string;
    due_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    status?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    subject?: StringFieldUpdateOperationsInput | string;
    client_message?: StringFieldUpdateOperationsInput | string;
    internal_notes?: StringFieldUpdateOperationsInput | string;
    internalAttachmentUrl?: StringFieldUpdateOperationsInput | string;
    client?: ClientsUpdateOneRequiredWithoutInvoicesNestedInput;
    job?: JobsUpdateOneWithoutInvoicesNestedInput;
    tax?: TaxesUpdateOneWithoutInvoicesNestedInput;
    additional_line_items?: LineItemInvoiceUpdateManyWithoutInvoiceNestedInput;
  };

  export type InvoicesUncheckedUpdateWithoutBelongs_toInput = {
    id?: IntFieldUpdateOperationsInput | number;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: BoolFieldUpdateOperationsInput | boolean;
    texted_to_client?: BoolFieldUpdateOperationsInput | boolean;
    issued_date?: DateTimeFieldUpdateOperationsInput | Date | string;
    due_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    status?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    subject?: StringFieldUpdateOperationsInput | string;
    client_id?: IntFieldUpdateOperationsInput | number;
    job_id?: NullableIntFieldUpdateOperationsInput | number | null;
    tax_id?: NullableIntFieldUpdateOperationsInput | number | null;
    client_message?: StringFieldUpdateOperationsInput | string;
    internal_notes?: StringFieldUpdateOperationsInput | string;
    internalAttachmentUrl?: StringFieldUpdateOperationsInput | string;
    additional_line_items?: LineItemInvoiceUncheckedUpdateManyWithoutInvoiceNestedInput;
  };

  export type InvoicesUncheckedUpdateManyWithoutBelongs_toInput = {
    id?: IntFieldUpdateOperationsInput | number;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: BoolFieldUpdateOperationsInput | boolean;
    texted_to_client?: BoolFieldUpdateOperationsInput | boolean;
    issued_date?: DateTimeFieldUpdateOperationsInput | Date | string;
    due_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    status?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    subject?: StringFieldUpdateOperationsInput | string;
    client_id?: IntFieldUpdateOperationsInput | number;
    job_id?: NullableIntFieldUpdateOperationsInput | number | null;
    tax_id?: NullableIntFieldUpdateOperationsInput | number | null;
    client_message?: StringFieldUpdateOperationsInput | string;
    internal_notes?: StringFieldUpdateOperationsInput | string;
    internalAttachmentUrl?: StringFieldUpdateOperationsInput | string;
  };

  export type RequestsCreateManyClientInput = {
    id?: number;
    status: string;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: boolean;
    texted_to_client?: boolean;
    title: string;
    service_details: string;
    assessment_date: Date | string;
    backup_assessment__date?: Date | string | null;
    preferred_arrival_times?: string | null;
    on_site_assesment_required?: boolean;
    assessment_id: number;
    internal_notes: string;
    internalAttachmentUrl: string;
    link_to_releated_quotes?: boolean;
    link_to_releated_jobs?: boolean;
    link_to_releated_invoices?: boolean;
    belongs_to_id: number;
  };

  export type QuotesCreateManyClientInput = {
    id?: number;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: boolean;
    texted_to_client?: boolean;
    status: string;
    title: string;
    quote_number: string;
    opportunity_rating?: string | null;
    client_message?: string | null;
    discount?: number | null;
    discount_unit?: string | null;
    tax_id: number;
    required_deposit?: number | null;
    link_to_releated_jobs?: boolean;
    link_to_releated_invoices?: boolean;
    belongs_to_id: number;
  };

  export type JobsCreateManyClientInput = {
    id?: number;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: boolean;
    texted_to_client?: boolean;
    status: string;
    title: string;
    instructions?: string | null;
    number: string;
    schedule_type: string;
    recurring_frequency?: string | null;
    recurring_interval?: string | null;
    day_of_week?: string | null;
    day_of_year?: string | null;
    duration?: string | null;
    start_date?: Date | string | null;
    end_date?: Date | string | null;
    start_time?: Date | string | null;
    end_time?: Date | string | null;
    schedule_later?: boolean;
    team?: string | null;
    email_team?: boolean;
    invoice_reminder?: boolean;
    internal_notes?: string | null;
    internal_attachment_url?: string | null;
    link_to_related_invoices?: boolean;
    belongs_to_id: number;
  };

  export type InvoicesCreateManyClientInput = {
    id?: number;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: boolean;
    texted_to_client?: boolean;
    issued_date: Date | string;
    due_date?: Date | string | null;
    status: string;
    type: string;
    subject: string;
    job_id?: number | null;
    tax_id?: number | null;
    client_message: string;
    internal_notes: string;
    internalAttachmentUrl: string;
    belongs_to_id: number;
  };

  export type RequestsUpdateWithoutClientInput = {
    status?: StringFieldUpdateOperationsInput | string;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: BoolFieldUpdateOperationsInput | boolean;
    texted_to_client?: BoolFieldUpdateOperationsInput | boolean;
    title?: StringFieldUpdateOperationsInput | string;
    service_details?: StringFieldUpdateOperationsInput | string;
    assessment_date?: DateTimeFieldUpdateOperationsInput | Date | string;
    backup_assessment__date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    preferred_arrival_times?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    on_site_assesment_required?: BoolFieldUpdateOperationsInput | boolean;
    internal_notes?: StringFieldUpdateOperationsInput | string;
    internalAttachmentUrl?: StringFieldUpdateOperationsInput | string;
    link_to_releated_quotes?: BoolFieldUpdateOperationsInput | boolean;
    link_to_releated_jobs?: BoolFieldUpdateOperationsInput | boolean;
    link_to_releated_invoices?: BoolFieldUpdateOperationsInput | boolean;
    assessment?: AssessmentsUpdateOneRequiredWithoutRequestsNestedInput;
    quotes?: QuoteRequestUpdateManyWithoutRequestNestedInput;
    job_requests?: JobRequestUpdateManyWithoutRequestNestedInput;
    belongs_to?: UsersUpdateOneRequiredWithoutRequestsNestedInput;
  };

  export type RequestsUncheckedUpdateWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number;
    status?: StringFieldUpdateOperationsInput | string;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: BoolFieldUpdateOperationsInput | boolean;
    texted_to_client?: BoolFieldUpdateOperationsInput | boolean;
    title?: StringFieldUpdateOperationsInput | string;
    service_details?: StringFieldUpdateOperationsInput | string;
    assessment_date?: DateTimeFieldUpdateOperationsInput | Date | string;
    backup_assessment__date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    preferred_arrival_times?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    on_site_assesment_required?: BoolFieldUpdateOperationsInput | boolean;
    assessment_id?: IntFieldUpdateOperationsInput | number;
    internal_notes?: StringFieldUpdateOperationsInput | string;
    internalAttachmentUrl?: StringFieldUpdateOperationsInput | string;
    link_to_releated_quotes?: BoolFieldUpdateOperationsInput | boolean;
    link_to_releated_jobs?: BoolFieldUpdateOperationsInput | boolean;
    link_to_releated_invoices?: BoolFieldUpdateOperationsInput | boolean;
    belongs_to_id?: IntFieldUpdateOperationsInput | number;
    quotes?: QuoteRequestUncheckedUpdateManyWithoutRequestNestedInput;
    job_requests?: JobRequestUncheckedUpdateManyWithoutRequestNestedInput;
  };

  export type RequestsUncheckedUpdateManyWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number;
    status?: StringFieldUpdateOperationsInput | string;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: BoolFieldUpdateOperationsInput | boolean;
    texted_to_client?: BoolFieldUpdateOperationsInput | boolean;
    title?: StringFieldUpdateOperationsInput | string;
    service_details?: StringFieldUpdateOperationsInput | string;
    assessment_date?: DateTimeFieldUpdateOperationsInput | Date | string;
    backup_assessment__date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    preferred_arrival_times?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    on_site_assesment_required?: BoolFieldUpdateOperationsInput | boolean;
    assessment_id?: IntFieldUpdateOperationsInput | number;
    internal_notes?: StringFieldUpdateOperationsInput | string;
    internalAttachmentUrl?: StringFieldUpdateOperationsInput | string;
    link_to_releated_quotes?: BoolFieldUpdateOperationsInput | boolean;
    link_to_releated_jobs?: BoolFieldUpdateOperationsInput | boolean;
    link_to_releated_invoices?: BoolFieldUpdateOperationsInput | boolean;
    belongs_to_id?: IntFieldUpdateOperationsInput | number;
  };

  export type QuotesUpdateWithoutClientInput = {
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: BoolFieldUpdateOperationsInput | boolean;
    texted_to_client?: BoolFieldUpdateOperationsInput | boolean;
    status?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    quote_number?: StringFieldUpdateOperationsInput | string;
    opportunity_rating?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    client_message?: NullableStringFieldUpdateOperationsInput | string | null;
    discount?: NullableFloatFieldUpdateOperationsInput | number | null;
    discount_unit?: NullableStringFieldUpdateOperationsInput | string | null;
    required_deposit?: NullableFloatFieldUpdateOperationsInput | number | null;
    link_to_releated_jobs?: BoolFieldUpdateOperationsInput | boolean;
    link_to_releated_invoices?: BoolFieldUpdateOperationsInput | boolean;
    line_items?: LineItemQuoteUpdateManyWithoutQuoteNestedInput;
    tax?: TaxesUpdateOneWithoutQuotesNestedInput;
    requests?: QuoteRequestUpdateManyWithoutQuoteNestedInput;
    job_quotes?: JobQuoteUpdateManyWithoutQuoteNestedInput;
    belongs_to?: UsersUpdateOneRequiredWithoutQuotesNestedInput;
  };

  export type QuotesUncheckedUpdateWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: BoolFieldUpdateOperationsInput | boolean;
    texted_to_client?: BoolFieldUpdateOperationsInput | boolean;
    status?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    quote_number?: StringFieldUpdateOperationsInput | string;
    opportunity_rating?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    client_message?: NullableStringFieldUpdateOperationsInput | string | null;
    discount?: NullableFloatFieldUpdateOperationsInput | number | null;
    discount_unit?: NullableStringFieldUpdateOperationsInput | string | null;
    tax_id?: IntFieldUpdateOperationsInput | number;
    required_deposit?: NullableFloatFieldUpdateOperationsInput | number | null;
    link_to_releated_jobs?: BoolFieldUpdateOperationsInput | boolean;
    link_to_releated_invoices?: BoolFieldUpdateOperationsInput | boolean;
    belongs_to_id?: IntFieldUpdateOperationsInput | number;
    line_items?: LineItemQuoteUncheckedUpdateManyWithoutQuoteNestedInput;
    requests?: QuoteRequestUncheckedUpdateManyWithoutQuoteNestedInput;
    job_quotes?: JobQuoteUncheckedUpdateManyWithoutQuoteNestedInput;
  };

  export type QuotesUncheckedUpdateManyWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: BoolFieldUpdateOperationsInput | boolean;
    texted_to_client?: BoolFieldUpdateOperationsInput | boolean;
    status?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    quote_number?: StringFieldUpdateOperationsInput | string;
    opportunity_rating?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    client_message?: NullableStringFieldUpdateOperationsInput | string | null;
    discount?: NullableFloatFieldUpdateOperationsInput | number | null;
    discount_unit?: NullableStringFieldUpdateOperationsInput | string | null;
    tax_id?: IntFieldUpdateOperationsInput | number;
    required_deposit?: NullableFloatFieldUpdateOperationsInput | number | null;
    link_to_releated_jobs?: BoolFieldUpdateOperationsInput | boolean;
    link_to_releated_invoices?: BoolFieldUpdateOperationsInput | boolean;
    belongs_to_id?: IntFieldUpdateOperationsInput | number;
  };

  export type JobsUpdateWithoutClientInput = {
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: BoolFieldUpdateOperationsInput | boolean;
    texted_to_client?: BoolFieldUpdateOperationsInput | boolean;
    status?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    instructions?: NullableStringFieldUpdateOperationsInput | string | null;
    number?: StringFieldUpdateOperationsInput | string;
    schedule_type?: StringFieldUpdateOperationsInput | string;
    recurring_frequency?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    recurring_interval?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    day_of_week?: NullableStringFieldUpdateOperationsInput | string | null;
    day_of_year?: NullableStringFieldUpdateOperationsInput | string | null;
    duration?: NullableStringFieldUpdateOperationsInput | string | null;
    start_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    end_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    start_time?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    end_time?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    schedule_later?: BoolFieldUpdateOperationsInput | boolean;
    team?: NullableStringFieldUpdateOperationsInput | string | null;
    email_team?: BoolFieldUpdateOperationsInput | boolean;
    invoice_reminder?: BoolFieldUpdateOperationsInput | boolean;
    internal_notes?: NullableStringFieldUpdateOperationsInput | string | null;
    internal_attachment_url?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    link_to_related_invoices?: BoolFieldUpdateOperationsInput | boolean;
    line_items?: LineItemJobUpdateManyWithoutJobNestedInput;
    job_requests?: JobRequestUpdateManyWithoutJobNestedInput;
    job_quotes?: JobQuoteUpdateManyWithoutJobNestedInput;
    invoices?: InvoicesUpdateManyWithoutJobNestedInput;
    belongs_to?: UsersUpdateOneRequiredWithoutJobsNestedInput;
  };

  export type JobsUncheckedUpdateWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: BoolFieldUpdateOperationsInput | boolean;
    texted_to_client?: BoolFieldUpdateOperationsInput | boolean;
    status?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    instructions?: NullableStringFieldUpdateOperationsInput | string | null;
    number?: StringFieldUpdateOperationsInput | string;
    schedule_type?: StringFieldUpdateOperationsInput | string;
    recurring_frequency?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    recurring_interval?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    day_of_week?: NullableStringFieldUpdateOperationsInput | string | null;
    day_of_year?: NullableStringFieldUpdateOperationsInput | string | null;
    duration?: NullableStringFieldUpdateOperationsInput | string | null;
    start_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    end_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    start_time?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    end_time?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    schedule_later?: BoolFieldUpdateOperationsInput | boolean;
    team?: NullableStringFieldUpdateOperationsInput | string | null;
    email_team?: BoolFieldUpdateOperationsInput | boolean;
    invoice_reminder?: BoolFieldUpdateOperationsInput | boolean;
    internal_notes?: NullableStringFieldUpdateOperationsInput | string | null;
    internal_attachment_url?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    link_to_related_invoices?: BoolFieldUpdateOperationsInput | boolean;
    belongs_to_id?: IntFieldUpdateOperationsInput | number;
    line_items?: LineItemJobUncheckedUpdateManyWithoutJobNestedInput;
    job_requests?: JobRequestUncheckedUpdateManyWithoutJobNestedInput;
    job_quotes?: JobQuoteUncheckedUpdateManyWithoutJobNestedInput;
    invoices?: InvoicesUncheckedUpdateManyWithoutJobNestedInput;
  };

  export type JobsUncheckedUpdateManyWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: BoolFieldUpdateOperationsInput | boolean;
    texted_to_client?: BoolFieldUpdateOperationsInput | boolean;
    status?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    instructions?: NullableStringFieldUpdateOperationsInput | string | null;
    number?: StringFieldUpdateOperationsInput | string;
    schedule_type?: StringFieldUpdateOperationsInput | string;
    recurring_frequency?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    recurring_interval?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    day_of_week?: NullableStringFieldUpdateOperationsInput | string | null;
    day_of_year?: NullableStringFieldUpdateOperationsInput | string | null;
    duration?: NullableStringFieldUpdateOperationsInput | string | null;
    start_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    end_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    start_time?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    end_time?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    schedule_later?: BoolFieldUpdateOperationsInput | boolean;
    team?: NullableStringFieldUpdateOperationsInput | string | null;
    email_team?: BoolFieldUpdateOperationsInput | boolean;
    invoice_reminder?: BoolFieldUpdateOperationsInput | boolean;
    internal_notes?: NullableStringFieldUpdateOperationsInput | string | null;
    internal_attachment_url?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    link_to_related_invoices?: BoolFieldUpdateOperationsInput | boolean;
    belongs_to_id?: IntFieldUpdateOperationsInput | number;
  };

  export type InvoicesUpdateWithoutClientInput = {
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: BoolFieldUpdateOperationsInput | boolean;
    texted_to_client?: BoolFieldUpdateOperationsInput | boolean;
    issued_date?: DateTimeFieldUpdateOperationsInput | Date | string;
    due_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    status?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    subject?: StringFieldUpdateOperationsInput | string;
    client_message?: StringFieldUpdateOperationsInput | string;
    internal_notes?: StringFieldUpdateOperationsInput | string;
    internalAttachmentUrl?: StringFieldUpdateOperationsInput | string;
    job?: JobsUpdateOneWithoutInvoicesNestedInput;
    tax?: TaxesUpdateOneWithoutInvoicesNestedInput;
    additional_line_items?: LineItemInvoiceUpdateManyWithoutInvoiceNestedInput;
    belongs_to?: UsersUpdateOneRequiredWithoutInvoicesNestedInput;
  };

  export type InvoicesUncheckedUpdateWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: BoolFieldUpdateOperationsInput | boolean;
    texted_to_client?: BoolFieldUpdateOperationsInput | boolean;
    issued_date?: DateTimeFieldUpdateOperationsInput | Date | string;
    due_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    status?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    subject?: StringFieldUpdateOperationsInput | string;
    job_id?: NullableIntFieldUpdateOperationsInput | number | null;
    tax_id?: NullableIntFieldUpdateOperationsInput | number | null;
    client_message?: StringFieldUpdateOperationsInput | string;
    internal_notes?: StringFieldUpdateOperationsInput | string;
    internalAttachmentUrl?: StringFieldUpdateOperationsInput | string;
    belongs_to_id?: IntFieldUpdateOperationsInput | number;
    additional_line_items?: LineItemInvoiceUncheckedUpdateManyWithoutInvoiceNestedInput;
  };

  export type InvoicesUncheckedUpdateManyWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: BoolFieldUpdateOperationsInput | boolean;
    texted_to_client?: BoolFieldUpdateOperationsInput | boolean;
    issued_date?: DateTimeFieldUpdateOperationsInput | Date | string;
    due_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    status?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    subject?: StringFieldUpdateOperationsInput | string;
    job_id?: NullableIntFieldUpdateOperationsInput | number | null;
    tax_id?: NullableIntFieldUpdateOperationsInput | number | null;
    client_message?: StringFieldUpdateOperationsInput | string;
    internal_notes?: StringFieldUpdateOperationsInput | string;
    internalAttachmentUrl?: StringFieldUpdateOperationsInput | string;
    belongs_to_id?: IntFieldUpdateOperationsInput | number;
  };

  export type RequestsCreateManyAssessmentInput = {
    id?: number;
    status: string;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: boolean;
    texted_to_client?: boolean;
    title: string;
    service_details: string;
    assessment_date: Date | string;
    backup_assessment__date?: Date | string | null;
    preferred_arrival_times?: string | null;
    on_site_assesment_required?: boolean;
    client_id: number;
    internal_notes: string;
    internalAttachmentUrl: string;
    link_to_releated_quotes?: boolean;
    link_to_releated_jobs?: boolean;
    link_to_releated_invoices?: boolean;
    belongs_to_id: number;
  };

  export type RequestsUpdateWithoutAssessmentInput = {
    status?: StringFieldUpdateOperationsInput | string;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: BoolFieldUpdateOperationsInput | boolean;
    texted_to_client?: BoolFieldUpdateOperationsInput | boolean;
    title?: StringFieldUpdateOperationsInput | string;
    service_details?: StringFieldUpdateOperationsInput | string;
    assessment_date?: DateTimeFieldUpdateOperationsInput | Date | string;
    backup_assessment__date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    preferred_arrival_times?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    on_site_assesment_required?: BoolFieldUpdateOperationsInput | boolean;
    internal_notes?: StringFieldUpdateOperationsInput | string;
    internalAttachmentUrl?: StringFieldUpdateOperationsInput | string;
    link_to_releated_quotes?: BoolFieldUpdateOperationsInput | boolean;
    link_to_releated_jobs?: BoolFieldUpdateOperationsInput | boolean;
    link_to_releated_invoices?: BoolFieldUpdateOperationsInput | boolean;
    client?: ClientsUpdateOneRequiredWithoutRequestsNestedInput;
    quotes?: QuoteRequestUpdateManyWithoutRequestNestedInput;
    job_requests?: JobRequestUpdateManyWithoutRequestNestedInput;
    belongs_to?: UsersUpdateOneRequiredWithoutRequestsNestedInput;
  };

  export type RequestsUncheckedUpdateWithoutAssessmentInput = {
    id?: IntFieldUpdateOperationsInput | number;
    status?: StringFieldUpdateOperationsInput | string;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: BoolFieldUpdateOperationsInput | boolean;
    texted_to_client?: BoolFieldUpdateOperationsInput | boolean;
    title?: StringFieldUpdateOperationsInput | string;
    service_details?: StringFieldUpdateOperationsInput | string;
    assessment_date?: DateTimeFieldUpdateOperationsInput | Date | string;
    backup_assessment__date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    preferred_arrival_times?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    on_site_assesment_required?: BoolFieldUpdateOperationsInput | boolean;
    client_id?: IntFieldUpdateOperationsInput | number;
    internal_notes?: StringFieldUpdateOperationsInput | string;
    internalAttachmentUrl?: StringFieldUpdateOperationsInput | string;
    link_to_releated_quotes?: BoolFieldUpdateOperationsInput | boolean;
    link_to_releated_jobs?: BoolFieldUpdateOperationsInput | boolean;
    link_to_releated_invoices?: BoolFieldUpdateOperationsInput | boolean;
    belongs_to_id?: IntFieldUpdateOperationsInput | number;
    quotes?: QuoteRequestUncheckedUpdateManyWithoutRequestNestedInput;
    job_requests?: JobRequestUncheckedUpdateManyWithoutRequestNestedInput;
  };

  export type RequestsUncheckedUpdateManyWithoutAssessmentInput = {
    id?: IntFieldUpdateOperationsInput | number;
    status?: StringFieldUpdateOperationsInput | string;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: BoolFieldUpdateOperationsInput | boolean;
    texted_to_client?: BoolFieldUpdateOperationsInput | boolean;
    title?: StringFieldUpdateOperationsInput | string;
    service_details?: StringFieldUpdateOperationsInput | string;
    assessment_date?: DateTimeFieldUpdateOperationsInput | Date | string;
    backup_assessment__date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    preferred_arrival_times?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    on_site_assesment_required?: BoolFieldUpdateOperationsInput | boolean;
    client_id?: IntFieldUpdateOperationsInput | number;
    internal_notes?: StringFieldUpdateOperationsInput | string;
    internalAttachmentUrl?: StringFieldUpdateOperationsInput | string;
    link_to_releated_quotes?: BoolFieldUpdateOperationsInput | boolean;
    link_to_releated_jobs?: BoolFieldUpdateOperationsInput | boolean;
    link_to_releated_invoices?: BoolFieldUpdateOperationsInput | boolean;
    belongs_to_id?: IntFieldUpdateOperationsInput | number;
  };

  export type QuoteRequestCreateManyRequestInput = {
    id?: number;
    quoteId: number;
  };

  export type JobRequestCreateManyRequestInput = {
    id?: number;
    job_id: number;
  };

  export type QuoteRequestUpdateWithoutRequestInput = {
    quote?: QuotesUpdateOneRequiredWithoutRequestsNestedInput;
  };

  export type QuoteRequestUncheckedUpdateWithoutRequestInput = {
    id?: IntFieldUpdateOperationsInput | number;
    quoteId?: IntFieldUpdateOperationsInput | number;
  };

  export type QuoteRequestUncheckedUpdateManyWithoutRequestInput = {
    id?: IntFieldUpdateOperationsInput | number;
    quoteId?: IntFieldUpdateOperationsInput | number;
  };

  export type JobRequestUpdateWithoutRequestInput = {
    job?: JobsUpdateOneRequiredWithoutJob_requestsNestedInput;
  };

  export type JobRequestUncheckedUpdateWithoutRequestInput = {
    id?: IntFieldUpdateOperationsInput | number;
    job_id?: IntFieldUpdateOperationsInput | number;
  };

  export type JobRequestUncheckedUpdateManyWithoutRequestInput = {
    id?: IntFieldUpdateOperationsInput | number;
    job_id?: IntFieldUpdateOperationsInput | number;
  };

  export type LineItemQuoteCreateManyLine_itemInput = {
    id?: number;
    quote_id: number;
  };

  export type LineItemInvoiceCreateManyLine_itemInput = {
    id?: number;
    invoice_id: number;
  };

  export type LineItemJobCreateManyLine_itemInput = {
    id?: number;
    job_id: number;
  };

  export type LineItemQuoteUpdateWithoutLine_itemInput = {
    quote?: QuotesUpdateOneRequiredWithoutLine_itemsNestedInput;
  };

  export type LineItemQuoteUncheckedUpdateWithoutLine_itemInput = {
    id?: IntFieldUpdateOperationsInput | number;
    quote_id?: IntFieldUpdateOperationsInput | number;
  };

  export type LineItemQuoteUncheckedUpdateManyWithoutLine_itemInput = {
    id?: IntFieldUpdateOperationsInput | number;
    quote_id?: IntFieldUpdateOperationsInput | number;
  };

  export type LineItemInvoiceUpdateWithoutLine_itemInput = {
    invoice?: InvoicesUpdateOneRequiredWithoutAdditional_line_itemsNestedInput;
  };

  export type LineItemInvoiceUncheckedUpdateWithoutLine_itemInput = {
    id?: IntFieldUpdateOperationsInput | number;
    invoice_id?: IntFieldUpdateOperationsInput | number;
  };

  export type LineItemInvoiceUncheckedUpdateManyWithoutLine_itemInput = {
    id?: IntFieldUpdateOperationsInput | number;
    invoice_id?: IntFieldUpdateOperationsInput | number;
  };

  export type LineItemJobUpdateWithoutLine_itemInput = {
    job?: JobsUpdateOneRequiredWithoutLine_itemsNestedInput;
  };

  export type LineItemJobUncheckedUpdateWithoutLine_itemInput = {
    id?: IntFieldUpdateOperationsInput | number;
    job_id?: IntFieldUpdateOperationsInput | number;
  };

  export type LineItemJobUncheckedUpdateManyWithoutLine_itemInput = {
    id?: IntFieldUpdateOperationsInput | number;
    job_id?: IntFieldUpdateOperationsInput | number;
  };

  export type LineItemQuoteCreateManyQuoteInput = {
    id?: number;
    line_item_id: number;
  };

  export type QuoteRequestCreateManyQuoteInput = {
    id?: number;
    requestId: number;
  };

  export type JobQuoteCreateManyQuoteInput = {
    id?: number;
    job_id: number;
  };

  export type LineItemQuoteUpdateWithoutQuoteInput = {
    line_item?: LineItemsUpdateOneRequiredWithoutQuotesNestedInput;
  };

  export type LineItemQuoteUncheckedUpdateWithoutQuoteInput = {
    id?: IntFieldUpdateOperationsInput | number;
    line_item_id?: IntFieldUpdateOperationsInput | number;
  };

  export type LineItemQuoteUncheckedUpdateManyWithoutQuoteInput = {
    id?: IntFieldUpdateOperationsInput | number;
    line_item_id?: IntFieldUpdateOperationsInput | number;
  };

  export type QuoteRequestUpdateWithoutQuoteInput = {
    request?: RequestsUpdateOneRequiredWithoutQuotesNestedInput;
  };

  export type QuoteRequestUncheckedUpdateWithoutQuoteInput = {
    id?: IntFieldUpdateOperationsInput | number;
    requestId?: IntFieldUpdateOperationsInput | number;
  };

  export type QuoteRequestUncheckedUpdateManyWithoutQuoteInput = {
    id?: IntFieldUpdateOperationsInput | number;
    requestId?: IntFieldUpdateOperationsInput | number;
  };

  export type JobQuoteUpdateWithoutQuoteInput = {
    job?: JobsUpdateOneRequiredWithoutJob_quotesNestedInput;
  };

  export type JobQuoteUncheckedUpdateWithoutQuoteInput = {
    id?: IntFieldUpdateOperationsInput | number;
    job_id?: IntFieldUpdateOperationsInput | number;
  };

  export type JobQuoteUncheckedUpdateManyWithoutQuoteInput = {
    id?: IntFieldUpdateOperationsInput | number;
    job_id?: IntFieldUpdateOperationsInput | number;
  };

  export type LineItemJobCreateManyJobInput = {
    id?: number;
    line_item_id: number;
  };

  export type JobRequestCreateManyJobInput = {
    id?: number;
    request_id: number;
  };

  export type JobQuoteCreateManyJobInput = {
    id?: number;
    quote_id: number;
  };

  export type InvoicesCreateManyJobInput = {
    id?: number;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: boolean;
    texted_to_client?: boolean;
    issued_date: Date | string;
    due_date?: Date | string | null;
    status: string;
    type: string;
    subject: string;
    client_id: number;
    tax_id?: number | null;
    client_message: string;
    internal_notes: string;
    internalAttachmentUrl: string;
    belongs_to_id: number;
  };

  export type LineItemJobUpdateWithoutJobInput = {
    line_item?: LineItemsUpdateOneRequiredWithoutJobsNestedInput;
  };

  export type LineItemJobUncheckedUpdateWithoutJobInput = {
    id?: IntFieldUpdateOperationsInput | number;
    line_item_id?: IntFieldUpdateOperationsInput | number;
  };

  export type LineItemJobUncheckedUpdateManyWithoutJobInput = {
    id?: IntFieldUpdateOperationsInput | number;
    line_item_id?: IntFieldUpdateOperationsInput | number;
  };

  export type JobRequestUpdateWithoutJobInput = {
    request?: RequestsUpdateOneRequiredWithoutJob_requestsNestedInput;
  };

  export type JobRequestUncheckedUpdateWithoutJobInput = {
    id?: IntFieldUpdateOperationsInput | number;
    request_id?: IntFieldUpdateOperationsInput | number;
  };

  export type JobRequestUncheckedUpdateManyWithoutJobInput = {
    id?: IntFieldUpdateOperationsInput | number;
    request_id?: IntFieldUpdateOperationsInput | number;
  };

  export type JobQuoteUpdateWithoutJobInput = {
    quote?: QuotesUpdateOneRequiredWithoutJob_quotesNestedInput;
  };

  export type JobQuoteUncheckedUpdateWithoutJobInput = {
    id?: IntFieldUpdateOperationsInput | number;
    quote_id?: IntFieldUpdateOperationsInput | number;
  };

  export type JobQuoteUncheckedUpdateManyWithoutJobInput = {
    id?: IntFieldUpdateOperationsInput | number;
    quote_id?: IntFieldUpdateOperationsInput | number;
  };

  export type InvoicesUpdateWithoutJobInput = {
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: BoolFieldUpdateOperationsInput | boolean;
    texted_to_client?: BoolFieldUpdateOperationsInput | boolean;
    issued_date?: DateTimeFieldUpdateOperationsInput | Date | string;
    due_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    status?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    subject?: StringFieldUpdateOperationsInput | string;
    client_message?: StringFieldUpdateOperationsInput | string;
    internal_notes?: StringFieldUpdateOperationsInput | string;
    internalAttachmentUrl?: StringFieldUpdateOperationsInput | string;
    client?: ClientsUpdateOneRequiredWithoutInvoicesNestedInput;
    tax?: TaxesUpdateOneWithoutInvoicesNestedInput;
    additional_line_items?: LineItemInvoiceUpdateManyWithoutInvoiceNestedInput;
    belongs_to?: UsersUpdateOneRequiredWithoutInvoicesNestedInput;
  };

  export type InvoicesUncheckedUpdateWithoutJobInput = {
    id?: IntFieldUpdateOperationsInput | number;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: BoolFieldUpdateOperationsInput | boolean;
    texted_to_client?: BoolFieldUpdateOperationsInput | boolean;
    issued_date?: DateTimeFieldUpdateOperationsInput | Date | string;
    due_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    status?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    subject?: StringFieldUpdateOperationsInput | string;
    client_id?: IntFieldUpdateOperationsInput | number;
    tax_id?: NullableIntFieldUpdateOperationsInput | number | null;
    client_message?: StringFieldUpdateOperationsInput | string;
    internal_notes?: StringFieldUpdateOperationsInput | string;
    internalAttachmentUrl?: StringFieldUpdateOperationsInput | string;
    belongs_to_id?: IntFieldUpdateOperationsInput | number;
    additional_line_items?: LineItemInvoiceUncheckedUpdateManyWithoutInvoiceNestedInput;
  };

  export type InvoicesUncheckedUpdateManyWithoutJobInput = {
    id?: IntFieldUpdateOperationsInput | number;
    tags?: NullableJsonNullValueInput | InputJsonValue;
    emailed_to_client?: BoolFieldUpdateOperationsInput | boolean;
    texted_to_client?: BoolFieldUpdateOperationsInput | boolean;
    issued_date?: DateTimeFieldUpdateOperationsInput | Date | string;
    due_date?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    status?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    subject?: StringFieldUpdateOperationsInput | string;
    client_id?: IntFieldUpdateOperationsInput | number;
    tax_id?: NullableIntFieldUpdateOperationsInput | number | null;
    client_message?: StringFieldUpdateOperationsInput | string;
    internal_notes?: StringFieldUpdateOperationsInput | string;
    internalAttachmentUrl?: StringFieldUpdateOperationsInput | string;
    belongs_to_id?: IntFieldUpdateOperationsInput | number;
  };

  export type LineItemInvoiceCreateManyInvoiceInput = {
    id?: number;
    line_item_id: number;
  };

  export type LineItemInvoiceUpdateWithoutInvoiceInput = {
    line_item?: LineItemsUpdateOneRequiredWithoutInvoicesNestedInput;
  };

  export type LineItemInvoiceUncheckedUpdateWithoutInvoiceInput = {
    id?: IntFieldUpdateOperationsInput | number;
    line_item_id?: IntFieldUpdateOperationsInput | number;
  };

  export type LineItemInvoiceUncheckedUpdateManyWithoutInvoiceInput = {
    id?: IntFieldUpdateOperationsInput | number;
    line_item_id?: IntFieldUpdateOperationsInput | number;
  };

  /**
   * Aliases for legacy arg types
   */
  /**
   * @deprecated Use TaxesCountOutputTypeDefaultArgs instead
   */
  export type TaxesCountOutputTypeArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = TaxesCountOutputTypeDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use AddressesCountOutputTypeDefaultArgs instead
   */
  export type AddressesCountOutputTypeArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = AddressesCountOutputTypeDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use UsersCountOutputTypeDefaultArgs instead
   */
  export type UsersCountOutputTypeArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = UsersCountOutputTypeDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use ClientsCountOutputTypeDefaultArgs instead
   */
  export type ClientsCountOutputTypeArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = ClientsCountOutputTypeDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use AssessmentsCountOutputTypeDefaultArgs instead
   */
  export type AssessmentsCountOutputTypeArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = AssessmentsCountOutputTypeDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use RequestsCountOutputTypeDefaultArgs instead
   */
  export type RequestsCountOutputTypeArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = RequestsCountOutputTypeDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use LineItemsCountOutputTypeDefaultArgs instead
   */
  export type LineItemsCountOutputTypeArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = LineItemsCountOutputTypeDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use QuotesCountOutputTypeDefaultArgs instead
   */
  export type QuotesCountOutputTypeArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = QuotesCountOutputTypeDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use JobsCountOutputTypeDefaultArgs instead
   */
  export type JobsCountOutputTypeArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = JobsCountOutputTypeDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use InvoicesCountOutputTypeDefaultArgs instead
   */
  export type InvoicesCountOutputTypeArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = InvoicesCountOutputTypeDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use TaxesDefaultArgs instead
   */
  export type TaxesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = TaxesDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use AddressesDefaultArgs instead
   */
  export type AddressesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = AddressesDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use UsersDefaultArgs instead
   */
  export type UsersArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = UsersDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use ClientsDefaultArgs instead
   */
  export type ClientsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = ClientsDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use AssessmentsDefaultArgs instead
   */
  export type AssessmentsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = AssessmentsDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use RequestsDefaultArgs instead
   */
  export type RequestsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = RequestsDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use LineItemsDefaultArgs instead
   */
  export type LineItemsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = LineItemsDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use QuotesDefaultArgs instead
   */
  export type QuotesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = QuotesDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use LineItemQuoteDefaultArgs instead
   */
  export type LineItemQuoteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = LineItemQuoteDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use QuoteRequestDefaultArgs instead
   */
  export type QuoteRequestArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = QuoteRequestDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use JobsDefaultArgs instead
   */
  export type JobsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = JobsDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use LineItemJobDefaultArgs instead
   */
  export type LineItemJobArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = LineItemJobDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use JobRequestDefaultArgs instead
   */
  export type JobRequestArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = JobRequestDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use JobQuoteDefaultArgs instead
   */
  export type JobQuoteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = JobQuoteDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use InvoicesDefaultArgs instead
   */
  export type InvoicesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = InvoicesDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use LineItemInvoiceDefaultArgs instead
   */
  export type LineItemInvoiceArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
  > = LineItemInvoiceDefaultArgs<ExtArgs>;

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number;
  };

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF;
}
